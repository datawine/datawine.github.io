<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>dlopen-source-code</title>
    <url>/index.html</url>
    <content><![CDATA[<p>研究一下dlopen的源码。</p>
<span id="more"></span>

<p>通过调用链的形式分析dlopen源码。</p>
<p>首先，函数的入口是<code>dlopen (const char *file, int mode)</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *</span><br><span class="line"><span class="title function_">dlopen</span> <span class="params">(<span class="type">const</span> <span class="type">char</span> *file, <span class="type">int</span> mode)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> __dlopen (file, mode, RETURN_ADDRESS (<span class="number">0</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数跳转到了<code>__dlopen</code>，这个函数实际上做了两件事情，将<code>struct dlopen_args args</code>赋值，然后运行<code>dlopen_doit</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *</span><br><span class="line">__dlopen (<span class="type">const</span> <span class="type">char</span> *file, <span class="type">int</span> mode DL_CALLER_DECL)</span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line"> </span><br><span class="line"><span class="meta"># <span class="keyword">ifdef</span> SHARED</span></span><br><span class="line">  <span class="keyword">return</span> _dlerror_run (dlopen_doit, &amp;args) ? <span class="literal">NULL</span> : args.new;</span><br><span class="line"><span class="meta"># <span class="keyword">else</span></span></span><br><span class="line">  <span class="keyword">if</span> (_dlerror_run (dlopen_doit, &amp;args))</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">return</span> args.new;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中结构体<code>struct dlopen_args</code>是这样的：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dlopen_args</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *file; <span class="comment">/* The arguments for dlopen_doit.  */</span></span><br><span class="line">  <span class="type">int</span> mode;</span><br><span class="line">  <span class="type">void</span> *new; <span class="comment">/* The return value of dlopen_doit.  */</span></span><br><span class="line">  <span class="type">const</span> <span class="type">void</span> *caller; <span class="comment">/* The return value of dlopen_doit.  */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>然后<code>dlopen_doit</code>的函数则是调用了<code>__dl_open</code>函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">dlopen_doit</span> <span class="params">(<span class="type">void</span> *a)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">dlopen_args</span> *<span class="title">args</span> =</span> (<span class="keyword">struct</span> dlopen_args *) a;</span><br><span class="line">	... </span><br><span class="line">  args-&gt;new = GLRO(dl_open) (args-&gt;file ?: <span class="string">&quot;&quot;</span>, args-&gt;mode | __RTLD_DLOPEN,</span><br><span class="line">			     args-&gt;caller,</span><br><span class="line">			     args-&gt;file == <span class="literal">NULL</span> ? LM_ID_BASE : NS,</span><br><span class="line">			     __dlfcn_argc, __dlfcn_argv, __environ);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于<code>__dl_open</code>函数，实际上调用了<code>dl_open_worker</code>函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *</span><br><span class="line">_dl_open (<span class="type">const</span> <span class="type">char</span> *file, <span class="type">int</span> mode, <span class="type">const</span> <span class="type">void</span> *caller_dlopen, Lmid_t nsid,</span><br><span class="line">	  <span class="type">int</span> argc, <span class="type">char</span> *argv[], <span class="type">char</span> *env[])</span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">dl_open_args</span> <span class="title">args</span>;</span></span><br><span class="line">  args.file = file;</span><br><span class="line">  args.mode = mode;</span><br><span class="line">  args.caller_dlopen = caller_dlopen;</span><br><span class="line">  args.caller_dl_open = RETURN_ADDRESS (<span class="number">0</span>);</span><br><span class="line">  args.<span class="built_in">map</span> = <span class="literal">NULL</span>;</span><br><span class="line">  args.nsid = nsid;</span><br><span class="line">  args.argc = argc;</span><br><span class="line">  args.argv = argv;</span><br><span class="line">  args.env = env;</span><br><span class="line"> </span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *objname;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *errstring;</span><br><span class="line">  <span class="type">bool</span> malloced;</span><br><span class="line">  <span class="type">int</span> errcode = _dl_catch_error (&amp;objname, &amp;errstring, &amp;malloced,</span><br><span class="line">				 dl_open_worker, &amp;args);</span><br><span class="line">	... </span><br><span class="line">  <span class="keyword">return</span> args.<span class="built_in">map</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中关键的数据存储在<code>struct dl_open_args</code>内，它的结构如下所示</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dl_open_args</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *file;</span><br><span class="line">  <span class="type">int</span> mode;</span><br><span class="line">  <span class="type">const</span> <span class="type">void</span> *caller_dlopen; <span class="comment">/* This is the caller of dlopen().  */</span></span><br><span class="line">  <span class="type">const</span> <span class="type">void</span> *caller_dl_open; <span class="comment">/* This is the caller of _dl_open().  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">map</span>;</span></span><br><span class="line">  Lmid_t nsid; <span class="comment">/* Namespace ID.  */</span></span><br><span class="line">  <span class="type">int</span> argc;</span><br><span class="line">  <span class="type">char</span> **argv;</span><br><span class="line">  <span class="type">char</span> **env;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在<code>dl_open_worker</code>函数中，最重要的加载数据一步是通过调用<code>_dl_map_object</code>实现的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Load the named object.  */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">new</span>;</span></span><br><span class="line">args-&gt;<span class="built_in">map</span> = new = _dl_map_object (call_map, file, lt_loaded, <span class="number">0</span>,</span><br><span class="line">		    mode | __RTLD_CALLMAP, args-&gt;nsid);</span><br></pre></td></tr></table></figure>

<p>接下来就是<code>_dl_map_object</code>函数，其主要的内容如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *</span></span><br><span class="line"><span class="class"><span class="title">internal_function</span></span></span><br><span class="line"><span class="class">_<span class="title">dl_map_object</span> (<span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">loader</span>, <span class="title">const</span> <span class="title">char</span> *<span class="title">name</span>,</span></span><br><span class="line"><span class="class">		<span class="title">int</span> <span class="title">type</span>, <span class="title">int</span> <span class="title">trace_mode</span>, <span class="title">int</span> <span class="title">mode</span>, <span class="title">Lmid_t</span> <span class="title">nsid</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">int</span> fd;</span><br><span class="line">  <span class="type">char</span> *realname;</span><br><span class="line">  <span class="type">char</span> *name_copy;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">l</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">filebuf</span> <span class="title">fb</span>;</span></span><br><span class="line">	...</span><br><span class="line">  <span class="comment">/* Look for this name among those already loaded.  */</span></span><br><span class="line">  <span class="keyword">for</span> (l = GL(dl_ns)[nsid]._ns_loaded; l; l = l-&gt;l_next)</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="comment">/* If the requested name matches the soname of a loaded object,</span></span><br><span class="line"><span class="comment">	 use that object.  Elide this check for names that have not</span></span><br><span class="line"><span class="comment">	 yet been opened.  */</span></span><br><span class="line">      <span class="keyword">if</span> (__builtin_expect (l-&gt;l_faked, <span class="number">0</span>) != <span class="number">0</span> </span><br><span class="line">          || __builtin_expect (l-&gt;l_removed, <span class="number">0</span>) != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">if</span> (!_dl_name_match_p (name, l))</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">char</span> *soname;</span><br><span class="line"> 				<span class="keyword">if</span> (__builtin_expect (l-&gt;l_soname_added, <span class="number">1</span>) </span><br><span class="line">            || l-&gt;l_info[DT_SONAME] == <span class="literal">NULL</span>)</span><br><span class="line">	    	<span class="keyword">continue</span>;</span><br><span class="line"> </span><br><span class="line">	  		soname = ((<span class="type">const</span> <span class="type">char</span> *) D_PTR (l, l_info[DT_STRTAB])</span><br><span class="line">		    	+ l-&gt;l_info[DT_SONAME]-&gt;d_un.d_val);</span><br><span class="line">	  		<span class="keyword">if</span> (<span class="built_in">strcmp</span> (name, soname) != <span class="number">0</span>)</span><br><span class="line">	    		<span class="keyword">continue</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">/* We have a match on a new name -- cache it.  */</span></span><br><span class="line">        add_name_to_object (l, soname);</span><br><span class="line">        l-&gt;l_soname_added = <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line"> </span><br><span class="line">      <span class="comment">/* We have a match.  */</span></span><br><span class="line">      <span class="keyword">return</span> l;</span><br><span class="line">  &#125;</span><br><span class="line"> 	</span><br><span class="line">  ...</span><br><span class="line">  fd = open_path (name, namelen, mode &amp; __RTLD_SECURE, </span><br><span class="line">                  &amp;main_map-&gt;l_rpath_dirs, &amp;realname, &amp;fb, </span><br><span class="line">                  loader ?: main_map, LA_SER_RUNPATH, &amp;found_other_class);</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">  l = _dl_new_object (name_copy, name, type, loader,</span><br><span class="line">				      mode, nsid)) </span><br><span class="line">	</span><br><span class="line">   <span class="keyword">return</span> _dl_map_object_from_fd (name, fd, &amp;fb, realname, loader, type, mode, &amp;stack_end, nsid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中文件是通过<code>open_path</code>调用的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">open_path</span> <span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="type">size_t</span> namelen, <span class="type">int</span> secure,</span></span><br><span class="line"><span class="params">	   <span class="keyword">struct</span> r_search_path_struct *sps, <span class="type">char</span> **realname,</span></span><br><span class="line"><span class="params">	   <span class="keyword">struct</span> filebuf *fbp, <span class="keyword">struct</span> link_map *loader, <span class="type">int</span> whatcode,</span></span><br><span class="line"><span class="params">	   <span class="type">bool</span> *found_other_class)</span></span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">for</span> (cnt = <span class="number">0</span>; fd == <span class="number">-1</span> &amp;&amp; cnt &lt; ncapstr; ++cnt) &#123;</span><br><span class="line"> 			fd = open_verify (buf, fbp, loader, whatcode, found_other_class, </span><br><span class="line">                        <span class="literal">false</span>);</span><br><span class="line">			...</span><br><span class="line">		&#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (fd != <span class="number">-1</span>) &#123;</span><br><span class="line">	  	*realname = (<span class="type">char</span> *) <span class="built_in">malloc</span> (buflen);</span><br><span class="line">	  	<span class="keyword">if</span> (*realname != <span class="literal">NULL</span>)</span><br><span class="line">	    &#123;</span><br><span class="line">	      <span class="built_in">memcpy</span> (*realname, buf, buflen);</span><br><span class="line">	      <span class="keyword">return</span> fd; <span class="comment">// here return the fd</span></span><br><span class="line">	    &#125;</span><br><span class="line">	  	<span class="keyword">else</span></span><br><span class="line">	    &#123;</span><br><span class="line">	      <span class="comment">/* No memory for the name, we certainly won&#x27;t be able</span></span><br><span class="line"><span class="comment">		 to load and link it.  */</span></span><br><span class="line">	      __close (fd);</span><br><span class="line">	      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	    &#125;</span><br><span class="line">		&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Remember whether we found anything.  */</span></span><br><span class="line">    any |= here_any;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (*++dirs != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中<code>open_verify</code>函数通过调用<code>__libc_read</code>对ELF文件的文件头实现了读写。</p>
<p>接下来是<code>_dl_new_object</code>函数，它主要初始化一个新的<code>struct link_map*</code>数据结构，并把它加入到<code>loader</code>对应的单链中（猜测）。</p>
<p>最重要的是函数<code>_dl_map_object_from_fd</code>。这个函数包括了</p>
<ul>
<li>对<code>link_map</code>的二次查找，是否已经存在映射了.so文件的</li>
<li>提取ELF头文件信息（程序入口地址，头文件信息等）</li>
<li>对phdr（程序头表进行遍历），根据每个程序头的type类型做具体的操作</li>
<li>进行映射</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">maplength = loadcmds[nloadcmds - <span class="number">1</span>].allocend - loadcmds[<span class="number">0</span>].mapstart;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Now process the load commands and map segments into memory.</span></span><br><span class="line"><span class="comment">   This is responsible for filling in:</span></span><br><span class="line"><span class="comment">   l_map_start, l_map_end, l_addr, l_contiguous, l_text_end, l_phdr</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">errstring = _dl_map_segments (l, fd, header, type, loadcmds, nloadcmds,</span><br><span class="line">  maplength, has_holes, loader);</span><br></pre></td></tr></table></figure>

<ul>
<li>调用<code>mprotect</code>修改内存权限</li>
<li>修改TLS等设置</li>
<li>修改符号表</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Set up the symbol hash table.  */</span></span><br><span class="line">_dl_setup_hash (l);</span><br></pre></td></tr></table></figure>

<p>最后，是<code>_dl_map_segments</code>函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* This is a position-independent shared object.  We can let the</span></span><br><span class="line"><span class="comment">   kernel map it anywhere it likes, but we must have space for all</span></span><br><span class="line"><span class="comment">   the segments in their specified positions relative to the first.</span></span><br><span class="line"><span class="comment">   So we map the first segment without MAP_FIXED, but with its</span></span><br><span class="line"><span class="comment">   extent increased to cover all the segments.  Then we remove</span></span><br><span class="line"><span class="comment">   access from excess portion, and there is known sufficient space</span></span><br><span class="line"><span class="comment">   there to remap from the later segments.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   As a refinement, sometimes we have an address that we would</span></span><br><span class="line"><span class="comment">   prefer to map such objects at; but this is only a preference,</span></span><br><span class="line"><span class="comment">   the OS can do whatever it likes. */</span></span><br><span class="line">ElfW(Addr) mappref</span><br><span class="line">  = (ELF_PREFERRED_ADDRESS (loader, maplength,</span><br><span class="line">                            c-&gt;mapstart &amp; GLRO(dl_use_load_bias))</span><br><span class="line">     - MAP_BASE_ADDR (l));</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Remember which part of the address space this object uses.  */</span></span><br><span class="line">l-&gt;l_map_start = (ElfW(Addr)) __mmap ((<span class="type">void</span> *) mappref, maplength,</span><br><span class="line">                                      c-&gt;prot,</span><br><span class="line">                                      MAP_COPY|MAP_FILE,</span><br><span class="line">                                      fd, c-&gt;mapoff);</span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely ((<span class="type">void</span> *) l-&gt;l_map_start == MAP_FAILED))</span><br><span class="line">  <span class="keyword">return</span> DL_MAP_SEGMENTS_ERROR_MAP_SEGMENT;</span><br><span class="line"></span><br><span class="line">l-&gt;l_map_end = l-&gt;l_map_start + maplength;</span><br><span class="line">l-&gt;l_addr = l-&gt;l_map_start - c-&gt;mapstart;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (has_holes)</span><br><span class="line">  <span class="comment">/* Change protection on the excess portion to disallow all access;</span></span><br><span class="line"><span class="comment">     the portions we do not remap later will be inaccessible as if</span></span><br><span class="line"><span class="comment">     unallocated.  Then jump into the normal segment-mapping loop to</span></span><br><span class="line"><span class="comment">     handle the portion of the segment past the end of the file</span></span><br><span class="line"><span class="comment">     mapping.  */</span></span><br><span class="line">  __mprotect ((<span class="type">caddr_t</span>) (l-&gt;l_addr + c-&gt;mapend),</span><br><span class="line">              loadcmds[nloadcmds - <span class="number">1</span>].mapstart - c-&gt;mapend,</span><br><span class="line">              PROT_NONE);</span><br><span class="line"></span><br><span class="line">l-&gt;l_contiguous = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">goto</span> postmap;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>系统</category>
      </categories>
      <tags>
        <tag>dlopen</tag>
      </tags>
  </entry>
  <entry>
    <title>too-many-open-files-error</title>
    <url>/index.html</url>
    <content><![CDATA[<p>解决一下linux系统同时打开过多文件的问题。</p>
<span id="more"></span>

<h1 id="方法一：命令方式"><a href="#方法一：命令方式" class="headerlink" title="方法一：命令方式"></a>方法一：命令方式</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">这样就可以把当前用户的最大允许打开文件数量设置为2048了，但这种设置方法在重启后会还原为默认值。</span> </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">ulimit</span> -n命令非root用户只能设置到4096。</span> </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">想要设置到8192需要sudo权限或者root用户。</span></span><br><span class="line">ulimit -n 2048</span><br></pre></td></tr></table></figure>

<h1 id="方法二：修改配置文件"><a href="#方法二：修改配置文件" class="headerlink" title="方法二：修改配置文件"></a>方法二：修改配置文件</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim /etc/security/limits.conf  </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">在最后加入</span>  </span><br><span class="line">* soft nofile 4096  </span><br><span class="line">* hard nofile 4096 </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">或者只加入</span></span><br><span class="line">* - nofile 8192</span><br></pre></td></tr></table></figure>

<p><code>*</code>代表所有用户，可根据需要设置某一用户</p>
<h1 id="检查程序文件数"><a href="#检查程序文件数" class="headerlink" title="检查程序文件数"></a>检查程序文件数</h1><p>如果你对你的程序有一定的解的话，应该对程序打开文件数(链接数)上限有一定的估算，如果感觉数字异常，请使用第一步的<strong>lsof -p 进程id &gt; openfiles.log</strong>命令，获得当前占用句柄的全部详情进行分析。</p>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>git-submodule-modify</title>
    <url>/index.html</url>
    <content><![CDATA[<p>因为国外google代码仓库的东西访问不到，有可能导致submodule失效，需要修改 或者删除git子模块</p>
<span id="more"></span>

<h1 id="删除子模块"><a href="#删除子模块" class="headerlink" title="删除子模块"></a>删除子模块</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">逆初始化模块，其中&#123;MOD_NAME&#125;为模块目录，执行后可发现模块目录被清空</span></span><br><span class="line">git submodule deinit &#123;MOD_NAME&#125; </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除.gitmodules中记录的模块信息（--cached选项清除.git/modules中的缓存）</span></span><br><span class="line">git rm --cached &#123;MOD_NAME&#125; </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">提交更改到代码库，可观察到<span class="string">&#x27;.gitmodules&#x27;</span>内容发生变更</span></span><br><span class="line">git commit -am &quot;Remove a submodule.&quot; </span><br></pre></td></tr></table></figure>

<h1 id="更改子模块url"><a href="#更改子模块url" class="headerlink" title="更改子模块url"></a>更改子模块url</h1><p>修改<code>.gitmodules</code>文件中对应模块的<code>url</code>属性，然后更新到<code>.git/config</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git submodule sync</span><br><span class="line">git commit -am &quot;Update submodule url.&quot;</span><br></pre></td></tr></table></figure>

<p>更低版本可能会不能自动更行<code>.git/config</code>，这时需要手动更新。</p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>dylib-to-sharemem</title>
    <url>/index.html</url>
    <content><![CDATA[<p>想要将动态链接库拷贝到共享存储里运行。</p>
<span id="more"></span>

<h1 id="相关编译过程概述"><a href="#相关编译过程概述" class="headerlink" title="相关编译过程概述"></a>相关编译过程概述</h1><h2 id="概述-GCC工作的前三个阶段"><a href="#概述-GCC工作的前三个阶段" class="headerlink" title="概述 - GCC工作的前三个阶段"></a>概述 - GCC工作的前三个阶段</h2><h3 id="预编译"><a href="#预编译" class="headerlink" title="预编译"></a>预编译</h3><ul>
<li>处理宏定义和文件包含。<ul>
<li>宏定义：可以理解为递归地替换</li>
<li>文件包含：将包含在头文件中的声明拷贝到同一个文件内（<code>extern</code>）。但是这一步的本质是为了让编译器在生成.S文件时的符号表管理和语义检查不会出错。</li>
</ul>
</li>
</ul>
<h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p>编译器完成的工作有词法分析、语法分析、语义分析和代码生成（编译优化）。其中词法分析、语法分析和语义分析中涉及到错误处理。语法分析和语义分析还有代码生成涉及到符号表管理。其中，词法分析通过有限状态自动机分析、语法分析通过语法树的生成构建、语义分析则是对一些语义的检查（声明与定义、表达式和语句的正确性等）、代码生成就是翻译为汇编代码的过程。我们重点关注符号表管理。</p>
<ul>
<li>符号表管理：一个比较典型的符号表保存三个数据结构：变量表、函数表和串表。一种设计是，变量表和函数表使用哈希散列。串表保存的是程序中用到的字符串常量，用链表保存。</li>
</ul>
<h3 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h3><p>汇编器的构造与编译器大同小异，因为它本质上是汇编的编译器，汇编器的符号来源有四种：数据、标签、宏、外部符号。</p>
<p>其中</p>
<ul>
<li>标签用于表示一段内存区域的地址，可能来自于函数名</li>
<li>外部符号用于表示引用的其他文件的数据或标签。</li>
</ul>
<p>此时，已经开始生成ELF格式文件，所以我们比较关心汇编器的符号表和重定位表的操作。</p>
<p>汇编允许符号的后置定义，所以汇编器需要对程序进行两次扫描。第一次扫描的时候，汇编器将引用的不在符号表中的符号作为外部符号处理，添加到符号表。当扫描到符号的定义时，使用该符号的定义信息替换原有的符号信息。</p>
<h4 id="表信息生成"><a href="#表信息生成" class="headerlink" title="表信息生成"></a>表信息生成</h4><p>由前面的“ELF文件格式”一节可以知道可重定位目标文件的结构。其中段表、符号表和重定位表是最重要的三个表。</p>
<p>汇编器在第一次扫描时，将汇编信息的段信息导出为段表项，填充到段表。在第二遍扫描时，将符号信息导出为符号表项，填充到符号表，并在产生重定位的位置生成重定位项，填充重定位表。这里重点关注符号表和重定位表。</p>
<ul>
<li><p>符号表</p>
<ul>
<li>符号表中记录的符号信息包括数据定义符号、宏符号、代码标签、函数名等。是为链接器、调试器、反汇编器等服务等。</li>
<li>符号表中记录符号名、所在段、段内偏移、类型（global, local）</li>
<li>对于外部符号，统一设定为全局符号（因为链接器会对全局符号进行符号解析，忽略局部符号的内容）（这是否是普遍的做法？），所在段设为未知。</li>
</ul>
</li>
<li><p>重定位表</p>
<ul>
<li>重定位表中记录重定位符号名，重定位位置所在段，重定位位置段内偏移，重定位类型（相对&#x2F;绝对）。【<strong>这里需要注意的是，和符号表的所在段和段内偏移不一样，符号表的这两个属性是符号被定义时的位置，而重定义表中的所在段和段内偏移的属性是在被使用时的位置</strong>】</li>
</ul>
</li>
</ul>
<h2 id="链接重定位和位置无关代码"><a href="#链接重定位和位置无关代码" class="headerlink" title="链接重定位和位置无关代码"></a>链接重定位和位置无关代码</h2><p>在预编译、编译中所操作的符号表，并不是可执行文件所生成的符号表或重定位表。他们所用的符号表只是在编译过程中，为了执行语法和语义的错误检查而维护的中间变量。我们所真正关心的是最终生成的可执行文件的符号表和重定位表。链接主要负责的工作有地址空间分配、符号解析和重定位。链接器会将同名的段合并。</p>
<h3 id="链接过程中的重定位操作"><a href="#链接过程中的重定位操作" class="headerlink" title="链接过程中的重定位操作"></a>链接过程中的重定位操作</h3><p>相对重定位和绝对重定位</p>
<ul>
<li>相对重定位：使用一个相对地址的引用</li>
<li>绝对重定位，使用一个绝对地址的引用<ul>
<li>相对重定位地址&#x3D;重定位符号地址-重定位位置+重定位位置数据内容&#x3D;重定位符号地址-下一条指令地址</li>
</ul>
</li>
<li>【<strong>凡是对数据符号的引用都需要重定位，而对标签符号的引用，只有外部引用时才需要重定位。</strong>】调用本地声明的函数时，无论链接器如何调整<code>.text</code>字段，调用者和被调用者的相对位置都不会改变，所以不需要进行重定位。【如<code>call fun</code>，<code>call</code>指令内保存的相对地址不会变化。】</li>
<li>具体操作<ul>
<li>对于一般的直接引用符号地址的指令会使用绝对地址重定位，对于函数调用或者跳转指令会使用相对地址重定位。（这是否是普遍的做法？）</li>
</ul>
</li>
</ul>
<h3 id="位置无关代码"><a href="#位置无关代码" class="headerlink" title="位置无关代码"></a>位置无关代码</h3><p>位置无关代码，可以<strong>加载而无需重定位代码段部分</strong>。</p>
<h4 id="PIC数据引用"><a href="#PIC数据引用" class="headerlink" title="PIC数据引用"></a>PIC数据引用</h4><p>无论在内存中的何处加载一个目标模块，数据段与代码段的距离总是保持不变。所以PIC数据引用利用了这个特点。在数据段开始的地方设置了<strong>全局偏移量表</strong>（Global Offset Table，GOT）。每个被当前目标模块引用的全局数据目标都有一个8字节条目，编译器为GOT中的每个条目生成一个重定位记录。加载的时候，动态链接器会重定位【GOT中的每个条目】。这意味着动态链接器并不会重定位代码段的信息。</p>
<p>每个引用全局目标的目标模块都有自己的GOT。</p>
<h4 id="PIC函数调用（延迟绑定）"><a href="#PIC函数调用（延迟绑定）" class="headerlink" title="PIC函数调用（延迟绑定）"></a>PIC函数调用（延迟绑定）</h4><p>一个典型的应用程序常常使用共享库的很少一部分，而延迟绑定被提出解决这一问题。一个目标模块调用在共享库中的任何函数，就会有自己的GOT和PLT。延迟绑定依赖于两个部分</p>
<ul>
<li>过程连接表（PLT，Procedure Linkage Table）<ul>
<li>PLT是以16字节代码为单位（一个条目）构成的数组。PLT[0]跳转到动态链接器中，PLT[1]初始化执行环境，PLT[2]开始的条目调用用户代码调用的函数。</li>
</ul>
</li>
<li>全局偏移量表（GOT）<ul>
<li>GOT是以8字节的地址为单位构成的数组。GOT[0]和[1]包含动态链接器在解析函数地址时会使用的信息（addr of .dynamic &#x2F; addr of reloc entries）。GOT[2]是动态链接器在<code>ld-linux.so</code>中的入口点。其余每一条对应于一个被调用的函数，其地址需要在运行时被解析。每个条目都有一条对应的PLT条目。初始时，每个GOT条目都指向对应PLT条目的第二条指令。</li>
</ul>
</li>
</ul>
<p>整个过程如下（如被调用函数为func）：</p>
<p>第一次执行<code>call func</code></p>
<ul>
<li>程序经过三次寻址（跳转到PLT，查询GOT条目，跳转到GOT条目对应地址），程序跳转到PLT对应表项的第二条指令。</li>
<li>PLT表项的第二条指令，将函数的ID压入栈中，然后跳转到PLT[0]。</li>
<li>PLT[0]压入GOT[1]存放的参数（是什么？），然后通过GOT[2]跳转到动态链接器中。动态链接器通过函数ID和GOT[1]参数确定函数<code>func</code>地址。用得到的地址重写对应GOT表中的地址。</li>
</ul>
<p>第二次执行<code>call func</code></p>
<ul>
<li>程序仍然经过上面三次寻址（跳转到PLT，查询GOT条目，跳转到GOT条目对应地址），此时GOT条目对应地址为<code>func</code>地址。</li>
</ul>
<p><strong>一个问题：延迟绑定修改后的GOT地址是相对地址还是绝对地址？经过思考，应为绝对地址</strong></p>
<h2 id="位置无关代码的函数内部调用"><a href="#位置无关代码的函数内部调用" class="headerlink" title="位置无关代码的函数内部调用"></a>位置无关代码的函数内部调用</h2><p>使用一些简单的程序进行实验，对函数内部调用有基本的认识。使用<code>-R</code>查看dynamic relocation entries，使用<code>-d</code>查看反汇编结果，使用<code>-t</code>查看符号表内容，使用<code>-T</code>查看动态符号表内容。RIP寄存器存放着当前指令的地址。</p>
<h3 id="64位RIP寻址"><a href="#64位RIP寻址" class="headerlink" title="64位RIP寻址"></a>64位RIP寻址</h3><p>在没有RIP寻址之前，ELF文件的PIC实现大费周章。必须先调用一个函数拿到PC，再加上偏移地址来获得变量的地址或者GOT位置。RIP寻址则解决了这一问题，这让代码可以通过<code>offset(%rip)</code>的形式偏移寻址。</p>
<h3 id="调用全局数据符号（RIP寻址）-√"><a href="#调用全局数据符号（RIP寻址）-√" class="headerlink" title="调用全局数据符号（RIP寻址） √"></a>调用全局数据符号（RIP寻址） √</h3><p>和前面的讲述一致。完成编译的位置无关代码动态链接库调用static数据符号时，采用<code>offset(%rip)</code>的形式找到GOT对应表项。加载的时候GOT对应表项被链接器重定位。而符号本身（也许）是存放在全局变量区，属于数据段的一部分。同时，动态符号表中将产生对应的表项。尚不清楚全局数据符号的实际地址在什么得放，猜测存放在全局变量区。</p>
<h3 id="调用static数据符号（RIP寻址）-√"><a href="#调用static数据符号（RIP寻址）-√" class="headerlink" title="调用static数据符号（RIP寻址） √"></a>调用static数据符号（RIP寻址） √</h3><p>和前面的讲述一致。但是在动态符号表中没有相应表项。猜测符号本身是存放在全局变量区，属于数据段的一部分。</p>
<h3 id="调用函数内部数据符号-√"><a href="#调用函数内部数据符号-√" class="headerlink" title="调用函数内部数据符号 √"></a>调用函数内部数据符号 √</h3><p>栈内创建，《编译原理》书上说应通过程序运行时指针<code>sp</code>访问。实际是用栈底+偏移的方式。（<code>offset(%rbp)</code>）</p>
<h4 id="补充：call汇编指令（intel-user-manual-P694）"><a href="#补充：call汇编指令（intel-user-manual-P694）" class="headerlink" title="补充：call汇编指令（intel user manual. P694）"></a>补充：call汇编指令（intel user manual. P694）</h4><p><code>call</code>汇编指令有许多种形式，其中<code>e8 cd</code>代表字节 0xE8 后面跟着一个2字节操作数表示要跳转到的地址与当前地址的偏移量。 下文中的<code>call</code>在64位机器上启用<code>-fPIC</code>等编译选项后的执行方式正好为<code>e8 cd</code>格式。可以归纳在下面的情景下，都为相对寻址。</p>
<h3 id="调用外部函数符号"><a href="#调用外部函数符号" class="headerlink" title="调用外部函数符号"></a>调用外部函数符号</h3><p>调用外部函数符号时，从汇编文件产生时，就已经有的<code>call xxx@PLT</code>的调用形式了。反编译得到的结果可以验证这一点，<strong>同时可以肯定，含有<code>@PLT</code>的应为绝对地址，因为最终是通过GOT获得了外部函数地址，而GOT本身是绝对地址。前提是使用位置无关方法</strong>。</p>
<h3 id="调用static函数符号"><a href="#调用static函数符号" class="headerlink" title="调用static函数符号"></a>调用static函数符号</h3><p>调用static函数符号时，汇编文件产生的调用的形式为<code>call xxx</code>，同时汇编文件中没有<code>.globl</code>字段。程序运行时应为相对地址调用。</p>
<ul>
<li>假如开了<code>-O2</code>选项，编译器有可能（未验证过是否都会）将static声明的函数优化为硬代码插入调用其的函数中。凡是全局声明的函数，都不会被这样优化。</li>
</ul>
<h1 id="全局函数符号直接拷贝运行失败的原因"><a href="#全局函数符号直接拷贝运行失败的原因" class="headerlink" title="全局函数符号直接拷贝运行失败的原因"></a>全局函数符号直接拷贝运行失败的原因</h1><p>对于调用了全局函数符号的代码，直接拷贝最根本的原因应该在于PLT表和GOT表可能产生的错误：</p>
<ul>
<li>函数首先通过相对偏移跳转到对应的PLT表。此时，【能否找到PLT表】成为第一个问题。问题的关键在于【PLT表是否已经被复制过来】。</li>
<li>接下来需要通过查找GOT表中对应的条目，跳转到对应的GOT表位置。【能否找到GOT表】成为第二个问题。（确定GOT表的位置时采用的寻址方式需要确定）</li>
<li>接下来GOT表记录的绝对地址应该是已经被修改过的。但是因为是绝对地址，所以【这个地址一定是错误的】，这是第三个问题。</li>
<li>如果调用任何数据符号，通过偏移寻址能否找到的关键则在于【有没有将数据段也一并拷贝过来】。</li>
</ul>
<h1 id="全局函数符号的拷贝解决"><a href="#全局函数符号的拷贝解决" class="headerlink" title="全局函数符号的拷贝解决"></a>全局函数符号的拷贝解决</h1><p>首先需要保证【PLT表和数据段被拷贝到代码段的正确相对位置】，其次要保证【PLT表能够正确访问GOT表】，最后要保证【GOT表存储的值被全部修改】。</p>
<ul>
<li>预编译阶段：全部修改为static函数，这样所有东西都是通过相对寻址访问的了。</li>
<li>编译或汇编阶段：全部修改为static函数解析。</li>
<li>链接或加载阶段：编写llvm pass，将动态链接库中函数按照static方式解析。</li>
<li>程序运行阶段：将动态链接库加载到我们想要拷贝到的地址。</li>
</ul>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>动态链接库</tag>
        <tag>共享存储</tag>
      </tags>
  </entry>
  <entry>
    <title>matplotlib-chinese-font</title>
    <url>/index.html</url>
    <content><![CDATA[<p>matplotlib原生是不支持中文的，但是因为画图中文方便一点，所以解决了一下这个问题。</p>
<span id="more"></span>

<h1 id="查看字体目录位置"><a href="#查看字体目录位置" class="headerlink" title="查看字体目录位置"></a>查看字体目录位置</h1><p>首先进入python查看一下自己电脑的字体存放位置</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> matplotlib</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> matplotlib.matplotlib_fname()</span><br></pre></td></tr></table></figure>

<p>我的mac打印出的信息在</p>
<p><code>/Users/junxianshen/anaconda2/lib/python2.7/site-packages/matplotlib/mpl-data/matplotlibrc</code></p>
<p>字体目录就在</p>
<p><code>/Users/junxianshen/anaconda2/lib/python2.7/site-packages/matplotlib/mpl-data/fonts/ttf/</code></p>
<h1 id="下载并安装"><a href="#下载并安装" class="headerlink" title="下载并安装"></a>下载并安装</h1><p>然后下载一个黑体简体中文字体，比如在这里下</p>
<ul>
<li><a href="http://www.font5.com.cn/font_download.php?id=151&amp;part=1237887120">http://www.font5.com.cn/font_download.php?id=151&amp;part=1237887120</a></li>
</ul>
<p>然后复制到上面的字体目录中</p>
<h1 id="清空缓存"><a href="#清空缓存" class="headerlink" title="清空缓存"></a>清空缓存</h1><p>接下来移除缓存，我的mac缓存目录在<code>~/.matplotlib/</code>，我是把里面的东西都删掉了。</p>
<h1 id="正式使用"><a href="#正式使用" class="headerlink" title="正式使用"></a>正式使用</h1><p>在python中添加一些中文必须的东西，比如</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br></pre></td></tr></table></figure>

<p>然后使用的时候例如</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plt.plot(max_xval, max_cdf_yval)</span><br><span class="line">plt.xlabel(<span class="string">u&#x27;最大流量&#x27;</span>, fontproperties=<span class="string">&#x27;SimHei&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<ul>
<li>注意，<code>plt.xlabel()</code>中还可以添加<code>fontsize</code>属性，如<code>plt.xlabel(u&#39;横轴：时间&#39;,fontproperties = &#39;SimHei&#39;,fontsize = 20)</code></li>
</ul>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>matplotlib</tag>
      </tags>
  </entry>
  <entry>
    <title>smartnic-learning</title>
    <url>/index.html</url>
    <content><![CDATA[<p>总结smartNIC的相关知识，虽然没啥用（因为很多东西都是基于netdev interface，而实验上好像是虚拟端口，所以不是一个东西），但是为了以后可能会用，还是记一下。</p>
<span id="more"></span>

<h1 id="Agilio-smartNIC-user-guide"><a href="#Agilio-smartNIC-user-guide" class="headerlink" title="Agilio smartNIC user guide"></a>Agilio smartNIC user guide</h1><p>文档地址<a href="https://help.netronome.com/support/solutions/articles/36000049975-basic-firmware-user-guide">https://help.netronome.com/support/solutions/articles/36000049975-basic-firmware-user-guide</a></p>
<h2 id="hardware-installation"><a href="#hardware-installation" class="headerlink" title="hardware installation"></a>hardware installation</h2><h3 id="validation"><a href="#validation" class="headerlink" title="validation"></a>validation</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">lspci -d 19ee:</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">或</span></span><br><span class="line">lspci | grep -i Eth</span><br></pre></td></tr></table></figure>

<h2 id="driver-and-firmware"><a href="#driver-and-firmware" class="headerlink" title="driver and firmware"></a>driver and firmware</h2><h3 id="validating-the-driver"><a href="#validating-the-driver" class="headerlink" title="validating the driver"></a>validating the driver</h3><p>支持nfp driver的操作系统</p>
<table>
<thead>
<tr>
<th>operating system</th>
<th>kernel version</th>
</tr>
</thead>
<tbody><tr>
<td>Ubuntu 16.04</td>
<td>4.11+(PF)</td>
</tr>
<tr>
<td>RHEL 7.4+</td>
<td>Default</td>
</tr>
<tr>
<td>CentOS 7.4+</td>
<td>Default</td>
</tr>
</tbody></table>
<h4 id="confirm-upstreamed-nfp-driver"><a href="#confirm-upstreamed-nfp-driver" class="headerlink" title="confirm upstreamed nfp driver"></a>confirm upstreamed nfp driver</h4><p>Confirm that your current Operating System contains the upstreamed nfp module</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">modinfo nfp | head -3</span><br></pre></td></tr></table></figure>

<h4 id="confirm-thath-nfp-driver-is-loaded"><a href="#confirm-thath-nfp-driver-is-loaded" class="headerlink" title="confirm thath nfp driver is loaded"></a>confirm thath nfp driver is loaded</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">lsmode | grep nfp</span><br></pre></td></tr></table></figure>

<h3 id="smartNIC-netdev-interfaces"><a href="#smartNIC-netdev-interfaces" class="headerlink" title="smartNIC netdev interfaces"></a>smartNIC netdev interfaces</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">install agilio-nameing-policy package</span></span><br><span class="line">apt-get install agilio-naming-policy</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">nfp driver初始化之后就有新的netdev interfaces了</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">ip <span class="built_in">link</span></span></span><br></pre></td></tr></table></figure>

<h3 id="validating-the-firmware"><a href="#validating-the-firmware" class="headerlink" title="validating the firmware"></a>validating the firmware</h3><p>固件的版本和smartNIC能实现的功能有关，固件应该在<code>/lib/firmware/netronome/</code></p>
<p>固件版本可以通过</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">ethtool -i <span class="string">&quot;netdev interface&quot;</span></span></span><br><span class="line">ethtool -i enp6s0np0</span><br></pre></td></tr></table></figure>

<h3 id="upgrading-the-firmware"><a href="#upgrading-the-firmware" class="headerlink" title="upgrading the firmware"></a>upgrading the firmware</h3><h4 id="upgrading-firmware-via-the-netronome-repo"><a href="#upgrading-firmware-via-the-netronome-repo" class="headerlink" title="upgrading firmware via the netronome repo"></a>upgrading firmware via the netronome repo</h4><p>通过附录一的配置之后，就可以这样安装</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apt-get install agilio-nic-firmware</span><br></pre></td></tr></table></figure>

<h4 id="upgrading-firmware-from-package-installation"><a href="#upgrading-firmware-from-package-installation" class="headerlink" title="upgrading firmware from package installation"></a>upgrading firmware from package installation</h4><p>从support上下载之后</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">dpkg -i agilio-nic-firmware-*.deb</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">reload driver to load new firmware</span></span><br><span class="line">rmmod nfp; modprobe nfp</span><br></pre></td></tr></table></figure>

<h2 id="using-the-linux-driver"><a href="#using-the-linux-driver" class="headerlink" title="using the linux driver"></a>using the linux driver</h2><h3 id="configuring-interface-media-mode"><a href="#configuring-interface-media-mode" class="headerlink" title="configuring interface media mode"></a>configuring interface media mode</h3><p>对于老的内核不支持这样配置的，见附录C</p>
<h4 id="configuring-interface-link-speed"><a href="#configuring-interface-link-speed" class="headerlink" title="configuring interface link-speed"></a>configuring interface link-speed</h4><p>下面是agilio CX 25G smartNIC的示例</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># down respective interface(s)</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ip <span class="built_in">link</span> <span class="built_in">set</span> &lt;intf&gt; down</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># to set interface linkspeed to 10G</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ethtool -s &lt;intf&gt; speed 10000</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#NB. A driver reload is needed whenever a port’s speed is changed</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># reload driver for changes to take effect</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">rmmod nfp; modprobe nfp</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># to set interface linkspeed to 25G</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ethtool -s &lt;intf&gt; speed 25000</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># reload driver for changes to take effect</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">rmmod nfp; modprobe nfp</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># older driver/firmware may require a system reboot for changes to take effect</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">reboot</span></span><br></pre></td></tr></table></figure>

<h4 id="setting-interface-breakout-mode"><a href="#setting-interface-breakout-mode" class="headerlink" title="setting interface breakout mode"></a>setting interface breakout mode</h4><p>下面的命令只适用于kernel版本4.13之后，为Agilio CX 40G&#x2F;2x40G SmartNICs的示例</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># determine card’s pci address</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">lspci -kd 19ee:</span></span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># devlink dev show</span></span></span><br><span class="line">pci/0000:06:00.0</span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># devlink port</span></span></span><br><span class="line">pci/0000:06:00.0/0: type eth netdev enp6s0np0</span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># to put the first 40G port in breakout mode(4x10G)</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">devlink port <span class="built_in">split</span> pci/0000:06:00.0/0 count 4</span></span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># to configure the second 40G port on a beryllium(2x40G interfaces) in breakout mode(4x10G)</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">devlink port <span class="built_in">split</span> pci/0000:06:00.0/4 count 4</span></span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># to configure a port from breakout mode(4x10G) to single mode(40G)</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">devlink port unsplit pci/0000:06:00.0/4</span></span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># reload driver for changes to take effect</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">rmmod nfp; modprobe nfp</span></span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># older driver/firmware versions may require a system reboot for changes to take effect</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">reboot</span></span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># after reboot the port should be in breakout mode e.g.</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">devlink port</span></span><br><span class="line">pci/0000:06:00.0/0: type eth netdev enp6s0np0s0 split_group 0</span><br><span class="line">pci/0000:06:00.0/1: type eth netdev enp6s0np0s1 split_group 0</span><br><span class="line">pci/0000:06:00.0/2: type eth netdev enp6s0np0s2 split_group 0</span><br><span class="line">pci/0000:06:00.0/3: type eth netdev enp6s0np0s3 split_group 0</span><br></pre></td></tr></table></figure>

<h3 id="confirm-connectivity"><a href="#confirm-connectivity" class="headerlink" title="confirm connectivity"></a>confirm connectivity</h3><h4 id="allocating-IP-addresses"><a href="#allocating-IP-addresses" class="headerlink" title="allocating IP addresses"></a>allocating IP addresses</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># assign IP address to interface</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ip address add 10.0.0.2/24 dev ens1np0</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ip <span class="built_in">link</span> <span class="built_in">set</span> ens1np0 up</span></span><br></pre></td></tr></table></figure>

<h4 id="pinging-interfaces"><a href="#pinging-interfaces" class="headerlink" title="pinging interfaces"></a>pinging interfaces</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># ping IP from host on same subnet</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ping 10.0.0.2</span></span><br><span class="line"></span><br><span class="line">PING 10.0.0.2 (10.0.0.2) 56(84) bytes of data.</span><br><span class="line">64 bytes from 10.0.0.2: icmp_seq=3 ttl=64 time=0.067 ms</span><br><span class="line">64 bytes from 10.0.0.2: icmp_seq=4 ttl=64 time=0.062 ms</span><br></pre></td></tr></table></figure>

<h2 id="basic-performance-test"><a href="#basic-performance-test" class="headerlink" title="basic performance test"></a>basic performance test</h2><p>除了IRQ和RSS的配置之外，就是iperf和iperf3的一些基本用法</p>
<h3 id="set-IRQ-affinity"><a href="#set-IRQ-affinity" class="headerlink" title="set IRQ affinity"></a>set IRQ affinity</h3><p>IRQ用来平衡核之间的负载</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">wget https://raw.githubusercontent.com/Netronome/nfp-drv-kmods/master/tools/set_irq_affinity.sh</span></span><br></pre></td></tr></table></figure>

<p>样例输出</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">/nfp-drv-kmods/tools/set_irq_affinity.sh enXXXXnpX</span></span><br><span class="line"></span><br><span class="line">Device 0000:02:00.0 is on node 0 with cpus 0 1 2 3 4 5 6 7 8 9 20 21 22 23 24 25 26 27 28 29</span><br><span class="line">IRQ 181 to CPU 0     (irq: 00,00000001 xps: 03,00030003)</span><br><span class="line">IRQ 182 to CPU 1     (irq: 00,00000002 xps: 00,00000000)</span><br><span class="line">IRQ 183 to CPU 2     (irq: 00,00000004 xps: 0c,000c000c)</span><br><span class="line">IRQ 184 to CPU 3     (irq: 00,00000008 xps: 00,00000000)</span><br><span class="line">IRQ 185 to CPU 4     (irq: 00,00000010 xps: 30,00300030)</span><br><span class="line">IRQ 186 to CPU 5     (irq: 00,00000020 xps: 00,00000000)</span><br><span class="line">IRQ 187 to CPU 6     (irq: 00,00000040 xps: c0,00c000c0)</span><br><span class="line">IRQ 188 to CPU 7     (irq: 00,00000080 xps: 00,00000000)</span><br></pre></td></tr></table></figure>

<h3 id="install-iperf"><a href="#install-iperf" class="headerlink" title="install iperf"></a>install iperf</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apt-get install -y iperf</span><br></pre></td></tr></table></figure>

<h3 id="using-iperf"><a href="#using-iperf" class="headerlink" title="using iperf"></a>using iperf</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># server</span></span> </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">allocate ipv4 address to SmartNIC interface</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ip address add 10.0.0.1/24 dev ens1np0</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">launch iperf server</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">iperf -s</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># client</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">iperf -c 10.0.0.1 -P 4</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"> iperf -c 10.0.0.1 -P 4</span></span><br><span class="line">------------------------------------------------------------</span><br><span class="line">Client connecting to 10.1, TCP port 5001</span><br><span class="line">TCP window size: 85.0 KByte (default)</span><br><span class="line">------------------------------------------------------------</span><br><span class="line">[  5] local 10.0.0.2 port 56938 connected with 10.0.0.1 port 5001</span><br><span class="line">[  3] local 10.0.0.2 port 56932 connected with 10.0.0.1 port 5001</span><br><span class="line">[  4] local 10.0.0.2 port 56934 connected with 10.0.0.1 port 5001</span><br><span class="line">[  6] local 10.0.0.2 port 56936 connected with 10.0.0.1 port 5001</span><br><span class="line">[ ID] Interval       Transfer     Bandwidth</span><br><span class="line">[  6]  0.0-10.0 sec  11.9 GBytes  10.3 Gbits/sec</span><br><span class="line">[  3]  0.0-10.0 sec  9.85 GBytes  8.46 Gbits/sec</span><br><span class="line">[  4]  0.0-10.0 sec  11.9 GBytes  10.2 Gbits/sec</span><br><span class="line">[  5]  0.0-10.0 sec  10.2 GBytes  8.75 Gbits/sec</span><br><span class="line">[SUM] 0.0-10.0 sec  43.8 GBytes  37.7 Gbits/sec</span><br></pre></td></tr></table></figure>

<h3 id="using-iperf3"><a href="#using-iperf3" class="headerlink" title="using iperf3"></a>using iperf3</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># Server:</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">iperf3 -s -p 5001 &amp; iperf3 -s -p 5002 &amp; iperf3 -s -p 5003 &amp; iperf3 -s -p 5004 &amp;</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># Client:</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">iperf3 -c 102.0.0.6 -i 30 -p 5001 &amp; iperf3 -c 102.0.0.6 -i 30 -p 5002 &amp; iperf3 -c 102.0.0.6 -i 30 -p 5003 &amp; iperf3 -c 102.0.0.6 -i 30 -p 5004 &amp;</span></span><br><span class="line"></span><br><span class="line">Example output:</span><br><span class="line"></span><br><span class="line">[ ID] Interval           Transfer     Bandwidth</span><br><span class="line">[  5]   0.00-10.04  sec  0.00 Bytes  0.00 bits/sec                  sender</span><br><span class="line">[  5]   0.00-10.04  sec  9.39 GBytes  8.03 Gbits/sec                  receiver</span><br><span class="line">[  5]  10.00-10.04  sec  33.1 MBytes  7.77 Gbits/sec                 </span><br><span class="line">- - - - - - - - - - - - - - - - - - - - - - - - -</span><br><span class="line">[ ID] Interval           Transfer     Bandwidth</span><br><span class="line">[  5]   0.00-10.04  sec  0.00 Bytes  0.00 bits/sec                  sender</span><br><span class="line">[  5]   0.00-10.04  sec  9.86 GBytes  8.44 Gbits/sec                  receiver</span><br><span class="line">[  5]  10.00-10.04  sec  53.6 MBytes  11.8 Gbits/sec                 </span><br><span class="line">- - - - - - - - - - - - - - - - - - - - - - - - -</span><br><span class="line">[ ID] Interval           Transfer     Bandwidth</span><br><span class="line">[  5]   0.00-10.04  sec  0.00 Bytes  0.00 bits/sec                  sender</span><br><span class="line">[  5]   0.00-10.04  sec  11.9 GBytes  10.2 Gbits/sec                  receiver</span><br><span class="line">[  5]  10.00-10.04  sec  42.1 MBytes  9.43 Gbits/sec                 </span><br><span class="line">- - - - - - - - - - - - - - - - - - - - - - - - -</span><br><span class="line">[ ID] Interval           Transfer     Bandwidth</span><br><span class="line">[  5]   0.00-10.04  sec  0.00 Bytes  0.00 bits/sec                  sender</span><br><span class="line">[  5]   0.00-10.04  sec  10.2 GBytes  8.70 Gbits/sec                  receiver</span><br><span class="line"></span><br><span class="line">Total: 37.7 Gbits/sec</span><br><span class="line"></span><br><span class="line">95.49% of 40GbE link</span><br></pre></td></tr></table></figure>

<h2 id="basic-firmware-features"><a href="#basic-firmware-features" class="headerlink" title="basic firmware features"></a>basic firmware features</h2><p>这节主要介绍用ethtool查看和配置一些smartNIC的接口参数。</p>
<h3 id="multiple-queues"><a href="#multiple-queues" class="headerlink" title="multiple queues"></a>multiple queues</h3><p>smartNIC支持多个TX和RX队列。<code>-I</code>可以看到当前的队列，<code>-L</code>可以配置当前的队列。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ethtool -l ens1np0</span></span><br><span class="line">Channel parameters for ens1np0:</span><br><span class="line">Pre-set maximums:</span><br><span class="line">RX:             20</span><br><span class="line">TX:             20</span><br><span class="line">Other:          2</span><br><span class="line">Combined:       20</span><br><span class="line">Current hardware settings:</span><br><span class="line">RX:             0</span><br><span class="line">TX:             12</span><br><span class="line">Other:          2</span><br><span class="line">Combined:       8</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ethtool -L &lt;intf&gt; rx 0 tx 0 combined 8</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># rx 代表receive ring interrupts</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># tx 代表transmit ring interrupts</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># combined 代表interrupts that service both</span></span></span><br></pre></td></tr></table></figure>

<h3 id="receive-side-scaling-RSS"><a href="#receive-side-scaling-RSS" class="headerlink" title="receive side scaling(RSS)"></a>receive side scaling(RSS)</h3><p><code>-n</code>查看，<code>-N</code>修改，<code>-x</code>和<code>-X</code>修改和配置key</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ethtool -n ens1np0 rx-flow-hash tcp4</span></span><br><span class="line">TCP over IPV4 flows use these fields for computing Hash flow key:</span><br><span class="line">IP SA</span><br><span class="line">IP DA</span><br><span class="line">L4 bytes 0 &amp; 1 [TCP/UDP src port]</span><br><span class="line">L4 bytes 2 &amp; 3 [TCP/UDP dst port]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ethtool -n ens1np0 rx-flow-hash udp4</span></span><br><span class="line">UDP over IPV4 flows use these fields for computing Hash flow key:</span><br><span class="line">IP SA</span><br><span class="line">IP DA</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ethtool -N &lt;intf&gt; rx-flow-hash tcp4 sdfn</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ethtool -N &lt;intf&gt; rx-flow-hash udp4 sdfn</span></span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># flag details</span></span></span><br><span class="line">rx-flow-hash tcp4|udp4|ah4|esp4|sctp4|tcp6|udp6|ah6|esp6|sctp6m|v|t|s|d|f|n|r...</span><br><span class="line">                  Configures the hash options for the specified flow type.</span><br><span class="line"> </span><br><span class="line">                  m   Hash on the Layer 2 destination address of the rx packet.</span><br><span class="line">                  v   Hash on the VLAN tag of the rx packet.</span><br><span class="line">                  t   Hash on the Layer 3 protocol field of the rx packet.</span><br><span class="line">                  s   Hash on the IP source address of the rx packet.</span><br><span class="line">                  d   Hash on the IP destination address of the rx packet.</span><br><span class="line">                  f   Hash on bytes 0 and 1 of the Layer 4 header of the rx packet.</span><br><span class="line">                  n   Hash on bytes 2 and 3 of the Layer 4 header of the rx packet.</span><br><span class="line">                  r   Discard  all  packets  of this flow type. When this option is set, all other options are ignored.</span><br><span class="line">                      </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ethtool -x &lt;intf&gt;</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ethtool -X &lt;intf&gt; &lt;hkey&gt;</span></span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># flag details</span></span></span><br><span class="line">-x --show-rxfh-indir</span><br><span class="line">Retrieves the receive flow hash indirection table.</span><br><span class="line">-X --set-rxfh-indir</span><br><span class="line">Configures the receive flow hash indirection table.</span><br></pre></td></tr></table></figure>

<h3 id="view-interface-parameters"><a href="#view-interface-parameters" class="headerlink" title="view interface parameters"></a>view interface parameters</h3><p><code>-k</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ethtool -k ens1np0</span></span><br></pre></td></tr></table></figure>

<p>一些选项开关列举如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># rx-checksumming</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">enable</span> rx-checksumming</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ethtool -K ens1np0 rx on</span></span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">disable</span> rx-checksumming</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ethtool -K ens1np0 rx off</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#同理</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># tx-checksumming: tx</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># scatter and gather: sg</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># tcp-segmentation offload: tso</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># generic segmentation offload: gso</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># generic receive offload: gro</span></span></span><br></pre></td></tr></table></figure>

<h2 id="install-configuring-and-using-dpdk"><a href="#install-configuring-and-using-dpdk" class="headerlink" title="install configuring and using dpdk"></a>install configuring and using dpdk</h2><p>此处就略过了。</p>
<h2 id="附录内容"><a href="#附录内容" class="headerlink" title="附录内容"></a>附录内容</h2><ul>
<li>A：netronome repositories，装上面提到的一些应用</li>
<li>B：安装out-of-tree NFP Driver</li>
<li>C：使用BSP package（上面提到了kernel较老的时候如何configure interface）</li>
<li>D：使用dpdk-ns</li>
<li>E：updating flash</li>
<li>F：升级kernel</li>
<li>G：set_irq_affinity.sh Source（前面irq的替代脚本）</li>
</ul>
<h1 id="key-schedule"><a href="#key-schedule" class="headerlink" title="key schedule"></a>key schedule</h1><p><a href="https://github.com/goodnighthy/KeySched/tree/master/key_schedule">https://github.com/goodnighthy/KeySched/tree/master/key_schedule</a></p>
<h2 id="starting-and-stopping-using-upstart-ubuntu-14-04-and-centos-6"><a href="#starting-and-stopping-using-upstart-ubuntu-14-04-and-centos-6" class="headerlink" title="starting and stopping using upstart(ubuntu 14.04 and centos 6)"></a>starting and stopping using upstart(ubuntu 14.04 and centos 6)</h2><p>The RTE (NORMAL MODE) can be started&#x2F;stopped by calling: start&#x2F;stop nfp-sdk6-rte</p>
<p>The RTE(DEBUG MODE) can be started&#x2F;stopped by calling: start&#x2F;stop nfp-sdk6-rte-debug</p>
<p>The RTE(SIM MODE) can be started by calling: start&#x2F;stop nfp-sdk6-rte-sim Before using this Upstart configuration set NETRODIR to the SDK6 simulator installation directory in the installed file nfp-sdk6-rte-sim.conf</p>
<p>The Hardware Debug Server can be started by calling: start&#x2F;stop nfp-hwdbg-srv</p>
<p>To start the job at system ready uncomment the startup line in nfp-sdk6-rte.conf, nfp-sdk6-rte-debug.conf or nfp-hwdbg-srv.conf in &#x2F;etc&#x2F;init&#x2F;.</p>
<p>To check whether the RTE job started correctly and is still running use: status nfp-sdk6-rte (add -debug for DEBUG MODE or -sim for SIM MODE) if the status show stop&#x2F;waiting the RTE has stopped and an error probably occurred. Look at either the Upstart job log in &#x2F;var&#x2F;log&#x2F;upstart&#x2F;nfp-sdk6-rte.log (replace nfp-sdk6-rte with the job name you started) or look in &#x2F;var&#x2F;log&#x2F;nfp-sdk-rte.log for RTE only logs. To have a continuous live log open either log with tail -f <log_file_name>.log</p>
<h2 id="starting-and-stopping-using-systemd-ubuntu-16-04-and-centos-x2F-rhel-7"><a href="#starting-and-stopping-using-systemd-ubuntu-16-04-and-centos-x2F-rhel-7" class="headerlink" title="starting and stopping using systemd(ubuntu 16.04 and centos&#x2F;rhel 7)"></a>starting and stopping using systemd(ubuntu 16.04 and centos&#x2F;rhel 7)</h2><p>The RTE (NORMAL MODE) can be started&#x2F;stopped by calling: systemctl start&#x2F;stop nfp-sdk6-rte</p>
<p>The RTE(DEBUG MODE) can be started&#x2F;stopped by calling: systemctl start&#x2F;stop pnfp-sdk6-rte-debug</p>
<p>The RTE(SIM MODE) can be started&#x2F;stopped by calling: systemctl start&#x2F;stop nfp-sdk6-rte-sim Before using this Upstart configuration set NETRODIR to the SDK6 simulator installation directory in the file &#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;nfp-sdk6-rte-sim.service</p>
<p>The Hardware Debug Server can be started&#x2F;stopped by calling: systemctl start&#x2F;stop nfp-hwdbg-srv</p>
<p>To start the programs at system startup run the systemctl enable command for the specified service: systemctl enable nfp-sdk6-rte.service</p>
<p>To check whether the RTE service started correctly and is still running use: systemctl status nfp-sdk6-rte (add -debug for DEBUG MODE or -sim for SIM MODE) if the Active status show inactive (dead) the RTE has stopped and an error probably occurred. Look at either the Systemd journal or in the RTE logs for more detail on what error occurred.</p>
<p>For looking in the Systemd journal use the following command: journalctl -u nfp-sdk6-rte replace nfp-sdk6-rte with the service name you are using (ex nfp-sdk6-rte-debug or nfp-sdk6-rte-sim). Add the -f argument to follow the journal for a live log.</p>
<p>For only logs generated by the RTE look &#x2F;var&#x2F;log&#x2F;nfp-sdk-rte.log, for continuous live log open the log with tail -f &#x2F;var&#x2F;log&#x2F;nfp-sdk-rte.log</p>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>smartnic</tag>
      </tags>
  </entry>
  <entry>
    <title>ycsb-learning</title>
    <url>/index.html</url>
    <content><![CDATA[<p>主要总结Yahoo的数据库测试项目YCSB的使用（针对redis）。</p>
<span id="more"></span>

<p>github网址：<a href="https://github.com/brianfrankcooper/YCSB">https://github.com/brianfrankcooper/YCSB</a></p>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><ul>
<li><p>需要安装</p>
<ul>
<li>java</li>
<li>maven</li>
</ul>
</li>
<li><p>直接下载编译好的版本（不推荐）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -O --location https://github.com/brianfrankcooper/YCSB/releases/download/0.15.0/ycsb-0.15.0.tar.gz</span><br><span class="line">tar xfvz ycsb-0.15.0.tar.gz</span><br><span class="line">cd ycsb-0.15.0</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用java或者maven编译</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone http://github.com/brianfrankcooper/YCSB.git</span><br><span class="line">cd YCSB</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">只安装redis测试部分</span></span><br><span class="line">mvn -pl com.yahoo.ycsb:redis-binding -am clean package</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装全部测试功能</span></span><br><span class="line">mvn clean package</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>详细说明：<a href="https://github.com/brianfrankcooper/YCSB/wiki/Running-a-Workload">https://github.com/brianfrankcooper/YCSB/wiki/Running-a-Workload</a></p>
<p>运行workload一共有六个部分</p>
<ul>
<li>设置数据库</li>
<li>选择合适的DB interface</li>
<li>选择合适的负载</li>
<li>选择合适的runtime parameters</li>
<li>load选择好的workload</li>
<li>run选择好的workload</li>
</ul>
<h2 id="设置数据库"><a href="#设置数据库" class="headerlink" title="设置数据库"></a>设置数据库</h2><p>简要的说，就是创建名为<code>usertable</code>的表，因为ycsb默认的是对<code>usertable</code>进行相关操作。</p>
<p>而对于redis，则不需要相关的操作。</p>
<h2 id="选择合适的DB-interface"><a href="#选择合适的DB-interface" class="headerlink" title="选择合适的DB interface"></a>选择合适的DB interface</h2><p>YCSB的操作是通过DB interface来实现的。最基本的DB interface是<code>com.yahoo.ycsb.BasicDB</code>，会将输出输出到<code>System.out</code>里。可以通过继承DB interface来自定义DB interface，也可以使用原有的DB interface。</p>
<h2 id="选择合适的workload"><a href="#选择合适的workload" class="headerlink" title="选择合适的workload"></a>选择合适的workload</h2><p>当前版本提供了六种workload</p>
<h3 id="Workload-A-Update-heavy-workload"><a href="#Workload-A-Update-heavy-workload" class="headerlink" title="Workload A: Update heavy workload"></a>Workload A: Update heavy workload</h3><p>This workload has a mix of 50&#x2F;50 reads and writes. An application example is a session store recording recent actions.</p>
<h3 id="Workload-B-Read-mostly-workload"><a href="#Workload-B-Read-mostly-workload" class="headerlink" title="Workload B: Read mostly workload"></a>Workload B: Read mostly workload</h3><p>This workload has a 95&#x2F;5 reads&#x2F;write mix. Application example: photo tagging; add a tag is an update, but most operations are to read tags.</p>
<h3 id="Workload-C-Read-only"><a href="#Workload-C-Read-only" class="headerlink" title="Workload C: Read only"></a>Workload C: Read only</h3><p>This workload is 100% read. Application example: user profile cache, where profiles are constructed elsewhere (e.g., Hadoop).</p>
<h3 id="Workload-D-Read-latest-workload"><a href="#Workload-D-Read-latest-workload" class="headerlink" title="Workload D: Read latest workload"></a>Workload D: Read latest workload</h3><p>In this workload, new records are inserted, and the most recently inserted records are the most popular. Application example: user status updates; people want to read the latest.</p>
<h3 id="Workload-E-Short-ranges"><a href="#Workload-E-Short-ranges" class="headerlink" title="Workload E: Short ranges"></a>Workload E: Short ranges</h3><p>In this workload, short ranges of records are queried, instead of individual records. Application example: threaded conversations, where each scan is for the posts in a given thread (assumed to be clustered by thread id).</p>
<h3 id="Workload-F-Read-modify-write"><a href="#Workload-F-Read-modify-write" class="headerlink" title="Workload F: Read-modify-write"></a>Workload F: Read-modify-write</h3><p>In this workload, the client will read a record, modify it, and write back the changes. Application example: user database, where user records are read and modified by the user or to record user activity.</p>
<h3 id="自定义Workload"><a href="#自定义Workload" class="headerlink" title="自定义Workload"></a>自定义Workload</h3><p>当然也可以自定义workload：<a href="https://github.com/brianfrankcooper/YCSB/wiki/Implementing-New-Workloads">https://github.com/brianfrankcooper/YCSB/wiki/Implementing-New-Workloads</a></p>
<p>一般常用的workload property如<code>fieldcount</code>，<code>fieldlength</code>，<code>requestdistribution</code>等。</p>
<p>全部properties如下：</p>
<p>The property files used with the core workload generator can specify values for the following properties:</p>
<ul>
<li><strong>fieldcount</strong>: the number of fields in a record (default: 10)</li>
<li><strong>fieldlength</strong>: the size of each field (default: 100)</li>
<li><strong>readallfields</strong>: should reads read all fields (true) or just one (false) (default: true)</li>
<li><strong>readproportion</strong>: what proportion of operations should be reads (default: 0.95)</li>
<li><strong>updateproportion</strong>: what proportion of operations should be updates (default: 0.05)</li>
<li><strong>insertproportion</strong>: what proportion of operations should be inserts (default: 0)</li>
<li><strong>scanproportion</strong>: what proportion of operations should be scans (default: 0)</li>
<li><strong>readmodifywriteproportion</strong>: what proportion of operations should be read a record, modify it, write it back (default: 0)</li>
<li><strong>requestdistribution</strong>: what distribution should be used to select the records to operate on – uniform, zipfian or latest (default: uniform)</li>
<li><strong>maxscanlength</strong>: for scans, what is the maximum number of records to scan (default: 1000)</li>
<li><strong>scanlengthdistribution</strong>: for scans, what distribution should be used to choose the number of records to scan, for each scan, between 1 and maxscanlength (default: uniform)</li>
<li><strong>insertorder</strong>: should records be inserted in order by key (“ordered”), or in hashed order (“hashed”) (default: hashed)</li>
<li><strong>operationcount</strong>: number of operations to perform. If set to zero then YCSB will run until maxexecutiontime is reached (which by default is indefinitely). Note that if your workload or command line parameters do not specify an operation count it will defualt to zero.</li>
<li><strong>maxexecutiontime</strong>: maximum execution time in seconds. The benchmark runs until either the operation count has exhausted or the maximum specified time has elapsed, whichever is earlier. If unspecified the defualt is to run indefinitely.</li>
<li><strong>table</strong>: the name of the table (default: usertable)</li>
<li><strong>recordcount</strong>: number of records to load into the database initially (default: 0)</li>
<li><strong>core_workload_insertion_retry_limit</strong>: number of attempts for any failed insert operation (default: 0)</li>
<li><strong>core_workload_insertion_retry_interval</strong>: interval between retries, in seconds (default: 3)</li>
</ul>
<h2 id="选择合适的runtime-parameter"><a href="#选择合适的runtime-parameter" class="headerlink" title="选择合适的runtime parameter"></a>选择合适的runtime parameter</h2><p>主要是</p>
<ul>
<li><code>-threads</code> : <strong>the number of client threads</strong>.</li>
<li><code>-target</code> : <strong>the target number of operations per second</strong>.</li>
<li><code>-s</code> : <strong>status</strong>.十秒打印一次状态</li>
</ul>
<h2 id="load-data"><a href="#load-data" class="headerlink" title="load data"></a>load data</h2><p>需要指定<code>redis.host</code>，<code>redis.port</code>。（可以指定<code>redis.password</code>和<code>redis.cluster</code>）</p>
<p>以上参数也可以在命令中指定，比如</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./bin/ycsb load redis -s -P workloads/workloada -p &quot;redis.host=127.0.0.1&quot; -p &quot;redis.port=6379&quot;</span><br></pre></td></tr></table></figure>

<h2 id="run-data"><a href="#run-data" class="headerlink" title="run data"></a>run data</h2><p>同理</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./bin/ycsb run redis -s -P workloads/workloada -p &quot;redis.host=127.0.0.1&quot; -p &quot;redis.port=6379&quot;</span><br></pre></td></tr></table></figure>

<h1 id="一些注意事项"><a href="#一些注意事项" class="headerlink" title="一些注意事项"></a>一些注意事项</h1><h2 id="ycsb不支持对key的长度的修改"><a href="#ycsb不支持对key的长度的修改" class="headerlink" title="ycsb不支持对key的长度的修改"></a>ycsb不支持对key的长度的修改</h2><p>issue网址：<a href="https://github.com/brianfrankcooper/YCSB/issues/587">https://github.com/brianfrankcooper/YCSB/issues/587</a></p>
<p>ycsb对key命名规则是两种，<code>hashed</code>模式会生成<code>user</code>加固定长度的一串hash值，而<code>ordered</code>模式会按照<code>user</code>加顺序的方式来命名。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">insertorder=hashed      # user6284781860667377211, user8517097267634966620, user1820151046732198393</span><br><span class="line">insertorder=ordered     # user1, user2, user3032</span><br></pre></td></tr></table></figure>

<h2 id="ycsb运行时错误：Read-time-out"><a href="#ycsb运行时错误：Read-time-out" class="headerlink" title="ycsb运行时错误：Read time out"></a>ycsb运行时错误：Read time out</h2><p>错误类似于</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redis.clients.jedis.exceptions.JedisConnectionException: java.net.SocketTimeoutException: Read timed out</span><br><span class="line"></span><br><span class="line">at redis.clients.jedis.Protocol.process(Protocol.java:79)</span><br><span class="line">at redis.clients.jedis.Protocol.read(Protocol.java:131)</span><br><span class="line">at redis.clients.jedis.Connection.getIntegerReply(Connection.java:188)</span><br><span class="line">at redis.clients.jedis.Jedis.sismember(Jedis.java:1266)</span><br></pre></td></tr></table></figure>

<p>当数据量变大之后，延时可能会变成几秒，而Jedis默认的是<code>2</code>秒的超时限制。</p>
<p>修改redis的src文件夹的RedisClient.java</p>
<p>将</p>
<p><code>jedis = new Jedis(host, port);</code></p>
<p>修改为</p>
<p><code>jedis = new Jedis(host, port, 10000);</code></p>
<p>即从默认的2秒上升为10秒。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li>ycsb github地址：<a href="https://github.com/brianfrankcooper/YCSB">https://github.com/brianfrankcooper/YCSB</a></li>
<li>ycsb 流程介绍：<a href="https://github.com/brianfrankcooper/YCSB/wiki/Running-a-Workload">https://github.com/brianfrankcooper/YCSB/wiki/Running-a-Workload</a></li>
<li>ycsb workload介绍：<a href="https://github.com/brianfrankcooper/YCSB/wiki/Implementing-New-Workloads">https://github.com/brianfrankcooper/YCSB/wiki/Implementing-New-Workloads</a></li>
<li>ycsb 不支持对key长度的修改 issue网址：<a href="https://github.com/brianfrankcooper/YCSB/issues/587">https://github.com/brianfrankcooper/YCSB/issues/587</a></li>
<li>ycsb 运行时错误：read time out 解决方法博客网址：<a href="https://github.com/brianfrankcooper/YCSB/issues/587">https://github.com/brianfrankcooper/YCSB/issues/587</a></li>
</ul>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>ycsb</tag>
      </tags>
  </entry>
  <entry>
    <title>sync-server-time</title>
    <url>/index.html</url>
    <content><![CDATA[<p>最近在make的时候发现server上的时间落后于我本地的时间，查了一下发现只要一条命令就能巧妙把server时间和互联网时间同步。</p>
<span id="more"></span>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo date -s &quot;$(wget -qSO- --max-redirect=0 google.com 2&gt;&amp;1 | grep Date: | cut -d&#x27; &#x27; -f5-8)Z&quot;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>2018年网络攻防小学期</title>
    <url>/network-attack-and-defense-semester.html</url>
    <content><![CDATA[<p>收录2018年网络攻防小学期的一些东西</p>
<span id="more"></span>

<ul>
<li><a href="https://datawine.github.io/%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2%E5%B0%8F%E5%AD%A6%E6%9C%9F%EF%BC%88%E4%B8%80%EF%BC%89%E7%BD%91%E7%BB%9C%E4%BE%A6%E6%9F%A5%E4%B8%8E%E5%8F%96%E8%AF%81%E5%88%86%E6%9E%90.html">网络攻防小学期（一）网络侦查与取证分析</a></li>
<li><a href="https://datawine.github.io/%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2%E5%B0%8F%E5%AD%A6%E6%9C%9F%EF%BC%88%E4%BA%8C%EF%BC%89%E4%BF%A1%E6%81%AF%E9%9A%90%E8%97%8F%E4%B8%8E%E4%BF%9D%E5%AF%86-%E5%AF%86%E7%A0%81/">网络攻防小学期（二）信息隐藏与保密&#x2F;密码</a></li>
<li><a href="https://datawine.github.io/%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2%E5%B0%8F%E5%AD%A6%E6%9C%9F%EF%BC%88%E4%B8%89%EF%BC%89%E7%BD%91%E7%AB%99%E5%AE%89%E5%85%A8/">网络攻防小学期（三）网站安全</a></li>
<li><a href="https://datawine.github.io/%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2%E5%B0%8F%E5%AD%A6%E6%9C%9F%EF%BC%88%E5%9B%9B%EF%BC%89%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E4%B8%8E%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%BC%8F%E6%B4%9E/">网络攻防小学期（四）逆向工程与二进制漏洞</a></li>
<li><a href="https://datawine.github.io/%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2%EF%BC%9AM1%E5%8D%A1%E5%B0%8F%E5%AE%9E%E9%AA%8C/">网络攻防：M1卡小实验</a></li>
<li><a href="https://datawine.github.io/%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2%EF%BC%9AM1%E5%8D%A1%E5%A4%A7%E5%AE%9E%E9%AA%8C/">网络攻防：M1卡大实验</a></li>
</ul>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>网络攻防</tag>
      </tags>
  </entry>
  <entry>
    <title>change-python-default-version</title>
    <url>/index.html</url>
    <content><![CDATA[<p>服务器上用的python默认是python3，需要改成python2</p>
<span id="more"></span>

<h1 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h1><p>修改别名，在<code>~/.bashrc</code>中修改</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alias python=python2</span><br></pre></td></tr></table></figure>

<h1 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h1><p>但是如果是在程序中调用有可能仍然是原来的python(具体我不太清楚，但是在跑一个项目的时候，他调用的python仍然是python3)。而且别的地方也找不到别名了。按理说python的默认版本应该是python2才对，但是也没有办法，只能硬着头皮改，毕竟项目还是要跑的啊。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">sudo update-alternatives --install &lt;<span class="built_in">link</span>&gt; &lt;name&gt; &lt;path&gt; &lt;priority&gt;</span></span><br><span class="line">sudo update-alternatives --install /usr/bin/python python /usr/bin/python2 10</span><br></pre></td></tr></table></figure>

<p>搞定。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://stackoverflow.com/questions/41986507/unable-to-set-default-python-version-to-python3-in-ubuntu">https://stackoverflow.com/questions/41986507/unable-to-set-default-python-version-to-python3-in-ubuntu</a></li>
</ul>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>docker-cgroup</title>
    <url>/docker-cgroup.html</url>
    <content><![CDATA[<p>好像默认的只有<code>sudo</code>有docker相关权限，普通用户<code>docker run hello-world</code>会有权限报错，解决方法如下</p>
<span id="more"></span>

<h1 id="具体错误"><a href="#具体错误" class="headerlink" title="具体错误"></a>具体错误</h1><p>如果直接运行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run hello-world</span><br></pre></td></tr></table></figure>

<p>产生错误</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker: Got permission denied while trying to connect to the Docker daemon socket at unix:///var/run/docker.sock: Post http://%2Fvar%2Frun%2Fdocker.sock/v1.35/containers/create: dial unix /var/run/docker.sock: connect: permission denied.See &#x27;docker run --help&#x27;.</span><br></pre></td></tr></table></figure>

<h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><p>创建docker group</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo groupadd docker</span><br></pre></td></tr></table></figure>

<p>把当前用户加入docker group</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo usermod -aG docker $USER</span><br></pre></td></tr></table></figure>

<p>登出再登入，此时可以直接运行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run hello-world</span><br></pre></td></tr></table></figure>

<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://stackoverflow.com/questions/48957195/how-to-fix-docker-got-permission-denied-issue">https://stackoverflow.com/questions/48957195/how-to-fix-docker-got-permission-denied-issue</a></li>
</ul>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
</search>
