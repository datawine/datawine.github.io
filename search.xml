<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>论文阅读</title>
    <url>/paper-reading.html</url>
    <content><![CDATA[<p>论文阅读列表</p>
<span id="more"></span>
<h1 id="asplos">ASPLOS</h1>
<h2 id="section">2016</h2>
<ul>
<li><a
href="https://datawine.github.io/asplos16-CloudSeer-Workflow-Monitoring-of-Cloud-Infrastructures-via-Interleaved-Logs.html">CloudSeer:
Workflow Monitoring of Cloud Infrastructures via Interleaved
Logs</a>：获得log的原始数据，用时序关系为边的自动机构造workflow图，获得workflow的异常。难点在于异步和并发带来的interleaved。
通过fork和join解决异步、通过标识符集解决并行问题。</li>
</ul>
<h2 id="section-1">2022</h2>
<ul>
<li><a
href="https://datawine.github.io/asplos22-IceBreaker-Warming-Serverless-Functions-Better-with-Heterogeneity.html">IceBreaker:
Warming Serverless Functions Better with
Heterogeneity</a>：利用异质化机器的区别来优化serverless
function的warmup</li>
<li><a
href="https://datawine.github.io/asplos22-INFless-A-Native-Serverless-System-for-Low-Latency-High-Throughput-Inference.html">INFless:
A Native Serverless System for Low Latency High Throughput
Inference</a>：主要对机器学习在serverless上的应用进行了适配</li>
<li><a
href="https://datawine.github.io/asplos22-FaaSFlow-Enable-Efficient-Workflow-Execution-for-Function-as-a-Service.html">FaaSFlow:
Enable Efficient Workflow Execution for
Function-as-a-Service</a>：主要对serverless的workflow进行了优化，改成了分布式函数状态存储和in-memory的数据传输</li>
<li><a
href="https://datawine.github.io/asplos22-Serverless-Computing-on-Heterogeneous-Computers.html">Serverless
Computing on Heterogeneous
Computers</a>：提出了一个FPGA+CPU+DPU的serverless平台，主要工作是做兼容的</li>
</ul>
<h1 id="atc">ATC</h1>
<h2 id="section-2">2015</h2>
<ul>
<li><a
href="https://datawine.github.io/atc15-Log2-A-Cost-Aware-Logging-Mechanism-for-Performance-Diagnosis.html">Log2:
A Cost-Aware Logging Mechanism for Performance
Diagnosis</a>：文章解决一个核心问题：whether to
log。这个log和传统的log不一样，这个log的意思是Monitored Code
Region的执行时间。论文用了两层filter，本地过滤器负责丢弃琐碎的日志请求，全局过滤器负责将排名靠前的日志请求flush到磁盘上。</li>
</ul>
<h2 id="section-3">2019</h2>
<ul>
<li><a
href="https://datawine.github.io/atc19-The-Design-and-Operation-of-CloudLab.html">The
Design and Operation of
CloudLab</a>：主要是讲分布式实验平台CloudLab的综述</li>
</ul>
<h1 id="eurosys">EuroSys</h1>
<h2 id="section-4">2018</h2>
<ul>
<li><a
href="https://datawine.github.io/eurosys18-Universal-context-propagation-for-distributed-system-instrumentation.html">Universal
context propagation for distributed system
instrumentation</a>：提出分层和baggage
context来解决分布式系统中instrumentation的context
propagation问题。核心思想就是分层和解耦。</li>
</ul>
<h2 id="section-5">2022</h2>
<ul>
<li><a
href="https://datawine.github.io/eurosys22-DeepRest-Deep-Resource-Estimation-for-Interactive-Microservices.html">DeepRest:
Deep Resource Estimation for Interactive
Microservices</a>：用深度学习的方法，提出API-based，估计微服务资源使用量</li>
<li><a
href="https://datawine.github.io/eurosys22-Fireworks-A-Fast-Efficient-and-Safe-Serverless-Framework-using-VM-level-post-JIT-Snapshot.html">Fireworks:
A Fast, Efficient, and Safe Serverless Framework using VM-level post-JIT
Snapshot</a>：serverless加速。通过一个train的过程，在entry
point前面JIT再snapshot</li>
<li><a
href="https://datawine.github.io/eurosys22-Jiffy-Elastic-Far-Memory-for-Stateful-Serverless-Analytics.html">Jiffy:
Elastic Far-Memory for Stateful Serverless
Analytics</a>：很不错的一篇工作。主要是serverless的analytics任务的far-memory管理，灵感来源于内存的分块管理。比Pocket更精细了。</li>
<li><a
href="https://datawine.github.io/eurosys22-Memory-Deduplication-for-Serverless-Computing-with-Medes.html">Memory
Deduplication for Serverless Computing with
Medes</a>：感觉很有新意。是从warm的角度来优化serverless冷启动的，也就是warm一部分，总体来说应该是snapshot+diff，然后只保存diff。</li>
<li><a
href="https://datawine.github.io/eurosys22-FaaSnap-FaaS-Made-Fast-Using-Snapshot-based-VMs.html">FaaSnap:
FaaS Made Fast Using Snapshot-based VMs</a>：把serverless snapshot
restore的page fault问题优化到了极致</li>
</ul>
<h1 id="fseesec">FSE/ESEC</h1>
<h2 id="section-6">2017</h2>
<ul>
<li><a
href="https://datawine.github.io/fse-esec17-short-paper-QEMU-based-framework-for-non-intrusive-virtual-machine-instrumentation-and-introspection.html">Short-Paper-QEMU-based
framework for non-intrusive virtual machine instrumentation and
introspection</a>：对Qemu的ABI进行hooking进行非侵入式的VM
introspection。</li>
</ul>
<h1 id="icdcs">ICDCS</h1>
<h2 id="section-7">2013</h2>
<ul>
<li><a
href="https://datawine.github.io/icdcs13-Detecting-Transient-Bottlenecks-in-n-Tier-Applications-through-Fine-Grained-Analysis.html">Detecting
Transient Bottlenecks in n-Tier Applications through Fine-Grained
Analysis</a>：论文主要是解决一些transient事件（比如JVM garbage
collection）带来的bottleneck。个人认为贡献在于提出了一个新的指标：并发/吞吐。</li>
</ul>
<h1 id="isca">ISCA</h1>
<h2 id="section-8">2017</h2>
<ul>
<li><a
href="https://datawine.github.io/isca17-PowerChief-Intelligent-Power-Allocation-for-Multi-Stage-Applications-to-Improve-Responsiveness-on-Power-Constrained-CMP.html">PowerChief:
Intelligent Power Allocation for Multi-Stage Applications to Improve
Responsiveness on Power Constrained
CMP</a>：PowerChief，识别瓶颈服务、自适应选择boosting技术、动态调整功率。</li>
</ul>
<h2 id="section-9">2022</h2>
<ul>
<li><a
href="https://datawine.github.io/isca22-HiveMind-A-Hardware-Software-System-Stack-for-Serverless-Edge-Swarms.html">HiveMind:
A Hardware-Software System Stack for Serverless Edge
Swarms</a>：serverless+edge
computing优化。主要利用serverless的可扩展性，在集中式和分布式之间取平衡，用serverless去做之前集中式的部分。</li>
<li><a
href="https://datawine.github.io/isca22-Lukewarm-Serverless-Functions-Characterization-and-Optimization.html">Lukewarm
Serverless Functions: Characterization and
Optimization</a>：针对serverless的warm instance交互运行导致的cache
miss，设计了FIFO的L2 prefetch</li>
</ul>
<h1 id="middleware">Middleware</h1>
<h2 id="section-10">2017</h2>
<ul>
<li><a
href="https://datawine.github.io/middleware17-Sieve-Actionable-Insights-from-Monitored-Metrics-in-Distributed-Systems.html">Sieve:
Actionable Insights from Monitored Metrics in Distributed
Systems</a>：虽然是middleware的文章，但是比较有意思。两个贡献：基于clustering的metric
selection；基于granger和call graph（用sysdig和系统调用得到）的dependency
graph。两个有趣的例子：对sharelatex的auto-scaling的设计（指标选择、策略、条件）；对openstack的故障根因分析。</li>
</ul>
<h1 id="ndss">NDSS</h1>
<h2 id="section-11">2020</h2>
<ul>
<li><a
href="https://datawine.github.io/ndss20-OmegaLog-High-Fidelity-Attack-Investigation-via-Transparent-Multi-layer-Log-Analysis.html">OmegaLog:
High-Fidelity Attack Investigation via Transparent Multi-layer Log
Analysis</a>：一篇log causality的文章。</li>
</ul>
<h2 id="section-12">2022</h2>
<ul>
<li><a
href="https://datawine.github.io/ndss22-REPTTACK-Exploiting-Cloud-Schedulers-to-Guide-Co-Location-Attacks.html">REPTTACK:
Exploiting Cloud Schedulers to Guide Co-Location
Attacks</a>：论文主要介绍repttack，利用filter-score调度器和一些user
specification可以实现co-location。</li>
</ul>
<h1 id="nsdi">NSDI</h1>
<h2 id="section-13">2011</h2>
<ul>
<li><a
href="https://datawine.github.io/nsdi11-Diagnosing-performance-changes-by-comparing-request-flows.html">Diagnosing
performance changes by comparing request
flows</a>：论文主要提出的是request-flow
comparison，也就是比较两个不同时期的流特征。
论文主要提出两种异常：执行时间异常和执行路径异常。
值得注意的是，request-flow comparison和anomaly detection不一样。
前者主要比较<strong>两个不同period</strong>的distribution
changes，后者主要比较<strong>一个period</strong>内表现明显不同的flow。</li>
</ul>
<h2 id="section-14">2013</h2>
<ul>
<li><a
href="https://datawine.github.io/nsdi13-Improving-availability-in-distributed-systems-with-failure-informers.html">Improving
availability in distributed systems with failure
informers</a>：本篇文章提出了Pigeon，用来在end-host的视角监测。系统包括分布在process、操作系统、路由器和ospf的sensor，报告问题是否是永久性的和问题是否已经发生了。</li>
</ul>
<h2 id="section-15">2015</h2>
<ul>
<li><a
href="https://datawine.github.io/nsdi15-Retro-Targeted-Resource-Management-in-Multi-tenant-Distributed-Systems.html">Retro:
Targeted Resource Management in Multi-tenant Distributed
Systems</a>：文章主要介绍的是Retro，一个resource management framework
for shared distributed
systems。具体而言，就是用AspectJ去提取按workflow抽象的资源用量；提了两个指标slowdown和workload来无单位地表示resource抽象的竞争；用令牌桶实现control
points的限速；decouple控制策略，实现了三种策略。</li>
</ul>
<h2 id="section-16">2022</h2>
<ul>
<li><a
href="https://datawine.github.io/nsdi22-Efficient-Scheduling-Policies-for-Microsecond-Scale-Tasks.html">Efficient
Scheduling Policies for Microsecond-Scale
Tasks</a>：开源。模拟。对比load balancing策略和core
allocation策略对1us级别任务的性能影响。</li>
<li><a
href="https://datawine.github.io/nsdi22-Buffer-based-End-to-end-Request-Event-Monitoring-in-the-Cloud.html">Buffer-based
End-to-end Request Event Monitoring in the
Cloud</a>：以请求粒度捕获请求延迟异常（RLA）相关的事件：缓冲区建模和请求级别的数据包注入</li>
<li><a
href="https://datawine.github.io/nsdi22-A-Case-for-Task-Sampling-based-Learning-for-Cluster-Job-Scheduling.html">A
Case for Task Sampling based Learning for Cluster Job
Scheduling</a>：提出使用空间特性（其实就是sample-based）来预测集群作业的Job
Completion Time要比history-based更好。</li>
<li><a
href="https://datawine.github.io/nsdi22-Starlight-Fast-Container-Provisioning-on-the-Edge-and-over-the-WAN.html">Starlight:
Fast Container Provisioning on the Edge and over the
WAN</a>：重新设计了容器provisioning的协议和流程等，来让在低带宽、高延时的网络中加速容器provisioning</li>
<li><a
href="https://datawine.github.io/nsdi22-Closed-loop-Network-Performance-Monitoring-and-Diagnosis-with-SpiderMon.html">Closed-loop
Network Performance Monitoring and Diagnosis with
SpiderMon</a>：基于可编程交换机的网络异常监控。论文的亮点在于针对后验诊断（posterior
diagnosis）、解决了现有的监控系统的两个问题：高覆盖率和低开销</li>
<li><a
href="https://datawine.github.io/nsdi22-Collie-Finding-Performance-Anomalies-in-RDMA-Subsystems.html">Collie-Finding
Performance Anomalies in RDMA
Subsystems</a>：使用模拟退火搜索性能异常空间</li>
<li><a
href="https://datawine.github.io/nsdi22-Performance-Interfaces-for-Network-Functions.html">Performance
Interfaces for Network Functions</a>：提出了performance
interface的概念，用符号执行和trace的一个简单执行来生成关于Performance
Critical Variances的一个程序，和实际的NF一一对应</li>
<li><a
href="https://datawine.github.io/nsdi22-Justitia-Software-Multi-Tenancy-in-Hardware-Kernel-Bypass-Networks.html">Justitia:
Software Multi-Tenancy in Hardware Kernel-Bypass
Networks</a>：对RDMA的多租户支持</li>
<li><a
href="https://datawine.github.io/nsdi22-Zeta-A-Scalable-and-Robust-East-West-Communication-Framework-in-Large-Scale-Clouds.html">Zeta:
A Scalable and Robust East-West Communication Framework in Large-Scale
Clouds</a>：云网关的设计</li>
<li><a
href="https://datawine.github.io/nsdi22-Cocktail-A-Multidimensional-Optimization-for-Model-Serving-in-Cloud.html">Cocktail:
A Multidimensional Optimization for Model Serving in
Cloud</a>：针对ensemble
learning，在保证机器学习的准确率的情况下设计动态模型选择和购买算法，来保证经济效益</li>
<li><a
href="https://datawine.github.io/nsdi22-Evolvable-Network-Telemetry-at-Facebook.html">Evolvable
Network Telemetry at Facebook</a>：PCAT，一个production
change-aware的遥测系统，处理快速发展的网络中的变化。我们建议使用一个change
cube abstraction来系统地跟踪变化，并使用intent-based
layering的设计来限制和跟踪变化。</li>
<li><a
href="https://datawine.github.io/nsdi22-SketchLib-Enabling-Efficient-Sketch-based-Monitoring-on-Programmable-Switches.html">SketchLib:
Enabling Efficient Sketch-based Monitoring on Programmable
Switches</a>：这篇文章主要是在p4交换机针对sketch应用进行优化。</li>
<li><a
href="https://datawine.github.io/nsdi22-HeteroSketch-Coordinating-Network-wide-Monitoring-in-Heterogeneous-and-Dynamic-Networks.html">HeteroSketch:
Coordinating Network-wide Monitoring in Heterogeneous and Dynamic
Networks</a>：主要解决sketch算法的在异质化硬件上的问题。首先用profiler测量硬件性能，再用optimizer根据性能放置sketch算法。</li>
<li><a
href="https://datawine.github.io/nsdi22-Packet-Order-Matters-Improving-Application-Performance-by-Deliberately-Delaying-Packets.html">Packet
Order Matters! Improving Application Performance by Deliberately
Delaying
Packets</a>：实际场景中，混杂流的包是交替到达的。论文提出将同一个流的包buffer一下，然后批处理统一发送，会提高效率。</li>
<li><a
href="https://datawine.github.io/nsdi22-How-to-diagnose-nanosecond-network-latencies-in-rich-end-host-stacks.html">How
to diagnose nanosecond network latencies in rich end-host
stacks</a>：改了基于intel-PT的perf，实现了一个full-stack的网络分析器</li>
<li><a
href="https://datawine.github.io/nsdi22-CloudCluster-Unearthing-the-Functional-Structure-of-a-Cloud-Service.html">CloudCluster:
Unearthing the Functional Structure of a Cloud
Service</a>：根据流量矩阵对同一个数据中心内的VM进行聚类</li>
<li><a
href="https://datawine.github.io/nsdi22-NetHint-White-Box-Networking-for-Multi-Tenant-Data-Centers.html">NetHint:
White-Box Networking for Multi-Tenant Data
Centers</a>：运营商提供给用户一套简单的拓扑信息，方便他们优化机器学习应用（或者说数据密集型应用）</li>
<li><a
href="https://datawine.github.io/nsdi22-Isolation-Mechanisms-for-High-Speed-Packet-Processing-Pipelines.html">Isolation
Mechanisms for High-Speed Packet-Processing
Pipelines</a>：本文介绍了Menshen，它是可编程交换机的可重构匹配表（RMT）管道的一个扩展，在不同的数据包处理模块之间实施隔离。</li>
</ul>
<h1 id="osdi">OSDI</h1>
<h2 id="section-17">2014</h2>
<ul>
<li><a
href="https://datawine.github.io/osdi14-lprof-A-Non-intrusive-Request-Flow-Profiler-for-Distributed-Systems.html">lprof:
A Non-intrusive Request Flow Profiler for Distributed
Systems</a>：lprof通过bytecode的静态分析，从runtime logs里面infers the
request-flow来实现zero-instrumentation的性能监测</li>
<li><a
href="https://datawine.github.io/osdi14-The-Mystery-Machine-End-to-end-Performance-Analysis-of-Large-scale-Internet-Services.html">The
Mystery Machine: End-to-end Performance Analysis of Large-scale Internet
Services</a>：通过在全连接图上迭代，得到多服务间因果分析。</li>
</ul>
<h2 id="section-18">2016</h2>
<ul>
<li><a
href="https://datawine.github.io/osdi16-Non-Intrusive-Performance-Profiling-for-Entire-Software-Stacks-Based-on-the-Flow-Reconstruction-Principle.html">Non-Intrusive
Performance Profiling for Entire Software Stacks Based on the Flow
Reconstruction
Principle</a>：非侵入式根据log推断objects之间的关系，针对这个关系和时间来推断性能异常。
亮点在于关系的定义和处理上，但是objects和type的提取比较工程。</li>
</ul>
<h2 id="section-19">2018</h2>
<ul>
<li><a
href="https://datawine.github.io/osdi18-Capturing-and-Enhancing-In-Situ-System-Observability-for-Failure-Detection.html">Capturing
and Enhancing In Situ System Observability for Failure
Detection</a>：通过inter-process和inter-thread的error
log来增加可观测性。一个设计点是indirection的处理。</li>
</ul>
<h2 id="section-20">2020</h2>
<ul>
<li><a
href="https://datawine.github.io/osdi20-FIRM-An-Intelligent-Fine-grained-Resource-Management-Framework-for-SLO-Oriented-Microservices.html">FIRM:
An Intelligent Fine-grained Resource Management Framework for
SLO-Oriented Microservices</a>：SLO
violation的基于SVMdetection和localization，基于RL的SLO
violation的mitigation，还包括了一个fault injection framework</li>
</ul>
<h1 id="others">Others</h1>
<h2 id="section-21">2013</h2>
<ul>
<li><a
href="https://datawine.github.io/others13-Performance-troubleshooting-in-data-centers-an-annotated-bibliography.html">Performance
troubleshooting in data centers: an annotated
bibliography?</a>：这篇文章主要是对performance trouble
shooting的一篇综述，分类方法可以参考一下</li>
</ul>
<h2 id="section-22">2014</h2>
<ul>
<li><a
href="https://datawine.github.io/others14-So-you-want-to-trace-your-distributed-system-Key-design-insights-from-years-of-practical-experience.html">So,
you want to trace your distributed system? Key design insights from
years of practical
experience</a>：一篇14年的关于分布式追踪的前瞻式文章，其风格很像综述。</li>
</ul>
<h2 id="section-23">2020</h2>
<ul>
<li><a
href="https://datawine.github.io/others20-ViperProbe-Using-eBPF-Metrics-to-Improve-Microservice-Observability.html">ViperProbe:
Rethinking Microservice Observability with eBPF / ViperProbe: Using eBPF
Metrics to Improve Microservice
Observability</a>：ViperProbe，一个基于eBPF的微服务收集框架。在副本集群上进行测试，收集metrics。通过eBPF实现动态调整（怎么动态调整没说）。</li>
</ul>
<h1 id="security">Security</h1>
<h2 id="section-24">2023</h2>
<ul>
<li><a
href="https://datawine.github.io/security23-An-Efficient-Design-of-Intelligent-Network-Data-Plane.html">An
Efficient Design of Intelligent Network Data
Plane</a>：本文实际上是将决策树的inference阶段offload到可编程交换机上，因为大小比较产生的状态爆炸问题是本文最重要的贡献。</li>
</ul>
<h1 id="sc">SC</h1>
<h2 id="section-25">2018</h2>
<ul>
<li><a
href="https://datawine.github.io/sc18-A-Year-in-the-Life-of-a-Parallel-File-System.html">A
Year in the Life of a Parallel File
System</a>：这篇论文主要是对两个leadership-level的high-performance
computing centers的IO性能进行为期一年的测量。</li>
</ul>
<h1 id="sigcomm">SIGCOMM</h1>
<h2 id="section-26">2022</h2>
<ul>
<li><a
href="https://datawine.github.io/sigcomm22-SPRIGHT-Extracting-the-Server-from-Serverless-Computing-High-performance-eBPF-based-Event-driven-Shared-memory-Processing.html">SPRIGHT:
Extracting the Server from Serverless Computing! High-performance
eBPF-based Event-driven, Shared-memory Processing</a>：利用eBPF和share
memory对serverless chain的数据平面进行性能优化</li>
</ul>
<h1 id="sigmetrics">SIGMETRICS</h1>
<h2 id="section-27">2014</h2>
<ul>
<li><a
href="https://datawine.github.io/sigmetrics14-Non-intrusive-Out-of-band-and-Out-of-the-box-Systems-Monitoring-in-the-Cloud.html">Non-intrusive,
Out-of-band and Out-of-the-box Systems Monitoring in the
Cloud</a>：通过利用VMI技术，抓取目标VM的内存和磁盘信息，实现non-intrusive的监测。</li>
<li><a
href="https://datawine.github.io/sigmetrics14-IntroPerf-Transparent-Context-Sensitive-Multi-Layer-Performance-Inference-using-System-Stack-Traces.html">IntroPerf:
Transparent Context-Sensitive Multi-Layer Performance Inference using
System Stack Traces</a>：核心观点是OS
tracer一般是由系统调用触发的，系统调用和函数调用之间有gap。
文章主要是通过Event Tracing Framework for Windows(ETW)采集的system call
stack去反向构造延时，通过call stack来推断函数调用，基于此进行分析。</li>
</ul>
<h1 id="socc">SoCC</h1>
<h2 id="section-28">2016</h2>
<ul>
<li><a
href="https://datawine.github.io/socc16-Automating-Failure-Testing-Research-at-Internet-Scale.html">Automating
Failure Testing Research at Internet Scale</a>：netflix的fault
injection框架。</li>
</ul>
<h2 id="section-29">2019</h2>
<ul>
<li><a
href="https://datawine.github.io/socc19-An-automated-cross-layer-instrumentation-framework-for-diagnosing-performance-problems-in-distributed-applications.html">An
automated, cross-layer instrumentation framework for diagnosing
performance problems in distributed
applications</a>：Pythia，基于OSProfiler，通过辨别本该差不多、但是却表现出了high
variance within the workflows of requests，来实现自动化插桩。</li>
</ul>
<h2 id="section-30">2020</h2>
<ul>
<li><a
href="https://datawine.github.io/socc20-Sequoia-enabling-quality-of-service-in-serverless-computing.html">Sequoia:
Enabling ￿ality-of-Service in Serverless
Computing</a>：论文提出了一个针对serverless
functions和chains的、以QoS为优化目标的调度器</li>
</ul>
<h2 id="section-31">2021</h2>
<ul>
<li><a
href="https://datawine.github.io/socc21-tprof-Performance-profiling-via-structural-aggregation-and-automated-analysis-of-distributed-systems-traces.html">tprof:
Performance profiling via structural aggregation and automated analysis
of distributed systems
traces</a>：本文基于分布式跟踪系统(Jaeger)实现了一种新的performance
profiling，把trace分成四层进行分析。</li>
</ul>
<h1 id="sp">S&amp;P</h1>
<h2 id="section-32">2014</h2>
<ul>
<li><a
href="https://datawine.github.io/sp14-Stealing-Webpages-Rendered-on-Your-Browser-by-Exploiting-GPU-Vulnerabilities.html">Stealing
Webpages Rendered on Your Browser by Exploiting GPU
Vulnerabilities</a>：论文主要针对GPU memory可能存在的data
exfiltration提出攻击。</li>
</ul>
<h1 id="sosp">SOSP</h1>
<h2 id="section-33">2015</h2>
<ul>
<li><a
href="https://datawine.github.io/sosp15-Pivot-Tracing-Dynamic-Causal-Monitoring-for-Distributed-Systems.html">Pivot
Tracing: Dynamic Causal Monitoring for Distributed
Systems</a>：distributed tracing，贡献点在于dynamic instrumentation +
happened-before join关系。</li>
</ul>
<h1 id="ton">TON</h1>
<h2 id="section-34">2018</h2>
<ul>
<li><a
href="https://datawine.github.io/ton18-Root-Cause-Analysis-of-Anomalies-of-Multitier-Services-in-Public-Clouds.html">Root
Cause Analysis of Anomalies of Multitier Services in Public
Clouds</a>：主要是用similarity和random
walk去做根因分析，同时也提出了internal
contention（函数本身layer之间故障的传播）和external
contention（资源竞争）。</li>
</ul>
<h1 id="tpds">TPDS</h1>
<h2 id="section-35">2012</h2>
<ul>
<li><a
href="https://datawine.github.io/tpds12-Precise-Scalable-and-Online-Request-Tracing-for-Multitier-Services-of-Black-Boxes.html">Precise,
Scalable, and Online Request Tracing for Multitier Services of Black
Boxes</a>：本文是基于kprobe的一个tracing工作。一个新颖点在于除了普通的逻辑之外还提出了一些新的图关系和图表示。</li>
</ul>
<h2 id="section-36">2013</h2>
<ul>
<li><a
href="https://datawine.github.io/tpds13-Toward-Fine-Grained-Unsupervised-Scalable-Performance-Diagnosis-for-Production-Cloud-Computing-Systems.html">Toward
Fine-Grained, Unsupervised, Scalable Performance Diagnosis for
Production Cloud Computing
Systems</a>：文章主要是用插桩去采样信息（基本还是执行时间），用call
tree去做分类，通过CoV找到异常分类，通过RPCA在异常分类中找到异常组件。</li>
</ul>
<h2 id="section-37">2015</h2>
<ul>
<li><a
href="https://datawine.github.io/tpds16-Wait-Analysis-of-Distributed-Systems-Using-Kernel-Tracing.html">Wait
Analysis of Distributed Systems Using Kernel
Tracing</a>：这篇文章核心是在对distributed
system里面的等待原因进行根因分析。主要是看因为什么wait了、wait了几次。</li>
</ul>
<h2 id="section-38">2017</h2>
<ul>
<li><a
href="https://datawine.github.io/tpds17-Failure-Diagnosis-for-Distributed-Systems-Using-Targeted-Fault-Injection.html">Failure
Diagnosis for Distributed Systems Using Targeted Fault
Injection</a>：针对分布式系统的特点提出了Target Fault
Injection，通过利用分布式组件的执行流知识来控制注入位置。</li>
</ul>
<h1 id="www">WWW</h1>
<h2 id="section-39">2022</h2>
<ul>
<li><a
href="https://datawine.github.io/www22-Accelerating-Serverless-Computing-by-Harvesting-Idle-Resources.html">Accelerating
Serverless Computing by Harvesting Idle
Resources</a>：使用RL对serverless资源用量进行建模，把over-provisioned的function的资源给under-provisioned的function</li>
</ul>
]]></content>
      <categories>
        <category>论文</category>
      </categories>
      <tags>
        <tag>论文汇总</tag>
      </tags>
  </entry>
  <entry>
    <title>孟德尔随机化</title>
    <url>/mendelian-randomization.html</url>
    <content><![CDATA[<p>孟德尔随机化</p>
<span id="more"></span>
<h1 id="课件">课件</h1>
<ul>
<li><a
href="https://datawine.github.io/mr-lesson-1.html">第一讲</a></li>
</ul>
<h1 id="资料">资料</h1>
<ul>
<li><a
href="https://datawine.github.io/mr-background.html">孟德尔随机化研究背景</a></li>
<li><a
href="https://datawine.github.io/One-Sample-MR.html">One-Sample-MR</a></li>
<li><a
href="https://datawine.github.io/Two-Sample-MR.html">Two-Sample-MR</a></li>
<li><a
href="https://datawine.github.io/MR-statistical-issues.html">一些MR的statistical问题</a></li>
<li><a
href="https://datawine.github.io/MR-extensions.html">MR进阶</a></li>
<li><a
href="https://datawine.github.io/MR-guidance.html">如何进行MR研究</a></li>
<li><a
href="https://datawine.github.io/mrcieu-twosamplemr.html">MR实战例子</a></li>
<li>统计学原理
<ul>
<li><a
href="https://datawine.github.io/instrumental-variable.html">工具变量孟德尔随机化原理</a></li>
<li>[R2]</li>
<li>[F统计量]</li>
</ul></li>
<li>包的使用
<ul>
<li><a href="">TwoSampleMR</a></li>
<li><a href=""></a></li>
</ul></li>
<li><a
href="https://datawine.github.io/mr-others.html">孟德尔随机化及其他</a></li>
</ul>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>孟德尔随机化</tag>
      </tags>
  </entry>
  <entry>
    <title>Istio学习（一）</title>
    <url>/istio-learning-1.html</url>
    <content><![CDATA[<p>istio学习：参考资料、总述、数据平面、控制平面、简单实践</p>
<span id="more"></span>
<h1 id="参考资料">参考资料</h1>
<ul>
<li><a href="https://jimmysong.io/istio-handbook/">Istio
服务网格——云原生应用网络构建指南</a></li>
<li><a href="https://istio.io/latest/docs/">Istio Documentation</a></li>
<li><a
href="http://dockone.io/article/2434566">http://dockone.io/article/2434566</a></li>
</ul>
<h1 id="总述">总述</h1>
<p>Istio服务网格逻辑上分为数据平面和控制平面，架构图如下所示</p>
<p><img src="/img/2022-5-10-1.png" height="50%" width="50%"></p>
<p>它的架构目前来说有两种，一种是 Sidecar 模式，这也是 Istio
最传统的部署架构，另一种是 Proxyless 模式。</p>
<h2 id="sidecar模式">Sidecar模式</h2>
<p>见<a
href="https://jimmysong.io/istio-handbook/concepts/transparent-traffic-hijacking.html">Istio中的透明流量劫持过程详解</a></p>
<p><img src="/img/2022-5-10-2.jpeg" /></p>
<h2 id="proxyless模式">Proxyless模式</h2>
<p>Proxyless 模式是 Istio 1.11 版本中支持的实验特性，Istio
官网中有篇博客介绍了这个特性。 可以直接将 gRPC 服务添加到 Istio
中，不需要再向 Pod 中注入 Envoy 代理。
这样做可以极大的提升应用性能，降低网络延迟。
有人说这种做法又回到了原始的基于 SDK
的微服务模式，其实非也，它依然使用了 Envoy 的 xDS API.
但是因为不再需要向应用程序中注入 Sidecar
代理，因此可以减少应用程序性能的损耗。</p>
<p><img src="/img/2022-5-10-3.png" /></p>
<h1 id="数据平面">数据平面</h1>
<h2 id="xds-api">xDS-API</h2>
<p>在Envoy中，xDS-API中的xDS是一类发现服务的统称，包括</p>
<ul>
<li>SDS/EDS：Service/Endpoint Discovery Service</li>
<li>CDS：Cluster Discovery Service</li>
<li>RDS：Route Discovery Service</li>
<li>LDS：Listener Discovery Service</li>
</ul>
<h2 id="入口网关与出口网关">入口网关与出口网关</h2>
<p>Istio提倡所有进入与离开服务网格的流量都经过一个特殊的网关。
网关配置被用于运行在网格边界的独立 Envoy 代理，而不是服务工作负载的
sidecar 代理。</p>
<h3 id="ingressgateway">IngressGateway</h3>
<p>istio-ingressgateway是Istio安装完成后就会启动的服务，其作用是作为整个服务网格的边缘网关。
在边缘架设网关的作用不仅是做一层统一代理，更是对服务接口的统一管理。</p>
<p>IngressGateway在Istio中的具体实现仍然是Envoy。</p>
<h2 id="sidecar路由配置">Sidecar路由配置</h2>
<p>默认情况下，Sidecar中并没有任何特别的配置，所有的流量都通过k8s域名走DNS解析走掉了。</p>
<p>当想对流量进行控制的时候，可以定义一个Virtual
Service来动态指定流量的流向。</p>
<h1 id="控制平面">控制平面</h1>
<h2 id="pilot结构及功能">Pilot结构及功能</h2>
<p>Pilot是对各容器平台（或者VM）的逻辑抽象，通过适配器模式，形成统一的对接接口。</p>
<p>Pilot的基本工作就是为数据平台的Sidecar提供服务发现能力。但是Pilot本身并不做服务注册。
它只是提供一个接口，对接已有的服务注册系统。除此之外，还负责为动态路由提供总控配置，并将这些配置分发给数据平面代理。</p>
<h2 id="mixer结构及功能">Mixer结构及功能</h2>
<p>Mixer负责在服务调用之间实施控制策略，同时在调用间收集请求的遥测数据。</p>
<p>为了实现上述目的，每个请求在到达Sidecar的时候都需要向Mixer发起一次逻辑请求，以进行前置检查。
在每次请求结束之后，还需要再次向Mixer做一次汇报。</p>
<p>这里其实有了问题，一次通信变成了三次。要解决这个问题，有两种方式：</p>
<ul>
<li>把Mixer的部分请求处理逻辑放置在数据平面的网管Envoy上</li>
<li>将Mixer的数据二级缓存到Envoy上</li>
</ul>
<h2 id="请求属性attribute">请求属性(Attribute)</h2>
<p>请求属性是控制平面的数据元。每个Sidecar在处理数据流动时均会向Mixer提供一种叫Attribute的key-value对，比如</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">request.path:</span> <span class="string">xyz/abc</span></span><br><span class="line"><span class="attr">request.size:</span> <span class="number">1234</span></span><br></pre></td></tr></table></figure>
<h2 id="操作配置operator-config">操作配置(Operator Config)</h2>
<p>操作配置是Mixer的规则定义，包含三个方面</p>
<ul>
<li>数据实例配置，规定Mixer从请求属性中采集什么数据、在一些条件下应该采取什么样的行为（即如何生成一个数据实例）</li>
<li>处理器，实际处理数据实例的逻辑体</li>
<li>规则，将上面两个关联起来</li>
</ul>
<h1 id="安全控制">安全控制</h1>
<p>Istio的安全分成三层</p>
<ul>
<li>最外层的企业防火墙是路由硬件层面上的安全防御，抵挡如DoS攻击</li>
<li>服务网格内部入口还有一层网关，主要提供服务接入鉴权及访问资源控制</li>
<li>内部实现多种机制，强化数据安全，如
<ul>
<li>身份标识</li>
<li>控制策略</li>
<li>传输加密</li>
<li>审计、认证、鉴权</li>
</ul></li>
</ul>
<h2 id="citadel结构及功能">Citadel结构及功能</h2>
<p>Citadel是密钥与证书的管理系统。</p>
<h2 id="搭建bookinfo系统">搭建BookInfo系统</h2>
<p><a
href="https://istio.io/latest/zh/docs/examples/bookinfo/">https://istio.io/latest/zh/docs/examples/bookinfo/</a></p>
<p><img src="/img/2022-5-10-4.jpeg" height="50%" width="50%"></p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>istio</tag>
      </tags>
  </entry>
  <entry>
    <title>R语言学习</title>
    <url>/r-learning.html</url>
    <content><![CDATA[<p>R语言学习</p>
<span id="more"></span>
<h1 id="r语言教程汇总">R语言教程汇总</h1>
<p>内容主要来自于<a
href="https://www.math.pku.edu.cn/teachers/lidf/docs/Rbook/html/_Rbook/index.html">R语言教程</a>，去掉了一些不太有用的东西</p>
<ul>
<li><a
href="https://datawine.github.io/r-learning-1.html">R语言介绍</a></li>
<li><a
href="https://datawine.github.io/r-learning-2.html">R语言入门运行样例</a></li>
</ul>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>R</tag>
      </tags>
  </entry>
  <entry>
    <title>route add报错SIOCADDRT:Network is unreachable解决方案</title>
    <url>/route%20add-siocaddrt-network-is-unreachable.html</url>
    <content><![CDATA[<p>服务器 重启后无法通过外网访问，此时需要添加路由表项。</p>
<p>添加时出现错误：SIOCADDRT:Network is unreachable</p>
<span id="more"></span>
<h1 id="问题描述">问题描述</h1>
<p>错误信息：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">SIOCADDRT:Network is unreachable</span><br></pre></td></tr></table></figure>
<h1 id="解决方法">解决方法</h1>
<p>这个错误的原因是因为gateway和IP不在一个网段内。</p>
<p>通过ifconfig查找相应添加的device的网段。</p>
<p>如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">eth0      Link encap:Ethernet  HWaddr 0c:c4:7a:dc:76:aa  </span><br><span class="line">          inet addr:202.112.237.33  Bcast:202.112.237.255  Mask:255.255.255.0</span><br><span class="line">          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1</span><br><span class="line">          RX packets:226265 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:15405 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:1000 </span><br><span class="line">          RX bytes:18275659 (18.2 MB)  TX bytes:3133390 (3.1 MB)</span><br><span class="line">          Memory:c7220000-c723ffff</span><br></pre></td></tr></table></figure>
<p>那么gateway的数值就应该是<code>202.112.237.1</code></p>
<p>route命令为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo route add default gw 202.112.237.1 dev eth0</span><br></pre></td></tr></table></figure>
<p>PS:
当初就是<code>eth0</code>写成了<code>eth1</code>导致这个错误的发生</p>
<h1 id="参考资料">参考资料</h1>
<ul>
<li>https://www.jianshu.com/p/0bd0c0c7bc73</li>
</ul>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>比较docker默认网络模式、dpdk、ovs+dpdk三种网络性能测试</title>
    <url>/compare-docker-dpdk-ovs+dpdk.html</url>
    <content><![CDATA[<p>将前面的工作整合了一下，比较docker默认的网桥模式、dpdk和dpdk+ovs三种网络的网络性能</p>
<span id="more"></span>
<h1 id="前期工作">前期工作</h1>
<ul>
<li>docker +
dpdk：https://datawine.github.io/2018/07/15/DPDK-Pktgen-Docker%E6%90%AD%E5%BB%BAVNF%E7%8E%AF%E5%A2%83%E5%8F%8A%E9%AA%8C%E8%AF%81/</li>
<li>docker + dpdk +
ovs：https://datawine.github.io/2018/07/22/Docker-DPDK-OVS/</li>
</ul>
<h1 id="docker默认的网桥performance">docker默认的网桥performance</h1>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">运行docker，使用iperf3 server监听5201端口</span></span><br><span class="line">sudo docker run -it --rm --name=iperf3-server -p 5201:5201 networkstatic/iperf3 -s</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">启动iperf3 client，发包</span></span><br><span class="line">docker run  -it --rm networkstatic/iperf3 -c $(docker inspect --format &quot;&#123;&#123; .NetworkSettings.IPAddress &#125;&#125;&quot; $(docker ps -ql))</span><br></pre></td></tr></table></figure>
<h1 id="实验结果">实验结果</h1>
<p>因为没有查到如何iperf3监听建好的virtio_user或者是virtio_host端口，而iperf3对ovs的监听好像也是针对网桥（见参考资料[1]），不支持手动添加ovs
port和流表的方法，而且在查资料中，据说iperf在dpdk的实验中没有办法达到峰值（？见参考资料[2]），所以后面两种用pktgen测速。</p>
<h2 id="docker默认网桥性能">docker默认网桥性能</h2>
<p>性能</p>
<p><img src="/img/2018-8-20.jpg" /></p>
<h2 id="docker-dpdk性能">docker + dpdk性能</h2>
<p>拓扑结构</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+--------+---------------+               +-------------------+---------------+</span><br><span class="line">|        | socket file 1 |&lt;-------------&gt;| vhost-user port 1 |               |</span><br><span class="line">|        +---------------+               +-------------------+               |</span><br><span class="line">| host   |     pktgen    |               |      testpmd      |     container |</span><br><span class="line">|        +---------------+               +-------------------+               |</span><br><span class="line">|        | socket file 0 |&lt;-------------&gt;| vhost-user port 0 |               |</span><br><span class="line">+--------+---------------+               +-------------------+---------------+</span><br></pre></td></tr></table></figure>
<p>性能</p>
<p><img src="/img/2018-8-20-1.jpg" /></p>
<h2 id="docker-dpdk-ovs性能">docker + dpdk + ovs性能</h2>
<p>拓扑结构</p>
<p><img src="/img/2018-8-17-1.jpg" /></p>
<p>性能</p>
<p><img src="/img/2018-8-20-2.jpg" /></p>
<h1 id="总结">总结</h1>
<p>由上面可知，docker默认的网桥带宽能够达到<code>1.98GB/s</code>，docker+dpdk的模式下，带宽能够达到<code>4150MB/s</code>即<code>4.05GB.s</code>左右，而docker+dpdk+ovs的模式下，带宽能够达到<code>1350MB/s</code>即<code>1.32GB/s</code>左右，且发现Rx速率要小于Tx速率，猜测是ovs处发生堵塞。</p>
<h1 id="参考资料">参考资料</h1>
<ul>
<li>[1]
https://software.intel.com/en-us/articles/using-docker-containers-with-open-vswitch-and-dpdk-on-ubuntu-1710</li>
<li>[2] http://www.qingpingshan.com/jb/lua/322243.html</li>
<li>[3]
http://networkstatic.net/measuring-network-bandwidth-using-iperf-and-docker/</li>
<li>[4] https://www.cnblogs.com/gispathfinder/p/5871043.html</li>
<li>[5] https://my.oschina.net/LastRitter/blog/1807032</li>
</ul>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>dpdk</tag>
        <tag>docker</tag>
        <tag>ovs</tag>
        <tag>pktgen</tag>
        <tag>iperf</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker+openvswitch+dpdk小实验</title>
    <url>/docker-ovs-dpdk-vnf-exp.html</url>
    <content><![CDATA[<p>前后弄了一个多月，总算弄出来了Docker + OpenvSwitch +
dpdk的VNF实验环境。</p>
<span id="more"></span>
<h1 id="可用版本">可用版本</h1>
<ul>
<li>Ubuntu kernel版本 4.4.0-131-generic</li>
<li>ubuntu系统版本16.04.5</li>
<li>dpdk版本16.11.1</li>
<li>openvswitch版本2.6.1</li>
<li>pktgen版本3.1.1</li>
</ul>
<h1 id="clear.sh">clear.sh</h1>
<p>防止冲突，先把一些设置清空</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo rm /usr/local/etc/openvswitch/*</span><br><span class="line">sudo rm /usr/local/var/run/openvswitch/*</span><br><span class="line">sudo rm /usr/local/var/log/openvswitch/ovs-vswitchd.log</span><br></pre></td></tr></table></figure>
<h1 id="拓扑结构">拓扑结构</h1>
<p>大致的结构是这样的</p>
<p><img src="/img/2018-8-17-1.jpg" /></p>
<h1 id="dpdk安装">dpdk安装</h1>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget http://fast.dpdk.org/rel/dpdk-16.11.1.tar.xz</span><br><span class="line">tar xf dpdk-16.11.1.tar.xz</span><br><span class="line">cd dpdk-stable-16.11.1</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">设置DPDK库目录位置</span></span><br><span class="line">echo export RTE_SDK=$(pwd) &gt;&gt; ~/.bashrc</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">设置DPDK目标环境</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">注意！这里的x86_64-native-linuxapp-gcc应替换为实际运行环境</span></span><br><span class="line">echo export RTE_TARGET=x86_64-native-linuxapp-gcc  &gt;&gt; ~/.bashrc</span><br><span class="line">source ~/.bashrc</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">配置DPDK,需要使用Vhost-user驱动，需要将CONFIG_RTE_LIBRTE_VHOST=y</span></span><br><span class="line">vim config/common_base</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">安装dpdk</span></span><br><span class="line">make config T=$RTE_TARGET</span><br><span class="line">make T=$RTE_TARGET -j8</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">install是必须的！原博客就没有install</span></span><br><span class="line">make install T=$RTE_TARGET -j8</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">可以编译l2fwd来看一下</span></span><br><span class="line">cd examples/l2fwd/</span><br><span class="line">make </span><br></pre></td></tr></table></figure>
<h1 id="hugepage配置">Hugepage配置</h1>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/default/grub</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">找到其中一项为 GRUB_CMDLINE_LINUX_DEFAULT= ，不论后面的引号内包含任何内容，在原本内容之后添加 default_hugepagesz=1GB hugepagesz=1G hugepages=8（这里分配了8个1G的hugepages）</span></span><br><span class="line">sudo update-grub</span><br><span class="line">sudo reboot</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看分配情况</span></span><br><span class="line">grep Huge /proc/meminfo</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">分配成功后进行挂载</span></span><br><span class="line">sudo mkdir -p /dev/hugepages</span><br><span class="line">sudo mount -t hugetlbfs none /dev/hugepages</span><br><span class="line">sudo mkdir -p /mnt/huge</span><br><span class="line">sudo mount -t hugetlbfs -o pagesize=1G none /mnt/huge</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">注：在服务器上是已经配置好了mount到了/mnt/huge_1GB上，所以并没有执行上面的操作</span></span><br></pre></td></tr></table></figure>
<h1 id="pktgen安装">pktgen安装</h1>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">某个版本第一次安装会失败，这个版本不会</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">然而可以知道好像是多make几次就会好(从Clayne Robison写的注释来看)</span></span><br><span class="line">sudo apt install libpcap-dev</span><br><span class="line">wget http://dpdk.org/browse/apps/pktgen-dpdk/snapshot/pktgen-dpdk-pktgen-3.1.1.tar.gz</span><br><span class="line">tar xzf pktgen-dpdk-pktgen-3.1.1.tar.gz</span><br><span class="line">cd pktgen-dpdk-pktgen-3.1.1</span><br><span class="line">make -j8</span><br><span class="line">ln -s $(pwd)/app/$RTE_TARGET/pktgen /usr/bin/pktgen</span><br></pre></td></tr></table></figure>
<h1 id="ovs安装与配置">OvS安装与配置</h1>
<h2 id="ovs安装">OvS安装</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">创建必要目录</span></span><br><span class="line">mkdir -p /usr/local/etc/openvswitch</span><br><span class="line">mkdir -p /usr/local/var/run/openvswitch</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">下载</span></span><br><span class="line">wget http://openvswitch.org/releases/openvswitch-2.6.1.tar.gz</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">解压</span></span><br><span class="line">tar xzvf openvswitch-2.6.1.tar.gz</span><br><span class="line">cd openvswitch-2.6.1</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">配置环境并安装</span></span><br><span class="line">./boot.sh</span><br><span class="line">CFLAGS=&#x27;-march=native&#x27; ./configure --with-dpdk=$RTE_SDK/$RTE_TARGET</span><br><span class="line"></span><br><span class="line">make -j8</span><br><span class="line">sudo make install -j8</span><br></pre></td></tr></table></figure>
<h2 id="启动ovs">启动OvS</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">此时在openvswitch-2.6.1目录下</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">init new ovs database</span></span><br><span class="line">sudo ovsdb-tool create /usr/local/etc/openvswitch/conf.db ./vswitchd/vswitch.ovsschema</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">start database server</span></span><br><span class="line">sudo ovsdb-server --remote=punix:/usr/local/var/run/openvswitch/db.sock \</span><br><span class="line">--remote=db:Open_vSwitch,Open_vSwitch,manager_options \</span><br><span class="line">--pidfile --detach</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">initializing the OVS database<span class="string">&quot;</span></span></span><br><span class="line">sudo ovs-vsctl --no-wait init</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string">configure ovs dpdk</span></span></span><br><span class="line">sudo ovs-vsctl --no-wait set Open_vSwitch . other_config:dpdk-init=true \</span><br><span class="line">other_config:dpdk-lcore-mask=0x00f0f0 other_config:dpdk-socket-mem=&quot;1024,1024&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string">start ovs</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string">--log-file指定了守护进程ovs-vswitchd的log位置</span></span></span><br><span class="line">sudo ovs-vswitchd unix:/usr/local/var/run/openvswitch/db.sock --log-file=/usr/local/var/log/openvswitch/ovs-vswitchd.log --pidfile --detach</span><br></pre></td></tr></table></figure>
<p>其中一些选项的说明如下</p>
<ul>
<li>dpdk-init
<ul>
<li>Specifies whether OVS should initialize and support DPDK ports. This
field can either be <code>true</code> or <code>try</code>. A value of
<code>true</code> will cause the ovs-vswitchd process to abort on
initialization failure. A value of <code>try</code> will imply that the
ovs-vswitchd process should continue running even if the EAL
initialization fails.</li>
</ul></li>
<li>dpdk-lcore-mask
<ul>
<li>Specifies the CPU cores on which dpdk lcore threads should be
spawned and expects hex string (eg ‘0x123’).</li>
</ul></li>
<li>dpdk-socket-mem
<ul>
<li>Comma separated list of memory to pre-allocate from hugepages on
specific sockets. If not specified, 1024 MB will be set for each numa
node by default.上面的是"1024,1024"，是因为机器有两个numa
node，如果只有一个就是"1024"</li>
</ul></li>
<li>dpdk-hugepage-dir
<ul>
<li>Directory where hugetlbfs is mounted</li>
</ul></li>
<li>vhost-sock-dir
<ul>
<li>Option to set the path to the vhost-user unix socket files.</li>
</ul></li>
</ul>
<h2 id="创建ovs-port">创建OvS port</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">ovs use core 2 <span class="keyword">for</span> the PMD</span></span><br><span class="line">sudo ovs-vsctl set Open_vSwitch . other_config:pmd-cpu-mask=0x0f0f00</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">create br0 and vhost ports <span class="built_in">which</span> use dpdk</span></span><br><span class="line">sudo ovs-vsctl add-br br0 -- set bridge br0 datapath_type=netdev</span><br><span class="line">sudo ovs-vsctl add-port br0 vhost-user1 -- set Interface vhost-user1 type=dpdkvhostuser</span><br><span class="line">sudo ovs-vsctl add-port br0 vhost-user2 -- set Interface vhost-user2 type=dpdkvhostuser</span><br><span class="line">sudo ovs-vsctl add-port br0 vhost-user3 -- set Interface vhost-user3 type=dpdkvhostuser</span><br><span class="line">sudo ovs-vsctl add-port br0 vhost-user4 -- set Interface vhost-user4 type=dpdkvhostuser</span><br></pre></td></tr></table></figure>
<h2 id="增加流表">增加流表</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">清理之前可能残存的流表</span></span><br><span class="line">sudo ./utilities/ovs-ofctl del-flows br0</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">2 &lt;-&gt; 3之间流量</span></span><br><span class="line">sudo ./utilities/ovs-ofctl add-flow br0 in_port=2,dl_type=0x800,idle_timeout=0,action=output:3</span><br><span class="line">sudo ./utilities/ovs-ofctl add-flow br0 in_port=3,dl_type=0x800,idle_timeout=0,action=output:2</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">1 &lt;-&gt; 4之间流量</span></span><br><span class="line">sudo ./utilities/ovs-ofctl add-flow br0 in_port=1,dl_type=0x800,idle_timeout=0,action=output:4</span><br><span class="line">sudo ./utilities/ovs-ofctl add-flow br0 in_port=4,dl_type=0x800,idle_timeout=0,action=output:1</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">show current flows</span></span><br><span class="line">sudo ./utilities/ovs-ofctl dump-flows br0</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">showing vhost-user sockets <span class="keyword">in</span> /usr/local/var/run/openvswitch</span></span><br><span class="line">sudo ls -la /usr/local/var/run/openvswitch | grep vhost-user</span><br></pre></td></tr></table></figure>
<p>OvS从这里就已经配置好了，接下来建立Docker container</p>
<h1 id="创建testpmd-container和pktgen-container">创建testpmd
container和pktgen container</h1>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">testpmd container</span></span><br><span class="line">cd $RTE_SDK/../</span><br><span class="line"></span><br><span class="line">vim Dockerfile</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">Dockerfile内容如下</span></span><br><span class="line">FROM ubuntu:16.04</span><br><span class="line">RUN apt-get update -y</span><br><span class="line">RUN apt-get install -y numactl</span><br><span class="line">WORKDIR /root/dpdk</span><br><span class="line">COPY dpdk-stable-16.11.1 /root/dpdk/.</span><br><span class="line">ENV PATH &quot;$PATH:/root/dpdk/x86_64-native-linuxapp-gcc/app/&quot;</span><br><span class="line"></span><br><span class="line">sudo docker build -t dpdk-docker:17.05 .</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">这里进的实际上是一个目录，因为我放到一起了，所以两个Dockerfile会重名，把上一个build完之后改名就好了</span></span><br><span class="line">cd pktgen-3.4.2/..</span><br><span class="line">vim Dockerfile</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">Dockerfile内容如下</span></span><br><span class="line">FROM ubuntu:16.04</span><br><span class="line">RUN apt-get update -y</span><br><span class="line">RUN apt-get install -y numactl libpcap-dev</span><br><span class="line">WORKDIR /root/dpdk</span><br><span class="line">COPY dpdk-stable-16.11.1 /root/dpdk/.</span><br><span class="line">COPY pktgen-dpdk-pktgen-3.1.1 /root/pktgen/.</span><br><span class="line">RUN ln -s /root/pktgen/app/x86_64-native-linuxapp-gcc/pktgen /usr/bin/pktgen</span><br><span class="line">RUN ln -s /usr/lib/x86_64-linux-gnu/libpcap.so /usr/lib/x86_64-linux-gnu/libpcap.so.1</span><br><span class="line">ENV PATH &quot;$PATH:/root/dpdk/x86_64-native-linuxapp-gcc/app/&quot;</span><br><span class="line"></span><br><span class="line">sudo docker build -t pktgen-docker .</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">可以查看docker image</span></span><br><span class="line">sudo docker images</span><br></pre></td></tr></table></figure>
<h1 id="启动docker">启动Docker</h1>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">启动pktgen-docker</span></span><br><span class="line">sudo docker run -ti --rm --privileged --name=pktgen-docker -v /mnt/huge_1GB:/mnt/huge -v /usr/local/var/run/openvswitch:/var/run/openvswitch pktgen-docker:latest</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">pktgen应该在pktgen目录下运行，即有Pktgen.lua的目录下运行</span></span><br><span class="line">cd ../pktgen</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">在Docker中运行pktgen</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">参数我就没改了</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">-c 0x19: DPDK can run on core 0,3-4: (0b0001 1001)</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">--master-lcore 3: make the pktgen dpdk thread run on core 3 (0b1000)</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">-n 1: we only have one memory bank <span class="keyword">in</span> this VM</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">--file-prefix pktgen: <span class="string">&quot;pktgen&quot;</span> will be appended to hugepage memory files used by this process</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">--no-pci don<span class="string">&#x27;t look for any PCI devices</span></span> </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string">--vdev &#x27;</span>virtio_user1,mac=00:00:00:00:00:01,path=/var/run/openvswitch/vhost-user1<span class="string">&#x27;</span></span> </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string">--vdev &#x27;</span>virtio_user2,mac=00:00:00:00:00:02,path=/var/run/openvswitch/vhost-user2<span class="string">&#x27;</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string">-P: Promiscuous mode</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string">-T: Color terminal output</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string">-m &quot;0.0,4.1&quot; (core.port): core 0: port 0 rx/tx; core 4: port 1 rx/tx</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string">注：-m选项一定要和前面dpdk的-c选项符合</span></span></span><br><span class="line">./app/app/x86_64-native-linuxapp-gcc/pktgen -c 0x19 --master-lcore 3 -n 1 --socket-mem 1024,1024 --file-prefix pktgen --no-pci  \</span><br><span class="line">--vdev &#x27;net_virtio_user1,mac=00:00:00:00:00:01,path=/var/run/openvswitch/vhost-user1&#x27; \</span><br><span class="line">--vdev &#x27;net_virtio_user2,mac=00:00:00:00:00:02,path=/var/run/openvswitch/vhost-user2&#x27; \</span><br><span class="line">-- -T -P -m &quot;0.0,4.1&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string">启动dpdk-docker</span></span></span><br><span class="line">sudo docker run -it --rm --privileged --name=dpdk-docker \</span><br><span class="line">-v /mnt/huge_1GB:/mnt/huge -v /usr/local/var/run/openvswitch:/var/run/openvswitch \</span><br><span class="line">dpdk-docker:17.05</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string">在Docker中运行dpdk</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string">-c 0xE0: DPDK can run on core 5-7: (0b1110 0000)</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string">--master-lcore 5: make the make the master testpmd thread run on core 5 (0b0010 0000)</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string">-n 1: we only have one memory bank in this VM</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string">--file-prefix testpmd: &quot;testpmd&quot; will be appended to hugepage memory files used by this process</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string">--no-pci don&#x27;</span>t look <span class="keyword">for</span> any PCI devices</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">--vdev=net_virtio_user3,mac=00:00:00:00:00:03,path=/var/run/openvswitch/vhost-user3</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">--vdev=net_virtio_user4,mac=00:00:00:00:00:04,path=/var/run/openvswitch/vhost-user4:</span> </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">	use a virtual</span> </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">	device using the net_virtio_user driver, MAC address 00:00:00:00:00:03, and the path to the</span> </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">	unix socket is /var/run/openvswitch/vhost-user3</span></span><br><span class="line">testpmd -c 0xE0 -n 1 --socket-mem 1024,1024 --file-prefix testpmd --no-pci \</span><br><span class="line">--vdev &#x27;net_virtio_user3,mac=00:00:00:00:00:03,path=/var/run/openvswitch/vhost-user3&#x27; \</span><br><span class="line">--vdev &#x27;net_virtio_user4,mac=00:00:00:00:00:04,path=/var/run/openvswitch/vhost-user4&#x27; \</span><br><span class="line">-- -i --burst=64 --disable-hw-vlan --txd=2048 --rxd=2048 --auto-start --coremask=0xc0</span><br></pre></td></tr></table></figure>
<h1 id="最后结果">最后结果</h1>
<p>pktgen上显示结果</p>
<p><img src="/img/2018-8-19-1.jpg" /></p>
<p>testpmd上显示结果</p>
<p><img src="/img/2018-8-19-2.jpg" /></p>
<p>配置显示结果</p>
<p><img src="/img/2018-8-19-3.jpg" /></p>
<h1 id="踩坑实录">踩坑实录</h1>
<ul>
<li><p>因为不是在虚拟机上跑，没有打2M
-singlefile的patch，所以选项改了一下</p></li>
<li><p>理论上dpdk的选项<code>--socket-mem</code>和<code>-m</code>应该都是可以的，然而在我mac上的vagrant开起来的虚拟机上，<code>--socket-mem</code>居然不行。</p></li>
<li><p>脱离版本的配置十分痛苦。</p></li>
<li><p>出现过ovs在add port的时候后报错，事实证明有了log
file之后就好调多了</p>
<ul>
<li>could not add network device vhost-user0 to ofproto (No such
device).猜测可能是某个东西和linux
kernel版本不兼容，因为换了内核就没再出现过了。当时的解决方法是先添加，再删除，再添加。然而最后因为没有产生traffic，所以不知道这种方法是否是对的。</li>
<li>could not allocate
memery。大概是这个错误。是因为我开启ovs-vswitchd的时候，设置的socket
memory是“1024”，而机器有两个numa node，另外一个就没有memory分配了。</li>
</ul></li>
<li><p>没有traffic的情况</p>
<ul>
<li>有可能是numa的pmd的core分配不对，导致有的socket没有可用的pmd
thread</li>
<li>有可能是dpdk的-c设置和testpmd或者pktgen的coremask设置不统一，即coremask使用到的内核并不在-c设置的内核中。</li>
</ul></li>
</ul>
<h1 id="参考资料">参考资料</h1>
<ul>
<li>https://github.com/intel/SDN-NFV-Hands-on-Samples/tree/master/DPDK_in_Containers_Hands-on_Lab/dpdk-container-lab</li>
<li>https://www.youtube.com/watch?v=hEmvd7ZjkFw&amp;index=1&amp;list=PLg-UKERBljNx44Q68QfQcYsza-fV0ARbp</li>
<li>https://blog.csdn.net/me_blue/article/details/78589592</li>
<li>http://blog.sina.com.cn/s/blog_da4487c40102v2ic.html</li>
<li>http://docs.openvswitch.org/en/latest/intro/install/dpdk/</li>
<li>其他的具体错误都是搜索谷歌解决</li>
<li>以及--log-file的问题是咨询学长解决</li>
</ul>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>dpdk</tag>
        <tag>docker</tag>
        <tag>ovs</tag>
      </tags>
  </entry>
  <entry>
    <title>DPDK Pktgen+Docker搭建VNF环境及验证</title>
    <url>/dpdk-pktgen-docker-vnf-test.html</url>
    <content><![CDATA[<p>主要是搭建一个DPDK+docker的环境，然而docker上次用是在软工的时候，重新学还花了一些功夫，改日写篇docker总结好了。</p>
<span id="more"></span>
<h1 id="最终能够运行的版本信息">最终能够运行的版本信息</h1>
<p>注 ：dpdk、pktgen是wget下载安装的，docker是apt install安装的</p>
<ul>
<li>Linux kernel 4.4.0-131-generic</li>
<li>Ubuntu 16.04.5 LTS</li>
<li>dpdk-stable-16.11.1</li>
<li>pktgen-dpdk-pktgen-3.1.1</li>
<li>Docker version 17.03.2-ce</li>
</ul>
<h1 id="环境配置">环境配置</h1>
<ul>
<li>安装dpdk</li>
<li>安装docker</li>
<li>安装pktgen</li>
<li>配置hugepages
<ul>
<li>注意！本实验中由于我们需要使用virtio-user这种连接方式，由于实现时的一些限制导致使用vhost-user时同时最多只能使用8个hugepages无论2M还是1G大小的hugepagesize。所以这里必须使用1G大小的hugepagesize同时最多分配8个。</li>
</ul></li>
</ul>
<h1 id="拓扑搭建">拓扑搭建</h1>
<h2 id="拓扑">拓扑</h2>
<p>预建立的简单拓扑</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+--------+---------------+               +-------------------+---------------+</span><br><span class="line">|        | socket file 1 |&lt;-------------&gt;| vhost-user port 1 |               |</span><br><span class="line">|        +---------------+               +-------------------+               |</span><br><span class="line">| host   |     pktgen    |               |      testpmd      |     container |</span><br><span class="line">|        +---------------+               +-------------------+               |</span><br><span class="line">|        | socket file 0 |&lt;-------------&gt;| vhost-user port 0 |               |</span><br><span class="line">+--------+---------------+               +-------------------+---------------+</span><br></pre></td></tr></table></figure>
<p>testpmd是DPDK提供的一个通过数据包转发进行DPDK测试的工具，也是一个非常好的DPDK应用开发示例。如果想进行简单的DPDK开发实验推荐修改<code>$RTE_SDK/app/test-pmd/iofwd.c</code>后编译testpmd应用，之后在同一目录<code>$RTE_SDK/app/test-pmd/</code>下可以找到下编译后的testpmd应用。</p>
<p>pktgen运行在主机中，testpmd运行在容器中，两个应用之间通过建立的socket文件以及vhost-user进行通信，相当于虚拟网卡。</p>
<h2 id="启动容器">启动容器</h2>
<p>创建Dockerfile</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat &lt;&lt;EOT &gt;&gt; $RTE_SDK/../Dockerfile</span><br><span class="line">FROM ubuntu:latest</span><br><span class="line">WORKDIR /root/dpdk</span><br><span class="line">COPY dpdk /root/dpdk/.</span><br><span class="line">ENV PATH &quot;$PATH:/root/dpdk/$RTE_TARGET/app/&quot;</span><br><span class="line">EOT</span><br></pre></td></tr></table></figure>
<p>使用创建的dockerfile建立docker镜像</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd $RTE_SDK/..</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">-t为镜像名，可以以name:tag的格式来写，不加tag默认tag为latest</span></span><br><span class="line">sudo docker build -t dpdk .</span><br></pre></td></tr></table></figure>
<p>运行容器</p>
<p>注：这里一开始没把libnuma.so.1共享-v加进去，结果进去报错</p>
<p>注2：但是在后来的可跑的版本中，不加又没有关系</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir -p /tmp/virtio</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-ti 提供一个PTY交互界面并保持STDIN持续可用</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-v /dev/... 将主机的hugepages通过数据卷挂载到容器内，从而可以与主机共享hugepages</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-v /tmp/... 挂载一个数据卷到容器中用于共享virtio_user的sockets</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">--privilege 不启用特权可能导致无法共享hugepages和sockets</span></span><br><span class="line">sudo docker run -ti --rm --name=test \</span><br><span class="line">-v /dev/hugepages:/dev/hugepages \</span><br><span class="line">-v /tmp/virtio/:/tmp/virtio/ \</span><br><span class="line">--privileged dpdk</span><br></pre></td></tr></table></figure>
<h3 id="虚拟机上的初步结果">虚拟机上的初步结果</h3>
<p>因为硬件受限还没法添加1G的hugepage，为了测试testpmd的可用性，我暂时直接在容器中运行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">testpmd</span><br></pre></td></tr></table></figure>
<p>截图如下</p>
<p><img src="/img/2018-7-16-1-1.png" /></p>
<h2 id="启动应用">启动应用</h2>
<p>在容器中运行testpmd</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">以下命令在容器中运行</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">DPDK的参数</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-l 列出所使用的CPU核</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-n 给出memory channels的数量</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">--socket-mem 限制用于每个socket的内存量</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">--vdev 创建vhost的socket文件用于进行网络连接，可以理解为虚拟网卡</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">--file-prefix hugepages字首，用于区分所使用的hugepage</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">testpmd的参数</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">--forward-mode=io 对两个端口情况从一个端口进来的包直接从另一个端口发出</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在~/dpdk文件夹下运行</span></span><br><span class="line">./x86_64-native-linuxapp-gcc/app/testpmd -l 0-1 -n 1 --socket-mem 1024,1024 --vdev &#x27;eth_vhost0,iface=/tmp/virtio/sock1&#x27; --vdev &#x27;eth_vhost1,iface=/tmp/virtio/sock2&#x27; --file-prefix=test --no-pci -- -i --forward-mode=io --auto-start</span><br></pre></td></tr></table></figure>
<p>在主机上运行pktgen</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">以下命令在主机中运行</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">DPDK的参数同上，--vdev在这里用来连接到socket文件</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">pktgen的参数</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-P 在所有端口启用混杂模式</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-m 定义CPU核到端口的绑定，在这里core5绑定到prot0，core6绑定到port1</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">pktgen的运行目录应在Pktgen.lua同一文件夹下运行</span></span><br><span class="line"></span><br><span class="line">sudo pktgen -l 2-6 -n 3 --socket-mem 1024,1024 --vdev=&#x27;virtio_user0,path=/tmp/virtio/sock1&#x27; --vdev=&#x27;virtio_user1,path=/tmp/virtio/sock2&#x27; -- -P -m &quot;5.0,6.1&quot;</span><br></pre></td></tr></table></figure>
<h1 id="最终结果">最终结果</h1>
<p>在pktgen中进行简单设置，并在testpmd中查看结果</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Pktgen:/&gt;set all rate 10</span><br><span class="line">Pktgen:/&gt;set 0 count 100</span><br><span class="line">Pktgen:/&gt;set 1 count 200</span><br><span class="line">Pktgen:/&gt;str</span><br></pre></td></tr></table></figure>
<h2 id="pktgen上截图">pktgen上截图</h2>
<p><img src="/img/2018-8-15-2.png" /></p>
<h2 id="testpmd上截图">testpmd上截图</h2>
<p><img src="/img/2018-8-15-1.png" /></p>
<h1 id="参考资料">参考资料</h1>
<ul>
<li>https://www.sdnlab.com/20112.html</li>
<li>https://segmentfault.com/q/1010000003036379</li>
<li>http://pktgen-dpdk.readthedocs.io/en/latest/getting_started.html</li>
<li>http://www.voidcn.com/article/p-fmqewmwt-bqu.html</li>
</ul>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title>pktgen-dpdk安装踩坑实录</title>
    <url>/pktgen-install.html</url>
    <content><![CDATA[<p>pktgen安装。</p>
<span id="more"></span>
<h1 id="安装过程">安装过程</h1>
<p>非常简单。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://git.dpdk.org/apps/pktgen-dpdk/snapshot/pktgen-3.5.0.tar.xz</span><br><span class="line">cd pktgen-3.5.0/</span><br><span class="line">make -j8</span><br></pre></td></tr></table></figure>
<h1 id="运行脚本">运行脚本</h1>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo ./app/x86_64-native-linuxapp-gcc/pktgen -l 1,3,5,7,9 -n 4 --socket-mem 1024,1024 -- -P -m &quot;[3:5].0,[7:9].1&quot;</span><br></pre></td></tr></table></figure>
<h1 id="踩坑实录">踩坑实录</h1>
<p>版本很重要！3.5.0这个版本不会遇到liblua的问题，因为他内部会自动下载。</p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>pktgen</tag>
      </tags>
  </entry>
  <entry>
    <title>linux查看线程状态</title>
    <url>/linux-thread-state.html</url>
    <content><![CDATA[<p>查看线程状态的简单方法。</p>
<span id="more"></span>
<h1 id="方法一">方法一</h1>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ps -T -p &lt;pid&gt;</span><br></pre></td></tr></table></figure>
<h1 id="方法二">方法二</h1>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">top -H</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看某一个特定进程的线程</span></span><br><span class="line">top -H -p &lt;pid&gt;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>lua学习</title>
    <url>/lua-learning.html</url>
    <content><![CDATA[<p>因为Moongen的需要，学习了一些Lua知识，特此总结。</p>
<p>现在更新到lua的模块与包。</p>
<span id="more"></span>
<h4 id="注释">注释</h4>
<p>字符串匹配模式以后补充。</p>
<p>包的加载机制和C包以后补充。</p>
<h1 id="installation">installation</h1>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">brew install lua</span><br></pre></td></tr></table></figure>
<p>注：lua的index都是从1开始的。</p>
<h1 id="lua数据类型">Lua数据类型</h1>
<ul>
<li>nil</li>
<li>boolean</li>
<li>number</li>
<li>string</li>
<li>function</li>
<li>userdata</li>
<li>thread</li>
<li>table</li>
</ul>
<h2 id="nil">nil</h2>
<p>nil表示值无效，对于全局变量和table，nil还有删除的作用，赋值为nil之后即删除了这个值</p>
<p>注：不能说<code>type(X) == nil</code>，而要说<code>type(X) == "nil"</code>，因为<code>type(type(X)) == string</code></p>
<h2 id="boolean">boolean</h2>
<p>分为<code>true</code>和<code>false</code>，而且<code>nil</code>的值也为<code>false</code>。</p>
<h2 id="number">number</h2>
<p>lua默认只有一种number类型：double。（默认类型可以在luacof.h中修改）</p>
<h2 id="string">string</h2>
<p>字符串类型。</p>
<p><code>[[]]</code>用来表示一整块字符。</p>
<p><code>..</code>用来连接字符串。</p>
<p>在对一个数字字符串上进行算术操作时，Lua会尝试将这个数字字符串转成一个数字。</p>
<p>使用<code>#</code>来计算字符串，比如</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">&gt; <span class="built_in">print</span>(#<span class="string">&quot;www&quot;</span>)</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>
<h2 id="table">table</h2>
<p>table的创建通过构造表达式来完成。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建一个空表</span></span><br><span class="line"><span class="keyword">local</span> tbl1 = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建初始化表</span></span><br><span class="line"><span class="keyword">local</span> tbl2 = &#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>&#125;</span><br><span class="line">tbl = &#123;<span class="string">&quot;alpha&quot;</span>, <span class="string">&quot;beta&quot;</span>, [<span class="number">3</span>] = <span class="string">&quot;uno&quot;</span>, [<span class="string">&quot;two&quot;</span>] = <span class="string">&quot;dos&quot;</span>&#125;</span><br></pre></td></tr></table></figure>
<p>table实际上是一个关联数组（就是一个map），初始化的表通过index可以访问，但是index从1开始。</p>
<p>遍历一张表</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> key, val <span class="keyword">in</span> <span class="built_in">pairs</span>(t) <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">print</span> (key .. <span class="string">&quot; : &quot;</span> .. val)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>赋值或访问</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(tbl1[<span class="number">1</span>])</span><br><span class="line">tbl1[<span class="string">&quot;key&quot;</span>] = <span class="string">&quot;value&quot;</span></span><br><span class="line">tbl1[<span class="number">1</span>] = <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h2 id="function">function</h2>
<p>lua中函数被看成第一类值。</p>
<p>函数可以被存在变量里，即</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial1</span><span class="params">(n)</span></span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> n * factorial1(n - <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">print</span>(factorial1(<span class="number">5</span>))</span><br><span class="line">factorial2 = factorial1</span><br><span class="line"><span class="built_in">print</span>(factorial2(<span class="number">5</span>))</span><br></pre></td></tr></table></figure>
<p>这时输出的两个值完全一致。</p>
<p>function还可以通过匿名函数的方式传递</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">testFun</span><span class="params">(tab,fun)</span></span></span><br><span class="line">    <span class="keyword">for</span> k ,v <span class="keyword">in</span> <span class="built_in">pairs</span>(tab) <span class="keyword">do</span></span><br><span class="line">        <span class="built_in">print</span>(fun(k,v));</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">tab=&#123;key1=<span class="string">&quot;val1&quot;</span>,key2=<span class="string">&quot;val2&quot;</span>&#125;;</span><br><span class="line">testFun(tab,</span><br><span class="line"><span class="function"><span class="keyword">function</span><span class="params">(key,val)</span></span><span class="comment">--匿名函数</span></span><br><span class="line">    <span class="keyword">return</span> key..<span class="string">&quot;=&quot;</span>..val;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h1 id="lua变量">Lua变量</h1>
<p>Lua有三种变量，全局变量、局部变量、表中的域</p>
<p>直接声明即为全局变量。</p>
<p>局部变量通过<code>local</code>声明。局部变量的作用范围为包围他的语句块。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">a = <span class="number">5</span>               <span class="comment">-- 全局变量</span></span><br><span class="line"><span class="keyword">local</span> b = <span class="number">5</span>         <span class="comment">-- 局部变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">joke</span><span class="params">()</span></span></span><br><span class="line">    c = <span class="number">5</span>           <span class="comment">-- 全局变量</span></span><br><span class="line">    <span class="keyword">local</span> d = <span class="number">6</span>     <span class="comment">-- 局部变量</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">-- 局部变量d变为nil</span></span><br></pre></td></tr></table></figure>
<h2 id="赋值语句">赋值语句</h2>
<p>直接赋值<code>=</code></p>
<p>可以对多个变量同时赋值，如<code>a, b = c, d</code>。赋值的时候Lua会先计算右边所有的值，再赋值，这样可以直接用同时赋值的方法交换变量。</p>
<ul>
<li><p>变量个数&gt;值的个数的时候，按变量个数补nil。</p></li>
<li><p>变量个数&lt;值的个数的时候，忽略多余变量。</p></li>
</ul>
<p>多个值赋值常常用来交换变量，或者获得函数返回值，如<code>a, b = f()</code>。</p>
<h1 id="lua循环">Lua循环</h1>
<p>分为while、for、repeat三种。并支持break。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (condition)</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    statements</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- var为变量名，exp1为var起始，exp2为var结束，exp3为步长，如exp3不指定则为1，两端为闭区间</span></span><br><span class="line"><span class="keyword">for</span> var = exp1, exp2, exp3 <span class="keyword">do</span></span><br><span class="line">    statements</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">repeat</span> </span><br><span class="line">    statements</span><br><span class="line"><span class="keyword">until</span>(condition)</span><br></pre></td></tr></table></figure>
<h2 id="泛型for循环">泛型for循环</h2>
<p>通过一个迭代器函数来遍历所有值。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">--打印数组a的所有值  </span></span><br><span class="line">a = &#123;<span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>, <span class="string">&quot;three&quot;</span>&#125;</span><br><span class="line"><span class="keyword">for</span> i, v <span class="keyword">in</span> <span class="built_in">ipairs</span>(a) <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">print</span>(i, v)</span><br><span class="line"><span class="keyword">end</span> </span><br></pre></td></tr></table></figure>
<p>其中ipairs为Lua提供的一个迭代器函数，用来迭代数组。</p>
<h1 id="lua流程控制">Lua流程控制</h1>
<p>即if语句和嵌套。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (布尔表达式)</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    statements</span><br><span class="line"><span class="comment">-- else</span></span><br><span class="line"><span class="comment">--    statements</span></span><br><span class="line"><span class="comment">-- elseif (布尔表达式)</span></span><br><span class="line"><span class="comment">-- then</span></span><br><span class="line"><span class="comment">--		statements</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h1 id="lua函数">Lua函数</h1>
<p>函数定义为</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">optional_function_scope <span class="function"><span class="keyword">function</span> <span class="title">function_name</span><span class="params">( argument1, argument2, argument3..., argumentn)</span></span></span><br><span class="line">    function_body</span><br><span class="line">    <span class="keyword">return</span> result_params_comma_separated</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>optional_function_scope:</strong>
该参数是可选的制定函数是全局函数还是局部函数，未设置该参数默认为全局函数，如果你需要设置函数为局部函数需要使用关键字
<strong>local</strong>。</li>
<li><strong>function_name:</strong> 指定函数名称。</li>
<li><strong>argument1, argument2, argument3..., argumentn:</strong>
函数参数，多个参数以逗号隔开，函数也可以不带参数。</li>
<li><strong>function_body:</strong>
函数体，函数中需要执行的代码语句块。</li>
<li><strong>result_params_comma_separated:</strong>
函数返回值，Lua语言函数可以返回多个值，每个值以逗号隔开。</li>
</ul>
<h2 id="多返回值">多返回值</h2>
<p>用逗号隔开</p>
<h2 id="可变参数">可变参数</h2>
<p>在函数列表中使用<code>...</code>表示可变参数。</p>
<p>调用的时候可以通过table方式调用。（相当于传入一个map）</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">average</span><span class="params">(...)</span></span></span><br><span class="line">   result = <span class="number">0</span></span><br><span class="line">   <span class="keyword">local</span> <span class="built_in">arg</span>=&#123;...&#125;    <span class="comment">--&gt; arg 为一个表，局部变量</span></span><br><span class="line">   <span class="keyword">for</span> i,v <span class="keyword">in</span> <span class="built_in">ipairs</span>(<span class="built_in">arg</span>) <span class="keyword">do</span></span><br><span class="line">      result = result + v</span><br><span class="line">   <span class="keyword">end</span></span><br><span class="line">   <span class="built_in">print</span>(<span class="string">&quot;总共传入 &quot;</span> .. #<span class="built_in">arg</span> .. <span class="string">&quot; 个数&quot;</span>)</span><br><span class="line">   <span class="keyword">return</span> result/#<span class="built_in">arg</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;平均值为&quot;</span>,average(<span class="number">10</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>))</span><br></pre></td></tr></table></figure>
<p>也可以通过<code>select("#",...)</code>来获得可变参数的数量。</p>
<p>如果需要固定参数，在<code>...</code>前面加上好了，一样逗号隔开，但是必须放在可变参数之前。</p>
<p>可变参数单个访问可以用<code>select(i, ...)</code>访问第<code>i</code>个元素。</p>
<h1 id="lua运算符">Lua运算符</h1>
<p>算术运算符<code>+</code>，<code>-</code>，<code>*</code>，<code>/</code>，<code>%</code>，<code>^</code>，<code>-</code></p>
<p>关系运算符<code>==</code>，<code>~=</code>（不等于），<code>&gt;</code>，<code>&lt;</code>，<code>&gt;=</code>，<code>&lt;=</code></p>
<p>逻辑运算符<code>and</code>，<code>or</code>，<code>not</code></p>
<p>其他运算符<code>..</code>（连接两个字符串），<code>#</code>（返回字符或表的长度）</p>
<h1 id="lua字符串">Lua字符串</h1>
<p>字符串可以用如下三种方法表示</p>
<ul>
<li>单引号间的一串字符。</li>
<li>双引号间的一串字符。</li>
<li>[[和]]间的一串字符。</li>
</ul>
<h2 id="字符串操作">字符串操作</h2>
<p>注：下面的<code>string</code>为保留字</p>
<ul>
<li><p>string.upper()：转成大写字母</p></li>
<li><p>string.lower()：转成小写字母</p></li>
<li><p>string.gsub(mainString, findString, replaceString[,
num])：在字符串中将mainString中的findString全部用replaceString替换num次，无num则全部替换。</p></li>
<li><p>string.find(str, substr, [init[,
end]])：从init到end在str中寻找substr</p></li>
<li><p>string.reverse(str)：翻转</p></li>
<li><p>string.format(…)：像printf一样</p></li>
<li><p>string.char(arg)和string.byte(arg[,
int])：在char和int之间转换。byte函数的int用来指定第几个字符，默认第一个。char函数可以有多个参数，返回连在一起的字符串。</p></li>
<li><p>string.len(arg)：字符串长度</p></li>
<li><p>string.rep(string, n)：重复string n次。</p></li>
<li><p>..：连接字符串</p></li>
<li><p>string.gmatch(str,
pattern)：返回一个迭代器函数。每一次调用函数返回下一个符合pattern描述的子串</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> word <span class="keyword">in</span> <span class="built_in">string</span>.<span class="built_in">gmatch</span>(<span class="string">&quot;Hello Lua user&quot;</span>, <span class="string">&quot;%a+&quot;</span>) <span class="keyword">do</span> <span class="built_in">print</span>(word) <span class="keyword">end</span></span><br></pre></td></tr></table></figure></li>
<li><p>string.match(str, pattern[,
init])：返回第一个匹配出的子串（？这个好像解释不对，没有试过）</p></li>
</ul>
<h3 id="string.format">string.format</h3>
<ul>
<li>%c - 接受一个数字, 并将其转化为ASCII码表中对应的字符</li>
<li>%d, %i - 接受一个数字并将其转化为有符号的整数格式</li>
<li>%o - 接受一个数字并将其转化为八进制数格式</li>
<li>%u - 接受一个数字并将其转化为无符号整数格式</li>
<li>%x - 接受一个数字并将其转化为十六进制数格式, 使用小写字母</li>
<li>%X - 接受一个数字并将其转化为十六进制数格式, 使用大写字母</li>
<li>%e - 接受一个数字并将其转化为科学记数法格式, 使用小写字母e</li>
<li>%E - 接受一个数字并将其转化为科学记数法格式, 使用大写字母E</li>
<li>%f - 接受一个数字并将其转化为浮点数格式</li>
<li>%g(%G) - 接受一个数字并将其转化为%e(%E,
对应%G)及%f中较短的一种格式</li>
<li>%q - 接受一个字符串并将其转化为可安全被Lua编译器读入的格式</li>
<li>%s - 接受一个字符串并按照给定的参数格式化该字符串</li>
</ul>
<h3 id="匹配模式">匹配模式</h3>
<p>因为现在不用，暂时就不放了，相关连接</p>
<p>http://www.runoob.com/lua/lua-strings.html</p>
<h1 id="lua数组">Lua数组</h1>
<p>一维数组很简单<code>a = &#123;&#125;</code></p>
<p>多维数组也很简单</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">array = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i=<span class="number">1</span>,<span class="number">3</span> <span class="keyword">do</span></span><br><span class="line">   array[i] = &#123;&#125;</span><br><span class="line">      <span class="keyword">for</span> j=<span class="number">1</span>,<span class="number">3</span> <span class="keyword">do</span></span><br><span class="line">         array[i][j] = i*j</span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h1 id="lua迭代器">Lua迭代器</h1>
<h2 id="ipairs和pairs的区别">ipairs和pairs的区别</h2>
<p>pairs会返回所有key和value，而ipairs会从index为1开始，遇到value为nil就停止。</p>
<h2
id="无状态的迭代器和多状态的迭代器">无状态的迭代器和多状态的迭代器</h2>
<h3 id="for泛型的调用过程">for泛型的调用过程</h3>
<p>在这之前，有必要讲一下for泛型的调用过程。</p>
<p>对于一个for泛型所需要的迭代器内容，共有三个值：迭代函数、状态常量、控制变量。执行过程如下：</p>
<ul>
<li>首先，初始化，计算in后面表达式的值，表达式应该返回泛型 for
需要的三个值：迭代函数、状态常量、控制变量；与多值赋值一样，如果表达式返回的结果个数不足三个会自动用nil补足，多出部分会被忽略。</li>
<li>第二，将状态常量和控制变量作为参数调用迭代函数（注意：对于for结构来说，状态常量没有用处，仅仅在初始化时获取他的值并传递给迭代函数）。</li>
<li>第三，将迭代函数返回的值赋给变量列表。</li>
<li>第四，如果返回的第一个值为nil循环结束，否则执行循环体。</li>
<li>第五，回到第二步再次调用迭代函数</li>
</ul>
<h3 id="无状态的迭代器">无状态的迭代器</h3>
<p>无状态的迭代器指不保留任何状态，每一次迭代，迭代函数都是用两个变量（状态常量和控制变量）的值作为参数被调用。典型例子是ipairs。以下是一个例子</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">function square(iteratorMaxCount,currentNumber)</span><br><span class="line">   if currentNumber&lt;iteratorMaxCount</span><br><span class="line">   then</span><br><span class="line">      currentNumber = currentNumber+1</span><br><span class="line">   return currentNumber, currentNumber*currentNumber</span><br><span class="line">   end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">for i,n in square,3,0</span><br><span class="line">do</span><br><span class="line">   print(i,n)</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<h3 id="多状态的迭代器">多状态的迭代器</h3>
<p>很多情况下，迭代器需要保存多个状态信息而不是简单的状态常量和控制变量，最简单的方法是使用闭包，还有一种方法是将所有的状态信息封装到table中，将table作为迭代器的状态常量。以下是一个遍历table的迭代器。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">array = &#123;<span class="string">&quot;Lua&quot;</span>, <span class="string">&quot;Tutorial&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">elementIterator</span> <span class="params">(collection)</span></span></span><br><span class="line">   <span class="keyword">local</span> index = <span class="number">0</span></span><br><span class="line">   <span class="keyword">local</span> count = #collection</span><br><span class="line">   <span class="comment">-- 闭包函数</span></span><br><span class="line">   <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="params">()</span></span></span><br><span class="line">      index = index + <span class="number">1</span></span><br><span class="line">      <span class="keyword">if</span> index &lt;= count</span><br><span class="line">      <span class="keyword">then</span></span><br><span class="line">         <span class="comment">--  返回迭代器的当前元素</span></span><br><span class="line">         <span class="keyword">return</span> collection[index]</span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">   <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> element <span class="keyword">in</span> elementIterator(array)</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">   <span class="built_in">print</span>(element)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h1 id="lua-table">Lua table</h1>
<h2 id="table操作">table操作</h2>
<p>注：下面的table为保留字</p>
<ul>
<li>table.concat(table[, sep[, start[,
end]]])：将table从start到end的所有东西用sep（分隔符）隔开并连接在一起</li>
<li>table.insert(table[, pos],
value)：在table数组部分pos位置插入值为value的元素</li>
<li>table.maxn(table)：指定table中所有正数key值中最大的key，如果不存在key值为正数的返回0.（在Lua5.2之后不存在了）</li>
<li>table.remove(table[,
pos])：返回table数组位于pos的元素，后面的元素会前移。</li>
<li>table.sort(table[, comp])：对给定的table进行升序排序。</li>
</ul>
<h1 id="lua模块与包">Lua模块与包</h1>
<p>模块类似与一个封装库，Lua的模块是由变量、函数等已知元素组成的table，因此创建一个模块就是创建一个table，将需要导出的常量和函数放入其中，最后返回这个table就行了。</p>
<h2 id="模块示例">模块示例</h2>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 文件名为 module.lua</span></span><br><span class="line"><span class="comment">-- 定义一个名为 module 的模块</span></span><br><span class="line"><span class="built_in">module</span> = &#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">-- 定义一个常量</span></span><br><span class="line"><span class="built_in">module</span>.constant = <span class="string">&quot;这是一个常量&quot;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">-- 定义一个函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">module.func1</span><span class="params">()</span></span></span><br><span class="line">    <span class="built_in">io</span>.<span class="built_in">write</span>(<span class="string">&quot;这是一个公有函数！\n&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">func2</span><span class="params">()</span></span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;这是一个私有函数！&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">module.func3</span><span class="params">()</span></span></span><br><span class="line">    func2()</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="built_in">module</span></span><br></pre></td></tr></table></figure>
<h2 id="require函数">require函数</h2>
<p>使用<code>require("模块名")</code>或者<code>require"模块名"</code>来加载模块。如果直接使用<code>require</code>的话，lua会定义与这个模块名相同的全局变量。如下：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">&quot;module&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">module</span>.constant)</span><br><span class="line"><span class="built_in">module</span>.func3()</span><br></pre></td></tr></table></figure>
<p>也可以给它赋值<code>m = require("模块")</code>，此时<code>m</code>就是一个别名变量。</p>
<h2 id="加载机制">加载机制</h2>
<p>以后补充。</p>
<h2 id="c包">C包</h2>
<p>以后补充。</p>
<h1 id="lua原表">Lua原表</h1>
<h1 id="lua协同程序">Lua协同程序</h1>
<h1 id="lua文件io">Lua文件I/O</h1>
<h1 id="lua错误处理">Lua错误处理</h1>
<h1 id="lua调试">Lua调试</h1>
<h1 id="lua垃圾回收">Lua垃圾回收</h1>
<h1 id="lua面向对象">Lua面向对象</h1>
<h1 id="lua数据库访问">Lua数据库访问</h1>
<h1 id="参考资料">参考资料</h1>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>lua</tag>
      </tags>
  </entry>
  <entry>
    <title>moongen学习</title>
    <url>/moongen-learning.html</url>
    <content><![CDATA[<p>学习了一下MoonGen，主要参考官网和tutorial。</p>
<span id="more"></span>
<h1 id="usage-introduction">usage introduction</h1>
<h2 id="device-setup">Device setup</h2>
<p><code>master</code>函数是必须的，用来进行设备的配置，一个简单的设置如下</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> device = <span class="built_in">require</span> <span class="string">&quot;device&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">master</span><span class="params">(txNum)</span></span></span><br><span class="line">    <span class="comment">-- use specified NIC number with</span></span><br><span class="line">    <span class="comment">-- no listening and one transmission queues</span></span><br><span class="line">    txDev = device.<span class="built_in">config</span>&#123;</span><br><span class="line">        port = txNum,</span><br><span class="line">        rxQueues = <span class="number">0</span>,</span><br><span class="line">        txQueues = <span class="number">1</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    device.waitForLinks()</span><br><span class="line">    send(txDev:getTxQueue(<span class="number">0</span>))</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>如果要用到receive filter
configuration，要在创建的时候设置设备。在<code>device.config</code>中，设置<code>rssNQueues = N</code>，来创建<code>N</code>个队列。此外，还可以通过<code>rssFunctions</code>来控制hash值，选项有<code>RSS_FUNCTION_IPV4</code>，<code>.._IPV6</code>，<code>.._IPVX_TCP</code>，<code>.._IPVX_UDP</code>。示例如下：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> device = <span class="built_in">require</span> <span class="string">&quot;device&quot;</span></span><br><span class="line">txDev = device.<span class="built_in">config</span>&#123;</span><br><span class="line">    port = <span class="number">0</span>,</span><br><span class="line">    rxQueues = <span class="number">4</span>,</span><br><span class="line">    rssNQueues = <span class="number">4</span>,</span><br><span class="line">    rssFunctions = &#123;</span><br><span class="line">        device.RSS_FUNCTION_IPV4,</span><br><span class="line">        device.RSS_FUNCTION_IPV4_TCP,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="packet-generation">packet generation</h2>
<p>packets是异步发送、在memory buffer中生成的，所以需要一个在memory
pool中的buffer array。</p>
<p>因为大多数packets应该是一样的，所以一般通过一个函数定义。</p>
<p>注意：应该在memory pool中定义packet的值，而不是在generation
loop中，否则性能会大大下降。</p>
<p>最简单的方法就是在char buffer中手动设置一个ethernet
header，示例如下：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> dpdk = <span class="built_in">require</span> <span class="string">&quot;dpdk&quot;</span></span><br><span class="line"><span class="keyword">local</span> memory = <span class="built_in">require</span> <span class="string">&quot;memory&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">send</span><span class="params">(queue)</span></span></span><br><span class="line">    <span class="keyword">local</span> mem = memory.createMemPool(<span class="function"><span class="keyword">function</span><span class="params">(buf)</span></span></span><br><span class="line">        <span class="keyword">local</span> data = ffi.cast(<span class="string">&quot;uint8_t*&quot;</span>, buf.pkt.data)</span><br><span class="line">        <span class="keyword">for</span> i = <span class="number">0</span>, <span class="number">11</span> <span class="keyword">do</span></span><br><span class="line">            data[i] = i <span class="comment">-- fill in mac addresses</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        data[<span class="number">12</span>] = <span class="number">0x12</span> <span class="comment">-- set type to ethernet</span></span><br><span class="line">        data[<span class="number">13</span>] = <span class="number">0x34</span></span><br><span class="line">    <span class="keyword">end</span>)</span><br><span class="line">    <span class="keyword">local</span> bufs = mem:bufArray()</span><br><span class="line">    <span class="keyword">while</span> dpdk.<span class="built_in">running</span>()</span><br><span class="line">        bufs:alloc(<span class="number">60</span>) <span class="comment">-- size of each packet</span></span><br><span class="line">        <span class="comment">-- ⇑ sets up each packet with the function above</span></span><br><span class="line">        <span class="comment">-- ← here, single packets could be modified</span></span><br><span class="line">        queue:send(bufs) <span class="comment">-- schedule sending</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>简单一点，raw
buffer可以先被转换成各种包的格式，然后直接填就可以了。在<code>lua/include/proto/</code>中可以找到定义的相应格式。比如：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> mem = memory.createMemPool(<span class="function"><span class="keyword">function</span><span class="params">(buf)</span></span></span><br><span class="line">    buf:getEthernetPacket():fill&#123;</span><br><span class="line">        ethSrc = txDev, <span class="comment">-- use device mac</span></span><br><span class="line">        ethDst = <span class="string">&quot;00:01:02:03:04:05&quot;</span>,</span><br><span class="line">        ethType = <span class="number">0x1234</span>,</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">end</span>)</span><br></pre></td></tr></table></figure>
<p>如果要定义一种新的格式，按照<code>lua/include/proto/newProtocolTemplate.lua</code>的方式，拷贝并修改。</p>
<p>如果要修改某一种特定的包，在分配buffer后和enqueue之前修改，方法类似。</p>
<p>如果需要控制发包器的速度，通过调用函数<code>queue:setRate(MBit/s)</code></p>
<p>如果需要暂停LuaJIT VM，通过<code>dpdk.sleepMillis(time)</code></p>
<h2 id="running-parallel-tasks">running parallel tasks</h2>
<p>为了支持并行，通过引入<code>dpdk.lauchLua("funcname", arg0, ...)</code>来用一个新的LuaJIT
VM跑一个新的slave task。一般的调用方法为</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> dpdk = <span class="built_in">require</span> <span class="string">&quot;dpdk&quot;</span></span><br><span class="line">dpdk.launchLua(<span class="string">&quot;funcname&quot;</span>, arg0, ...)</span><br><span class="line">dpdk.waitForSlaves() <span class="comment">-- wait for child termination</span></span><br></pre></td></tr></table></figure>
<h2 id="statistics">statistics</h2>
<p><code>stats</code>模块提供了统计功能，收集完数据之后，可以被写到<code>stdout</code>或者一些其他的文件中。支持的输出类型有<code>plain</code>，<code>csv</code>和<code>ini</code>。</p>
<p>packet counter是和device绑定的，要创建一个新的packet
counter，可以使用<code>rxCtr = stats:newDevRxCounter(device, "plain")</code>或者<code>newDevTxCounter(..)</code>。</p>
<p><code>newPktRxCounter("your counter name", "plain")</code>或者<code>newPktTxCounter(..)</code>可以通过调用它的<code>countPacket(singleBuffer)</code>来将packet
buffer传递给它们来实现更新。</p>
<p><code>newManualTxCounter("your counter name", "plain")</code>可以手动计数。可以通过<code>updateWithSize(packet_count, each_size)</code>来更新。</p>
<p>对于所有counter，<code>update()</code>方法都可以频繁调用，可以显示当前数据。</p>
<p><code>histogram</code>模块可以收集频率方面的数据。</p>
<p>下面的示例使用了device和package两种计数器，packet
size记在histogram里。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> dpdk = <span class="built_in">require</span> <span class="string">&quot;dpdk&quot;</span></span><br><span class="line"><span class="keyword">local</span> device = <span class="built_in">require</span> <span class="string">&quot;device&quot;</span></span><br><span class="line"><span class="keyword">local</span> histogram = <span class="built_in">require</span> <span class="string">&quot;histogram&quot;</span></span><br><span class="line"><span class="keyword">local</span> memory = <span class="built_in">require</span> <span class="string">&quot;memory&quot;</span></span><br><span class="line"><span class="keyword">local</span> stats = <span class="built_in">require</span> <span class="string">&quot;stats&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">master</span><span class="params">(rxPort, saveInterval)</span></span></span><br><span class="line">    <span class="keyword">local</span> saveInterval = saveInterval <span class="keyword">or</span> <span class="number">60</span></span><br><span class="line">    <span class="keyword">local</span> rxDev = device.<span class="built_in">config</span>&#123;</span><br><span class="line">        port = rxPort,</span><br><span class="line">        dropEnable = <span class="literal">false</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    device.waitForLinks()</span><br><span class="line">    <span class="keyword">local</span> queue = rxDev:getRxQueue(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">local</span> bufs = memory.bufArray()</span><br><span class="line">    <span class="comment">-- create the device receive counter</span></span><br><span class="line">    <span class="keyword">local</span> rxCtr = stats:newDevRxCounter(queue.dev)</span><br><span class="line">    <span class="comment">-- and the packet receive counter to detect</span></span><br><span class="line">    <span class="comment">-- packets that were dropped on the NICNIC</span></span><br><span class="line">    <span class="keyword">local</span> pktCtr = stats:newPktRxCounter(<span class="string">&quot;pkts&quot;</span>, <span class="string">&quot;plain&quot;</span>)</span><br><span class="line">    <span class="keyword">local</span> hist = histogram:<span class="built_in">create</span>()</span><br><span class="line">    <span class="keyword">local</span> timer = timer:new(saveInterval)</span><br><span class="line">    <span class="keyword">while</span> dpdk.<span class="built_in">running</span>() <span class="keyword">do</span></span><br><span class="line">        <span class="comment">-- wait max 100ms for new data</span></span><br><span class="line">        <span class="keyword">local</span> rx = queue:tryRecv(bufs, <span class="number">100</span>)</span><br><span class="line">        <span class="keyword">for</span> i = <span class="number">1</span>, rx <span class="keyword">do</span></span><br><span class="line">            <span class="keyword">local</span> buf = bufs[i]</span><br><span class="line">            <span class="keyword">local</span> size = buf:getSize()</span><br><span class="line">            hist:update(size)</span><br><span class="line">            pktCtr:countPacket(buf)</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        bufs:free(rx)</span><br><span class="line">        rxCtr:update()</span><br><span class="line">        pktCtr:update()</span><br><span class="line">        <span class="keyword">if</span> timer:expired() <span class="keyword">then</span></span><br><span class="line">            timer:reset()</span><br><span class="line">            hist:<span class="built_in">print</span>()</span><br><span class="line">            hist:save(<span class="string">&quot;packet_sizes.csv&quot;</span>)</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">-- and print statistics, those should be the same.</span></span><br><span class="line">    rxCtr:finalize()</span><br><span class="line">    pktCtr:finalize()</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>如果要使用manual
counter，可以通过<code>queue:send()</code>的返回值来实时更新。注意到发送动作是异步的，但是返回值仍然可以用来做计数。和之前的一样，<code>finalize()</code>函数可以用来输出最终结果。而<code>updateWithSize()</code>输出每一秒的实时结果。示例如下：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">send</span><span class="params">(queue)</span></span></span><br><span class="line">    <span class="keyword">local</span> mem = ...</span><br><span class="line">    <span class="keyword">local</span> packetSize = <span class="number">250</span></span><br><span class="line">    <span class="comment">-- create manual counter</span></span><br><span class="line">    <span class="keyword">local</span> txCtr = stats:newManualTxCounter(port, <span class="string">&quot;plain&quot;</span>)</span><br><span class="line">    <span class="keyword">local</span> bufs = mem:bufArray()</span><br><span class="line">    <span class="keyword">while</span> dpdk.<span class="built_in">running</span>() <span class="keyword">do</span></span><br><span class="line">        bufs:alloc(packetSize)</span><br><span class="line">        bufs:offloadUdpChecksums()</span><br><span class="line">        <span class="keyword">local</span> sentCount = queue:send(bufs)</span><br><span class="line">        <span class="comment">-- register new data: sentCount * packetSize</span></span><br><span class="line">        txCtr:updateWithSize(sentCount, packetSize)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">	txCtr:finalize()</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>同时也可以在接收包的时候，可以对包的一些特定内容进行统计。示例如下：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">recv</span><span class="params">(queue)</span></span></span><br><span class="line">    <span class="keyword">local</span> bufs = memory.bufArray()</span><br><span class="line">    <span class="keyword">local</span> counters = &#123;&#125;</span><br><span class="line">    <span class="keyword">while</span> dpdk.<span class="built_in">running</span>() <span class="keyword">do</span></span><br><span class="line">        <span class="comment">-- block until some data was received</span></span><br><span class="line">        <span class="keyword">local</span> rx = queue:recv(bufs)</span><br><span class="line">        <span class="keyword">for</span> i = <span class="number">1</span>, rx <span class="keyword">do</span></span><br><span class="line">            <span class="keyword">local</span> buf = bufs[i]</span><br><span class="line">            <span class="comment">-- cast the buffer to a known protocol</span></span><br><span class="line">            <span class="keyword">local</span> port = buf:getUdpPacket().udp:getDstPort()</span><br><span class="line">            <span class="keyword">local</span> ctr = counters[port]</span><br><span class="line">            <span class="comment">-- create counters dynamically</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> ctr <span class="keyword">then</span></span><br><span class="line">                ctr = stats:newPktRxCounter(port, <span class="string">&quot;plain&quot;</span>)</span><br><span class="line">                counters[port] = ctr</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="comment">-- record the packet</span></span><br><span class="line">            ctr:countPacket(buf)</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        bufs:freeAll()</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">-- for each observed destination port, print stats:</span></span><br><span class="line">    <span class="keyword">for</span> _, ctr <span class="keyword">in</span> <span class="built_in">pairs</span>(counters) <span class="keyword">do</span></span><br><span class="line">        ctr:finalize()</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h2 id="timestamping">timestamping</h2>
<p>用来测时间戳的包定义在<code>lua/include/proto/ptp.lua</code>。可以通过<code>timestamping:newTimestamper(txq, rxq)</code>来创造一个新的timestamper。创建的timestamper可以在l2层使用，或者也可以通过udp传输。</p>
<p>以下的例子在两个queue之间每隔0.01s测量一次延迟。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> ts = <span class="built_in">require</span> <span class="string">&quot;timestamping&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">timerTask</span><span class="params">(txq, rxq, size)</span></span></span><br><span class="line">    <span class="comment">-- create the timestamper for measuring</span></span><br><span class="line">    <span class="comment">-- between those queues</span></span><br><span class="line">    <span class="keyword">local</span> timestamper = ts:newTimestamper(txq, rxq)</span><br><span class="line">    <span class="keyword">local</span> hist = histogram:new()</span><br><span class="line">    <span class="keyword">local</span> rateLimiter = timer:new(<span class="number">0.01</span>)</span><br><span class="line">    <span class="keyword">while</span> dpdk.<span class="built_in">running</span>() <span class="keyword">do</span></span><br><span class="line">        rateLimiter:reset()</span><br><span class="line">        hist:update(timestamper:measureLatency(size))</span><br><span class="line">        rateLimiter:busyWait()</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    hist:<span class="built_in">print</span>()</span><br><span class="line">    hist:save(<span class="string">&quot;histogram.csv&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h2 id="task-communication">task communication</h2>
<p>moongen提供两种交流的方法。</p>
<p>一种是pipes。一般在一个公共背景下创建pipe，比如master函数。以下就是一个示例：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> pipe = <span class="built_in">require</span> <span class="string">&quot;pipe&quot;</span></span><br><span class="line"><span class="comment">-- create a new pipe in the parent task</span></span><br><span class="line"><span class="keyword">local</span> p = pipe:newSlowPipe()</span><br><span class="line">p:send(<span class="number">0</span>, <span class="number">13</span>, <span class="number">37</span>, <span class="number">42</span>) <span class="comment">-- send array</span></span><br><span class="line">p:send(<span class="string">&quot;the cake is a lie&quot;</span>) <span class="comment">-- send string</span></span><br><span class="line"><span class="comment">-- or send a table</span></span><br><span class="line">p:send(&#123;<span class="number">235</span>, lol = <span class="string">&quot;rofl&quot;</span>, subtable = &#123;<span class="number">1</span>&#125;&#125;)</span><br><span class="line"><span class="comment">-- number of waiting messages</span></span><br><span class="line"><span class="keyword">local</span> enqueued = p:count()</span><br><span class="line"><span class="comment">-- receiving</span></span><br><span class="line"><span class="keyword">local</span> a, b, c, d = p:recv() <span class="comment">-- equals tryRecv(10)</span></span><br><span class="line"><span class="keyword">local</span> txt = p:tryRecv(<span class="number">100</span>) <span class="comment">-- wait time microseconds</span></span><br><span class="line"><span class="comment">-- and return answer</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- pass this pipe when creating another task</span></span><br><span class="line"><span class="comment">-- it can then access it like above.</span></span><br><span class="line">dpdk.launchLua(<span class="string">&quot;somefunnction&quot;</span>, p)</span><br><span class="line">dpdk.waitForSlaves()</span><br></pre></td></tr></table></figure>
<p>另一种是namespace，就是在LuaJIT VM之间声明用lua
table表示的全局变量。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> dpdk = <span class="built_in">require</span> <span class="string">&quot;dpdk&quot;</span></span><br><span class="line"><span class="keyword">local</span> namespaces = <span class="built_in">require</span> <span class="string">&quot;namespaces&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">master</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">local</span> space = namespaces:get(<span class="string">&quot;mine&quot;</span>)</span><br><span class="line">    space.<span class="built_in">string</span> = <span class="string">&quot;data!&quot;</span></span><br><span class="line">    space.answer = <span class="number">42</span></span><br><span class="line">    space.<span class="built_in">table</span> = &#123; black = <span class="string">&quot;mesa&quot;</span>, &#123; <span class="number">1</span> &#125; &#125;</span><br><span class="line">    dpdk.launchLua(<span class="string">&quot;slave&quot;</span>):wait()</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">slave</span><span class="params">()</span></span></span><br><span class="line">    <span class="comment">-- can access the same namespace!</span></span><br><span class="line">    <span class="keyword">local</span> slavespace = namespaces:get(<span class="string">&quot;mine&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;data? &quot;</span> .. slavespace.<span class="built_in">string</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h2 id="traffic-patterns">traffic patterns</h2>
<p>有的时候网卡只支持固定速度，而却需要人为降速，这个时候moongen会通过在包之间添加gap（就是在空隙发送损坏的包）来达到降速的效果。</p>
<p>可以通过<code>buf.setDelay(bytes)</code>来设置延时，如果要设置随机延时，有泊松分布的延时产生<code>poissonDelay(average_wait)</code>。示例如下：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">send</span><span class="params">(txDev)</span></span></span><br><span class="line">    <span class="keyword">local</span> mem = ...</span><br><span class="line">    <span class="keyword">local</span> bufs = mem:bufArray()</span><br><span class="line">    <span class="keyword">while</span> dpdk.<span class="built_in">running</span>() <span class="keyword">do</span></span><br><span class="line">        bufs:alloc(size)</span><br><span class="line">        <span class="keyword">for</span> _, buf <span class="keyword">in</span> <span class="built_in">ipairs</span>(bufs) <span class="keyword">do</span></span><br><span class="line">            <span class="keyword">local</span> avg = rateToByteDelay(rate, size)</span><br><span class="line">            <span class="keyword">local</span> delay = poissonDelay(avg)</span><br><span class="line">            buf:setDelay(delay)</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        queue:sendWithDelay(bufs)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>moongen</tag>
      </tags>
  </entry>
  <entry>
    <title>p4学习</title>
    <url>/p4-learning.html</url>
    <content><![CDATA[<p>因为最近用到p4，总结一下p4的学习</p>
<span id="more"></span>
<h1 id="p4概念">P4概念</h1>
<p>P4由以下部分构成</p>
<ul>
<li>Headers</li>
<li>Parsers</li>
<li>Tables</li>
<li>Actions</li>
<li>Control Programs</li>
</ul>
<h2 id="headers">Headers</h2>
<p>用来形容the sequence and structure of a series of
fields，包括了字段的宽度和字段值的限制。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">header ethernet &#123;</span><br><span class="line">    fields &#123;</span><br><span class="line">        dst_addr : 48; // width in bits</span><br><span class="line">        src_addr : 48;</span><br><span class="line">        ethertype : 16;</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br><span class="line">header vlan &#123;</span><br><span class="line">    fields &#123;</span><br><span class="line">        pcp : 3;</span><br><span class="line">        cfi : 1;</span><br><span class="line">        vid : 12;</span><br><span class="line">        ethertype : 16;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="parsers">Parsers</h2>
<p>P4用一个transition的集合来表示state
machine，用来提取字段的value，然后发送到match+action表。论文给了一个示例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">parser start &#123;</span><br><span class="line">    ethernet;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">parser ethernet &#123;</span><br><span class="line">    switch(ethertype) &#123;</span><br><span class="line">        case 0x8100: vlan;</span><br><span class="line">        case 0x9100: vlan;</span><br><span class="line">        case  0x800: ipv4;</span><br><span class="line">        // Other cases</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">parser vlan &#123;</span><br><span class="line">    switch(ethertype) &#123;</span><br><span class="line">        case 0xaaaa: mTag;</span><br><span class="line">        case  0x800: ipv4;</span><br><span class="line">        // Other cases</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br><span class="line">parser mTag &#123;</span><br><span class="line">    switch(ethertype) &#123;</span><br><span class="line">        case 0x800: ipv4;</span><br><span class="line">        // Other cases</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解析从start state开始。知道一个显式声明的stop
state结束（或者遇到一个unhandled case报错）。</p>
<p>遇到一个新的header的state，状态机会提取出header然后继续下一次处理，被提取出的头会被发送到match+action进行处理。</p>
<h2 id="table-specification">Table Specification</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">table mTag_table &#123;</span><br><span class="line">    reads &#123;</span><br><span class="line">        ethernet.dst_addr : exact;</span><br><span class="line">        vlan.vid : exact;</span><br><span class="line">    &#125;</span><br><span class="line">    actions &#123;</span><br><span class="line">        add_mTag;</span><br><span class="line">    &#125;</span><br><span class="line">    max_size : 20000;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>reads属性声明match什么字段，指定match的类型（exact,
ternary）等。</p></li>
<li><p>actions属性列举所有对packet的可能行为</p></li>
<li><p>max_size属性声明table应该支持多少entries</p></li>
</ul>
<h2 id="action-specifications">Action Specifications</h2>
<p>P4定义了一堆动作原语。每一个P4程序都通过动作原语定义新的动作。</p>
<p>如上文提到的add_mTag</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">action add_mTag(up1, up2, down1, down2, egr_spec) &#123;</span><br><span class="line">    add_header(mTag);</span><br><span class="line">    // Copy VLAN ethertype to mTag</span><br><span class="line">    copy_field(mTag.ethertype, vlan.ethertype);</span><br><span class="line">    // Set VLAN’s ethertype to signal mTag</span><br><span class="line">    set_field(vlan.ethertype, 0xaaaa);</span><br><span class="line">    set_field(mTag.up1, up1);</span><br><span class="line">    set_field(mTag.up2, up2);</span><br><span class="line">    set_field(mTag.down1, down1);</span><br><span class="line">    set_field(mTag.down2, down2);</span><br><span class="line">    // Set the destination egress port as well</span><br><span class="line">    set_field(metadata.egress_spec, egr_spec);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果action需要某些参数，如up1，会由match table在运行的时候提供。</p>
<p>p4的动作原语包括</p>
<ul>
<li>set_field</li>
<li>copy_field</li>
<li>add_header</li>
<li>remove_header</li>
<li>increment</li>
<li>checksum</li>
</ul>
<h2 id="the-control-program">The Control Program</h2>
<p><img src="/img/2018-9-29-1.png" /></p>
<p>主要通过函数、条件、对table的引用来完成。如以下代码完成了对上图的构建。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">control main() &#123;</span><br><span class="line">    // Verify mTag state and port are consistent</span><br><span class="line">    table(source_check);</span><br><span class="line">    // If no error from source_check, continue</span><br><span class="line">    if (!defined(metadata.ingress_error)) &#123;</span><br><span class="line">        // Attempt to switch to end hosts</span><br><span class="line">        table(local_switching);</span><br><span class="line">        if (!defined(metadata.egress_spec)) &#123;</span><br><span class="line">            // Not a known local host; try mtagging</span><br><span class="line">            table(mTag_table);</span><br><span class="line">		&#125;</span><br><span class="line">        // Check for unknown egress state or</span><br><span class="line">        // bad retagging with mTag.</span><br><span class="line">        table(egress_check);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>p4</tag>
      </tags>
  </entry>
  <entry>
    <title>memsentry项目源码注释</title>
    <url>/memsentry-source-code.html</url>
    <content><![CDATA[<p>memsentry github地址：https://github.com/vusec/memsentry</p>
<span id="more"></span>
<p>主要是三个文件<code>BenchDomain.cpp</code>,<code>BenchDomainPost.cpp</code>和<code>MenSentry.cpp</code>。分别为向某些特定地方添加memory
access实现bench的目的，去掉之前的memory
access来达到不修改源文件的目的，和mensentry pass主体。</p>
<h1 id="benchdomain.cpp">BenchDomain.cpp</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Benchmark performance of domain-based methods by inserting</span></span><br><span class="line"><span class="comment"> * domain-switches at specified points. For benchmarking address-based methods,</span></span><br><span class="line"><span class="comment"> * this pass is not needed.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Usage:</span></span><br><span class="line"><span class="comment"> * This pass inserts memory accesses (tagged as &#x27;safe&#x27;) at the specified points</span></span><br><span class="line"><span class="comment"> * (e.g., at every call/ret). The MemSentry pass will then insert domain</span></span><br><span class="line"><span class="comment"> * switches for these memory accesses. Finally, the MemSentryBenchDomainPost</span></span><br><span class="line"><span class="comment"> * pass will remove the memory accesses, but leave the domain switches. This can</span></span><br><span class="line"><span class="comment"> * thus be used to benchmark the performance of domain-based approaches at</span></span><br><span class="line"><span class="comment"> * different frequencies of required switches.</span></span><br><span class="line"><span class="comment"> * Passes should thus be used as follows:</span></span><br><span class="line"><span class="comment"> *  -memsentry-benchdomain -memsentry -memsentry-benchdomain-post</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * -memsentry-benchdomain-points=[call-ret,icall,libfunc]</span></span><br><span class="line"><span class="comment"> * -memsentry-benchdomain-libfunc-file=&lt;file&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * call-ret: insert mem access before every call and return</span></span><br><span class="line"><span class="comment"> * icall:    insert mem access before every indirect call</span></span><br><span class="line"><span class="comment"> * libfunc:  insert mem access before every library function call from</span></span><br><span class="line"><span class="comment"> *           specified list.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG_TYPE <span class="string">&quot;memsentry-benchdomain&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;utils.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;memsentry-pass.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> llvm;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">points</span> &#123;</span><br><span class="line">    CALLRET,</span><br><span class="line">    ICALL,</span><br><span class="line">    LIBFUNC,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化名为Points的opt示例，用以在命令行中显示选项</span></span><br><span class="line"><span class="function">cl::opt&lt;points&gt; <span class="title">Points</span><span class="params">(<span class="string">&quot;memsentry-benchdomain-points&quot;</span>, <span class="comment">// name</span></span></span></span><br><span class="line"><span class="params"><span class="function">    cl::desc(<span class="string">&quot;What points should be treated as safe-region accesses:&quot;</span>), <span class="comment">// description</span></span></span></span><br><span class="line"><span class="params"><span class="function">    cl::values( <span class="comment">// listed values</span></span></span></span><br><span class="line"><span class="params"><span class="function">        clEnumValN(CALLRET, <span class="string">&quot;call-ret&quot;</span>, <span class="string">&quot;Every call and return&quot;</span>),</span></span></span><br><span class="line"><span class="params"><span class="function">        clEnumValN(ICALL,   <span class="string">&quot;icall&quot;</span>,    <span class="string">&quot;Indirect calls&quot;</span>),</span></span></span><br><span class="line"><span class="params"><span class="function">        clEnumValN(LIBFUNC, <span class="string">&quot;libfunc&quot;</span>,  <span class="string">&quot;Library functions (syscalls), specify list with -memsentry-benchdomain-libfunc-file.&quot;</span>),</span></span></span><br><span class="line"><span class="params"><span class="function">        clEnumValEnd), cl::init(CALLRET) <span class="comment">// default value</span></span></span></span><br><span class="line"><span class="params"><span class="function">        )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化名为LibFuncFile的opt示例，存放文件路径。文件中每一行包含一个函数名，被直接调用时被pass instrument</span></span><br><span class="line"><span class="function"><span class="type">static</span> cl::opt&lt;std::string&gt; <span class="title">LibFuncFile</span><span class="params">(<span class="string">&quot;memsentry-benchdomain-libfunc-file&quot;</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        cl::desc(<span class="string">&quot;Path to file containing (per line) functions that, when called, should be instrumented.&quot;</span>))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承ModulePass</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MemSentryBenchDomain</span> : <span class="keyword">public</span> ModulePass &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="type">static</span> <span class="type">char</span> ID;</span><br><span class="line">        <span class="built_in">MemSentryBenchDomain</span>() : <span class="built_in">ModulePass</span>(ID) &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">runOnModule</span><span class="params">(Module &amp;M)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        std::set&lt;std::string&gt; libFuncSet;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">initLibFuncs</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">handleInst</span><span class="params">(Instruction *I)</span></span>;</span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">shouldInstrCallRet</span><span class="params">(Instruction *I)</span></span>;</span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">shouldInstrICall</span><span class="params">(Instruction *I)</span></span>;</span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">shouldInstrLibFunc</span><span class="params">(Instruction *I)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 判断：</span></span><br><span class="line"><span class="comment"> * 当前指令call或者invoke直接调用了一个&quot;原文件中没有显式要求ignore的本地函数&quot;</span></span><br><span class="line"><span class="comment"> * 或者当前指令是一个return指令</span></span><br><span class="line"><span class="comment"> * 则返回true</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">MemSentryBenchDomain::shouldInstrCallRet</span><span class="params">(Instruction *I)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 判断是否为Call指令或者Invoke指令</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isa</span>&lt;CallInst&gt;(I) || <span class="built_in">isa</span>&lt;InvokeInst&gt;(I)) &#123;</span><br><span class="line">        <span class="comment">/* Try to only instrument calls where we can also insert the</span></span><br><span class="line"><span class="comment">         * corresponding switch at the return, to better simulate what a defense</span></span><br><span class="line"><span class="comment">         * could do. */</span></span><br><span class="line">        <span class="comment">// CallSite是CallInst和InvokeInst的一层封装，保留了两者的一些共有特征。</span></span><br><span class="line">        <span class="function">CallSite <span class="title">CS</span><span class="params">(I)</span></span>;</span><br><span class="line">        <span class="comment">// 拿到这条指令调用的函数</span></span><br><span class="line">        Function *F = CS.<span class="built_in">getCalledFunction</span>();</span><br><span class="line">        <span class="keyword">return</span> !F || <span class="built_in">shouldInstrument</span>(*F);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// return指令</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isa</span>&lt;ReturnInst&gt;(I))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前指令为间接调用（即不通过函数指针？）</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">MemSentryBenchDomain::shouldInstrICall</span><span class="params">(Instruction *I)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isa</span>&lt;CallInst&gt;(I) || <span class="built_in">isa</span>&lt;InvokeInst&gt;(I)) &#123;</span><br><span class="line">        <span class="function">CallSite <span class="title">CS</span><span class="params">(I)</span></span>;</span><br><span class="line">        Function *F = CS.<span class="built_in">getCalledFunction</span>();</span><br><span class="line">        <span class="keyword">return</span> F == <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前指令直接调用了一个FuncLib中的函数</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">MemSentryBenchDomain::shouldInstrLibFunc</span><span class="params">(Instruction *I)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isa</span>&lt;CallInst&gt;(I) || <span class="built_in">isa</span>&lt;InvokeInst&gt;(I)) &#123;</span><br><span class="line">        <span class="function">CallSite <span class="title">CS</span><span class="params">(I)</span></span>;</span><br><span class="line">        Function *F = CS.<span class="built_in">getCalledFunction</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!F)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (libFuncSet.<span class="built_in">find</span>(F-&gt;<span class="built_in">getName</span>()) != libFuncSet.<span class="built_in">end</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 处理每条指令</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MemSentryBenchDomain::handleInst</span><span class="params">(Instruction *I)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 根据Points的类型，判断是否需要处理</span></span><br><span class="line">    <span class="keyword">switch</span> (Points) &#123;</span><br><span class="line">        <span class="keyword">case</span> CALLRET: <span class="keyword">if</span> (!<span class="built_in">shouldInstrCallRet</span>(I)) <span class="keyword">return</span>; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ICALL:   <span class="keyword">if</span> (!<span class="built_in">shouldInstrICall</span>(I))   <span class="keyword">return</span>; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> LIBFUNC: <span class="keyword">if</span> (!<span class="built_in">shouldInstrLibFunc</span>(I)) <span class="keyword">return</span>; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>: <span class="built_in">assert</span>(<span class="number">0</span>); <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在I前面插入读取和储存指令</span></span><br><span class="line">    <span class="comment">// IRBuilder的主要功能是构建一系列IR，具体的语法以后再学习</span></span><br><span class="line">    IRBuilder&lt;&gt; <span class="built_in">B</span>(I);</span><br><span class="line">    Value *Val = B.<span class="built_in">getInt8</span>(<span class="number">0</span>);</span><br><span class="line">    Value *Ptr = Constant::<span class="built_in">getNullValue</span>(B.<span class="built_in">getInt8PtrTy</span>());</span><br><span class="line">    StoreInst *Dummy = B.<span class="built_in">CreateStore</span>(Val, Ptr, <span class="literal">true</span>);</span><br><span class="line">    Dummy-&gt;<span class="built_in">setMetadata</span>(<span class="string">&quot;memsentry.benchdomain.dummy&quot;</span>, MDNode::<span class="built_in">get</span>(I-&gt;<span class="built_in">getContext</span>(), &#123;&#125;));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memsentry_saferegion_access</span>(Dummy);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从LibFuncFile中按行载入需要instrument的函数名称的字符串</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MemSentryBenchDomain::initLibFuncs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::ifstream <span class="title">input</span><span class="params">(LibFuncFile)</span></span>;</span><br><span class="line">    std::string line;</span><br><span class="line">    <span class="keyword">while</span> (std::<span class="built_in">getline</span>(input, line))</span><br><span class="line">        libFuncSet.<span class="built_in">insert</span>(line);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (std::string a : libFuncSet)</span><br><span class="line">        <span class="built_in">errs</span>() &lt;&lt; <span class="string">&quot; F: &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载runOnModule，对每一个Module，</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">MemSentryBenchDomain::runOnModule</span><span class="params">(Module &amp;M)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果命令行里选择了LIBFUNC，则需要加载LibFunc文件</span></span><br><span class="line">    <span class="keyword">if</span> (Points == LIBFUNC)</span><br><span class="line">        <span class="built_in">initLibFuncs</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历Module中函数</span></span><br><span class="line">    <span class="keyword">for</span> (Function &amp;F : M) &#123;</span><br><span class="line">        <span class="comment">// 是否是原文件中没有显式要求ignore的本地函数</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">shouldInstrument</span>(F))</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// 遍历函数中instruction</span></span><br><span class="line">        <span class="keyword">for</span> (inst_iterator II = <span class="built_in">inst_begin</span>(&amp;F), E = <span class="built_in">inst_end</span>(&amp;F); II != E; ++II) &#123;</span><br><span class="line">            <span class="comment">// 通过dereference拿到</span></span><br><span class="line">            Instruction *I = &amp;*II;</span><br><span class="line">            <span class="built_in">handleInst</span>(I);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> MemSentryBenchDomain::ID = <span class="number">0</span>; <span class="comment">// ID会按照pass地址赋值，所以值不重要</span></span><br><span class="line"><span class="comment">// 通过初试化实例X的方法，注册pass</span></span><br><span class="line"><span class="function"><span class="type">static</span> RegisterPass&lt;MemSentryBenchDomain&gt; <span class="title">X</span><span class="params">(<span class="string">&quot;memsentry-benchdomain&quot;</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="string">&quot;MemSentry benchmarking pass for domain-based methods&quot;</span>)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="benchdomainpost.cpp">BenchDomainPost.cpp</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Should be used in conjuction with -memsentry-benchdomain, and should run</span></span><br><span class="line"><span class="comment"> * after -memsentry.</span></span><br><span class="line"><span class="comment"> * See BenchDomain.cpp for more details.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG_TYPE <span class="string">&quot;memsentry-benchdomain-post&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;utils.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;types.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> llvm;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承FunctionPass</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MemSentryBenchDomainPost</span> : <span class="keyword">public</span> FunctionPass &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="type">static</span> <span class="type">char</span> ID;</span><br><span class="line">        <span class="built_in">MemSentryBenchDomainPost</span>() : <span class="built_in">FunctionPass</span>(ID) &#123;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">runOnFunction</span><span class="params">(Function &amp;F)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除之前benchdomain插入的新的instruction，只保留mensentry插入的instruction</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">MemSentryBenchDomainPost::runOnFunction</span><span class="params">(Function &amp;F)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果是原文件中没有显式要求ignore的本地函数，就处理，否则返回false</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">shouldInstrument</span>(F))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    SmallVector&lt;Instruction *, <span class="number">16</span>&gt; DummyInstructions;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历instruction</span></span><br><span class="line">    <span class="keyword">for</span> (inst_iterator II = <span class="built_in">inst_begin</span>(&amp;F), E = <span class="built_in">inst_end</span>(&amp;F); II != E; ++II) &#123;</span><br><span class="line">        Instruction *I = &amp;*II;</span><br><span class="line">        <span class="comment">// 拿到metadata，如果是benchdomain插入的，添加到smallvector中</span></span><br><span class="line">        MDNode *MD = I-&gt;<span class="built_in">getMetadata</span>(<span class="string">&quot;memsentry.benchdomain.dummy&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (MD)</span><br><span class="line">            DummyInstructions.<span class="built_in">push_back</span>(I);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> changed = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (Instruction *I : DummyInstructions) &#123;</span><br><span class="line">        changed = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 删除指令</span></span><br><span class="line">        I-&gt;<span class="built_in">eraseFromParent</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回值代表函数被修改过</span></span><br><span class="line">    <span class="keyword">return</span> changed;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> MemSentryBenchDomainPost::ID = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 注册pass</span></span><br><span class="line"><span class="function"><span class="type">static</span> RegisterPass&lt;MemSentryBenchDomainPost&gt; <span class="title">X</span><span class="params">(<span class="string">&quot;memsentry-benchdomain-post&quot;</span>, <span class="string">&quot;MemSentry benchmarking pass for domain-based methods - cleanup pass&quot;</span>)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="mensentry.cpp">MenSentry.cpp</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * MemSentry: protecting safe regions on commodity hardware.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This pass applies a specified protection to a program. The points that are</span></span><br><span class="line"><span class="comment"> * allowed access should be specified by a previous pass (e.g., BenchDomain or a</span></span><br><span class="line"><span class="comment"> * defense). An alternative to this is to place all code accessing the safe</span></span><br><span class="line"><span class="comment"> * region in its own section, and specify the name of this section to this pass.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * For address-based approaches, all read, all writes or both read and writes</span></span><br><span class="line"><span class="comment"> * can be instrumented, as specified by the compile-time flag.</span></span><br><span class="line"><span class="comment"> * For certain domain-based approaches the safe-region is pre-allocated, and the</span></span><br><span class="line"><span class="comment"> * size of this region should be specified at compile time.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * -memsentry-prot-feature=[sfi*,mpx,vmfunc,crypt]</span></span><br><span class="line"><span class="comment"> * -memsentry-whitelist-section=memsentry_functions</span></span><br><span class="line"><span class="comment"> * -memsentry-rw=[r,w,rw*]                           # For sfi/mpx</span></span><br><span class="line"><span class="comment"> * -memsentry-verify-external-call-args=true         # For sfi/mpx</span></span><br><span class="line"><span class="comment"> * -memsentry-max-region-size=4096                   # For crypt</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG_TYPE <span class="string">&quot;memsentry&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;utils.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;memsentry-pass.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> llvm;</span><br><span class="line"></span><br><span class="line"><span class="function">cl::opt&lt;prot_method&gt; <span class="title">ProtMethod</span><span class="params">(<span class="string">&quot;memsentry-prot-method&quot;</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    cl::desc(<span class="string">&quot;Method of protecting safe region:&quot;</span>),</span></span></span><br><span class="line"><span class="params"><span class="function">    cl::values(</span></span></span><br><span class="line"><span class="params"><span class="function">        clEnumValN(SFI,    <span class="string">&quot;sfi&quot;</span>,    <span class="string">&quot;Software fault isolation (pointer masking)&quot;</span>),</span></span></span><br><span class="line"><span class="params"><span class="function">        clEnumValN(MPX,    <span class="string">&quot;mpx&quot;</span>,    <span class="string">&quot;Intel MPX (memory protection extensions)&quot;</span>),</span></span></span><br><span class="line"><span class="params"><span class="function">        clEnumValN(VMFUNC, <span class="string">&quot;vmfunc&quot;</span>, <span class="string">&quot;VM-Functions (requires vmfunc-enabled hypervisor like MemSentry&#x27;s Dune)&quot;</span>),</span></span></span><br><span class="line"><span class="params"><span class="function">        clEnumValN(MPK,    <span class="string">&quot;mpk&quot;</span>,    <span class="string">&quot;Intel MPK (memory protection keys). Upcoming, implemented as simulation&quot;</span>),</span></span></span><br><span class="line"><span class="params"><span class="function">        clEnumValN(CRYPT,  <span class="string">&quot;crypt&quot;</span>,  <span class="string">&quot;Encryption (using Intel AES-NI)&quot;</span>),</span></span></span><br><span class="line"><span class="params"><span class="function">        clEnumValEnd), cl::init(SFI))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">cl::opt&lt;readwrite&gt; <span class="title">ReadWrite</span><span class="params">(<span class="string">&quot;memsentry-rw&quot;</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    cl::desc(<span class="string">&quot;What type of memory accesses to protect when using address-based approaches:&quot;</span>),</span></span></span><br><span class="line"><span class="params"><span class="function">    cl::values(</span></span></span><br><span class="line"><span class="params"><span class="function">        clEnumValN(READWRITE, <span class="string">&quot;rw&quot;</span>, <span class="string">&quot;Reads and writes&quot;</span>),</span></span></span><br><span class="line"><span class="params"><span class="function">        clEnumValN(READ,      <span class="string">&quot;r&quot;</span>,  <span class="string">&quot;Reads only&quot;</span>),</span></span></span><br><span class="line"><span class="params"><span class="function">        clEnumValN(WRITE,     <span class="string">&quot;w&quot;</span>,  <span class="string">&quot;Writes only&quot;</span>),</span></span></span><br><span class="line"><span class="params"><span class="function">        clEnumValEnd), cl::init(READWRITE))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定白名单section</span></span><br><span class="line"><span class="function"><span class="type">static</span> cl::opt&lt;std::string&gt; <span class="title">WhitelistSection</span><span class="params">(<span class="string">&quot;memsentry-whitelist-section&quot;</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        cl::desc(<span class="string">&quot;Functions in this section are allowed access to the safe region&quot;</span>),</span></span></span><br><span class="line"><span class="params"><span class="function">        cl::init(<span class="string">&quot;memsentry_functions&quot;</span>))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> cl::opt&lt;<span class="type">bool</span>&gt; <span class="title">VerifyExternalCallArguments</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="string">&quot;memsentry-verify-external-call-args&quot;</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        cl::desc(<span class="string">&quot;For address-based methods, add checks to all pointer-type &quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="string">&quot;arguments to external functions (make sure uninstrumented &quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="string">&quot;libraries cannot use invalid pointers.&quot;</span>),</span></span></span><br><span class="line"><span class="params"><span class="function">        cl::init(<span class="literal">true</span>))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> cl::opt&lt;<span class="type">unsigned</span>&gt; <span class="title">MaxRegionSize</span><span class="params">(<span class="string">&quot;memsentry-max-region-size&quot;</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        cl::desc(<span class="string">&quot;For methods that need to pre-allocate the entire safe-region,&quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="string">&quot; the maximum size that should be supported.&quot;</span>),</span></span></span><br><span class="line"><span class="params"><span class="function">        cl::init(<span class="number">4096</span>))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * External function, used to mark instruction as safe from other passes.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">memsentry_saferegion_access</span><span class="params">(Instruction *I)</span> </span>&#123;</span><br><span class="line">    I-&gt;<span class="built_in">setMetadata</span>(MemSentrySafeMDName, MDNode::<span class="built_in">get</span>(I-&gt;<span class="built_in">getContext</span>(), &#123;&#125;));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从module中查找名为name的函数</span></span><br><span class="line"><span class="function"><span class="type">static</span> Function *<span class="title">getHelperFunc</span><span class="params">(Module *M, std::string name)</span> </span>&#123;</span><br><span class="line">    Function *F = M-&gt;<span class="built_in">getFunction</span>(name);</span><br><span class="line">    <span class="keyword">if</span> (!F) &#123;</span><br><span class="line">        <span class="built_in">errs</span>() &lt;&lt; <span class="string">&quot;Cannot find func &#x27;&quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot;&#x27;\n&quot;</span>;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> F;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把module中名为name的全局变量的初始值设为value</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setGV</span><span class="params">(Module &amp;M, StringRef name, <span class="type">size_t</span> value)</span> </span>&#123;</span><br><span class="line">    GlobalVariable* GV = M.<span class="built_in">getNamedGlobal</span>(name);</span><br><span class="line">    <span class="keyword">if</span>(!GV) &#123;</span><br><span class="line">        <span class="built_in">errs</span>() &lt;&lt; <span class="string">&quot;Error: no &quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot; global variable found\n&quot;</span>;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Type *Ty = GV-&gt;<span class="built_in">getType</span>()-&gt;<span class="built_in">getPointerElementType</span>();</span><br><span class="line">    Constant *Val = ConstantInt::<span class="built_in">get</span>(Ty, value);</span><br><span class="line">    GV-&gt;<span class="built_in">setInitializer</span>(Val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数参数是否有指针类型</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">hasPointerArg</span><span class="params">(Function *F)</span> </span>&#123;</span><br><span class="line">    FunctionType *FT = F-&gt;<span class="built_in">getFunctionType</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">unsigned</span> i = <span class="number">0</span>, n = FT-&gt;<span class="built_in">getNumParams</span>(); i &lt; n; i++) &#123;</span><br><span class="line">        Type *type = FT-&gt;<span class="built_in">getParamType</span>(i);</span><br><span class="line">        <span class="keyword">if</span> (type-&gt;<span class="built_in">isPointerTy</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回是否直接调用了白名单section中的函数</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">callsIntoWhitelistedFunction</span><span class="params">(CallSite &amp;CS)</span> </span>&#123;</span><br><span class="line">    Function *F = CS.<span class="built_in">getCalledFunction</span>();</span><br><span class="line">    <span class="keyword">if</span> (!F) <span class="comment">// Indirect call</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> F-&gt;<span class="built_in">getSection</span>() == WhitelistSection;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Determines whether an instruction should be allowed access to the safe region</span></span><br><span class="line"><span class="comment"> * (i.e., a previous pass has marked it as such).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isAllowedAccess</span><span class="params">(Instruction *I)</span> </span>&#123;</span><br><span class="line">    MDNode *MD = I-&gt;<span class="built_in">getMetadata</span>(MemSentrySafeMDName);</span><br><span class="line">    <span class="keyword">return</span> MD != <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Protection</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MemSentryPass</span> : <span class="keyword">public</span> ModulePass &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="type">static</span> <span class="type">char</span> ID;</span><br><span class="line">        <span class="built_in">MemSentryPass</span>() : <span class="built_in">ModulePass</span>(ID) &#123;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">runOnModule</span><span class="params">(Module &amp;M)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        Protection *prot;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">handleInst</span><span class="params">(Instruction *I)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Protection</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">        Module *M;</span><br><span class="line">        InlineFunctionInfo *inliningInfo;</span><br><span class="line">        <span class="keyword">enum</span> <span class="title class_">prot_method</span> protMethod;</span><br><span class="line">        std::string protMethodStr;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Protection</span>(Module *M, <span class="keyword">enum</span> prot_method protMethod) &#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;M = M;</span><br><span class="line">            <span class="keyword">this</span>-&gt;inliningInfo = <span class="keyword">new</span> <span class="built_in">InlineFunctionInfo</span>();</span><br><span class="line">            <span class="keyword">this</span>-&gt;protMethod = protMethod;</span><br><span class="line">            <span class="keyword">this</span>-&gt;protMethodStr = prot_method_strings[protMethod];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">virtual</span> ~<span class="built_in">Protection</span>() &#123; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">handleLoadInst</span><span class="params">(LoadInst *LI)</span> </span>&#123;</span><br><span class="line">            <span class="built_in">handleMemInst</span>(LI);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">handleStoreInst</span><span class="params">(StoreInst *SI)</span> </span>&#123;</span><br><span class="line">            <span class="built_in">handleMemInst</span>(SI);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">handleLoadIntrinsic</span><span class="params">(MemTransferInst *MTI)</span> </span>&#123;</span><br><span class="line">            <span class="built_in">handleMemInst</span>(MTI);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">handleStoreIntrinsic</span><span class="params">(MemIntrinsic *MI)</span> </span>&#123;</span><br><span class="line">            <span class="built_in">handleMemInst</span>(MI);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">handleMemInst</span><span class="params">(Instruction *I)</span> </span>&#123;</span><br><span class="line">            <span class="built_in">assert</span>(<span class="number">0</span> &amp;&amp; <span class="string">&quot;Not implemented&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">handleCallInst</span><span class="params">(CallSite &amp;CS)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Inline calls to _memsentry_&lt;protMethod&gt;*. This is done afterwards,</span></span><br><span class="line"><span class="comment">         * instead of immediately, so the optimizeBB function can more easily</span></span><br><span class="line"><span class="comment">         * see (and optimize) region changes.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">inlineHelperCalls</span><span class="params">(Function &amp;F)</span> </span>&#123;</span><br><span class="line">            <span class="type">bool</span> has_changed;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                has_changed = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">for</span> (inst_iterator it = <span class="built_in">inst_begin</span>(F), E = <span class="built_in">inst_end</span>(F); it != E; ++it) &#123;</span><br><span class="line">                    Instruction *I = &amp;(*it);</span><br><span class="line">                    CallInst *CI = <span class="built_in">dyn_cast</span>&lt;CallInst&gt;(I);</span><br><span class="line">                    <span class="comment">// 不是call指令</span></span><br><span class="line">                    <span class="keyword">if</span> (!CI)</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    Function *F = CI-&gt;<span class="built_in">getCalledFunction</span>();</span><br><span class="line">                    <span class="keyword">if</span> (!F)</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="comment">// 是memsentry插入的指令</span></span><br><span class="line">                    <span class="keyword">if</span> (F-&gt;<span class="built_in">getName</span>().<span class="built_in">startswith</span>(<span class="string">&quot;_memsentry_&quot;</span> + protMethodStr)) &#123;</span><br><span class="line">                        <span class="built_in">InlineFunction</span>(CI, *inliningInfo);</span><br><span class="line">                        has_changed = <span class="literal">true</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">while</span> (has_changed);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将应该处理的函数中的_memsentry_&lt;protMethod&gt;*全部inline</span></span><br><span class="line">        <span class="comment">// 此方法在domainprotection中被重载</span></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">postInstrumentation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (Function &amp;F : *M) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!<span class="built_in">shouldInstrument</span>(F, &amp;WhitelistSection))</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="built_in">inlineHelperCalls</span>(F);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// addressprotection即通过把地址空间分开，访问时通过pass对指针加mask的方式保护sensitive region</span></span><br><span class="line"><span class="comment">// 在static文件夹中inline实现了两个方法，分别是mpx和sfi</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AddressProtection</span> : <span class="keyword">public</span> Protection &#123;</span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">        Function *checkFunc; <span class="comment">// 具体mpx/sfi函数，其参数为一个指针</span></span><br><span class="line"></span><br><span class="line">        <span class="function">Value* <span class="title">verifyPtr</span><span class="params">(Value *ptrVal, Instruction *I)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 不处理</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isa</span>&lt;Constant&gt;(ptrVal)) &#123;</span><br><span class="line">                <span class="comment">//LOG_LINE(&quot;+ Ignoring constant &quot; &lt;&lt; *I);</span></span><br><span class="line">                <span class="keyword">return</span> ptrVal;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//LOG_LINE(&quot;Masking &quot; &lt;&lt; *I);</span></span><br><span class="line">            <span class="comment">// 使用IRBuilder在I前插入语句块</span></span><br><span class="line">            IRBuilder&lt;&gt; <span class="built_in">B</span>(I);</span><br><span class="line">            <span class="comment">// 把ptrVal转换成checkFunc的第一个参数的类型</span></span><br><span class="line">            Value *funcArg = B.<span class="built_in">CreateBitCast</span>(ptrVal, checkFunc-&gt;<span class="built_in">getFunctionType</span>()-&gt;<span class="built_in">getParamType</span>(<span class="number">0</span>));</span><br><span class="line">            <span class="comment">// 即语句masked = checkFunc(funcArg)</span></span><br><span class="line">            Value *masked = B.<span class="built_in">CreateCall</span>(checkFunc, &#123; funcArg &#125;);</span><br><span class="line">            <span class="comment">// 把masked转换成ptrVal的值</span></span><br><span class="line">            Value *casted = B.<span class="built_in">CreateBitCast</span>(masked, ptrVal-&gt;<span class="built_in">getType</span>());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 这里有个问题，不需要把ptrVal赋值为casted吗？</span></span><br><span class="line">            <span class="comment">// 最后ptrVal的值肯定被修改了（否则这个函数就没用了）</span></span><br><span class="line">            <span class="comment">// 但是怎么修改的呢？</span></span><br><span class="line">            <span class="keyword">return</span> casted;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">// 复用protection构造函数</span></span><br><span class="line">        <span class="comment">// checkFunc从module中找_memsentry_xxx，如_memsentry_mpx</span></span><br><span class="line">        <span class="built_in">AddressProtection</span>(Module *M, <span class="keyword">enum</span> prot_method protMethod)</span><br><span class="line">            : <span class="built_in">Protection</span>(M, protMethod) &#123;</span><br><span class="line">                std::string checkFuncName = <span class="string">&quot;_memsentry_&quot;</span> + protMethodStr;</span><br><span class="line">                checkFunc = <span class="built_in">getHelperFunc</span>(M, checkFuncName);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 下面四个函数很简单，将访问地址的相应指针通过调用verifyPtr加上mask</span></span><br><span class="line">        <span class="comment">// 加上mask的指针就能够访问sensitive region了</span></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">handleLoadInst</span><span class="params">(LoadInst *LI)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">isAllowedAccess</span>(LI))</span><br><span class="line">                LI-&gt;<span class="built_in">setOperand</span>(<span class="number">0</span>, <span class="built_in">verifyPtr</span>(LI-&gt;<span class="built_in">getOperand</span>(<span class="number">0</span>), LI));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">handleStoreInst</span><span class="params">(StoreInst *SI)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">isAllowedAccess</span>(SI))</span><br><span class="line">                SI-&gt;<span class="built_in">setOperand</span>(<span class="number">1</span>, <span class="built_in">verifyPtr</span>(SI-&gt;<span class="built_in">getOperand</span>(<span class="number">1</span>), SI));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">handleLoadIntrinsic</span><span class="params">(MemTransferInst *MTI)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">isAllowedAccess</span>(MTI))</span><br><span class="line">                MTI-&gt;<span class="built_in">setSource</span>(<span class="built_in">verifyPtr</span>(MTI-&gt;<span class="built_in">getRawSource</span>(), MTI));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">handleStoreIntrinsic</span><span class="params">(MemIntrinsic *MI)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">isAllowedAccess</span>(MI))</span><br><span class="line">                MI-&gt;<span class="built_in">setDest</span>(<span class="built_in">verifyPtr</span>(MI-&gt;<span class="built_in">getRawDest</span>(), MI));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Verify pointer args to external functions if flag is set. */</span></span><br><span class="line">        <span class="comment">// 处理call/invoke函数</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">handleCallInst</span><span class="params">(CallSite &amp;CS)</span> </span>&#123;</span><br><span class="line">            Function *F = CS.<span class="built_in">getCalledFunction</span>();</span><br><span class="line">            <span class="comment">// 用户指定不处理</span></span><br><span class="line">            <span class="keyword">if</span> (!VerifyExternalCallArguments)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            <span class="comment">// 调用了白名单中的函数</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">callsIntoWhitelistedFunction</span>(CS))</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            <span class="comment">// 不处理内联asm</span></span><br><span class="line">            <span class="keyword">if</span> (CS.<span class="built_in">isInlineAsm</span>())</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            <span class="comment">// 简洁调用</span></span><br><span class="line">            <span class="keyword">if</span> (!F)</span><br><span class="line">                <span class="keyword">return</span>; <span class="comment">/* Indirect call */</span></span><br><span class="line">            <span class="comment">// 不处理内部函数</span></span><br><span class="line">            <span class="keyword">if</span> (!F-&gt;<span class="built_in">isDeclaration</span>() &amp;&amp; !F-&gt;<span class="built_in">isDeclarationForLinker</span>())</span><br><span class="line">                <span class="keyword">return</span>; <span class="comment">/* Not external */</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 是intrinsic函数而且函数参数有指针，则需要判断</span></span><br><span class="line">            <span class="comment">// 只处理memcpy,memmove,memset,vastart,vacopy,vaend</span></span><br><span class="line">            <span class="keyword">if</span> (F-&gt;<span class="built_in">isIntrinsic</span>() &amp;&amp; <span class="built_in">hasPointerArg</span>(F)) &#123;</span><br><span class="line">                <span class="keyword">switch</span> (F-&gt;<span class="built_in">getIntrinsicID</span>()) &#123;</span><br><span class="line">                    <span class="keyword">case</span> Intrinsic::dbg_declare:</span><br><span class="line">                    <span class="keyword">case</span> Intrinsic::dbg_value:</span><br><span class="line">                    <span class="keyword">case</span> Intrinsic::lifetime_start:</span><br><span class="line">                    <span class="keyword">case</span> Intrinsic::lifetime_end:</span><br><span class="line">                    <span class="keyword">case</span> Intrinsic::invariant_start:</span><br><span class="line">                    <span class="keyword">case</span> Intrinsic::invariant_end:</span><br><span class="line">                    <span class="keyword">case</span> Intrinsic::eh_typeid_for:</span><br><span class="line">                    <span class="keyword">case</span> Intrinsic::eh_return_i32:</span><br><span class="line">                    <span class="keyword">case</span> Intrinsic::eh_return_i64:</span><br><span class="line">                    <span class="keyword">case</span> Intrinsic::eh_sjlj_functioncontext:</span><br><span class="line">                    <span class="keyword">case</span> Intrinsic::eh_sjlj_setjmp:</span><br><span class="line">                    <span class="keyword">case</span> Intrinsic::eh_sjlj_longjmp:</span><br><span class="line">                        <span class="keyword">return</span>; <span class="comment">/* No masking */</span></span><br><span class="line">                    <span class="keyword">case</span> Intrinsic::memcpy:</span><br><span class="line">                    <span class="keyword">case</span> Intrinsic::memmove:</span><br><span class="line">                    <span class="keyword">case</span> Intrinsic::memset:</span><br><span class="line">                    <span class="keyword">case</span> Intrinsic::vastart:</span><br><span class="line">                    <span class="keyword">case</span> Intrinsic::vacopy:</span><br><span class="line">                    <span class="keyword">case</span> Intrinsic::vaend:</span><br><span class="line">                        <span class="keyword">break</span>; <span class="comment">/* Continue with masking */</span></span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                        <span class="built_in">errs</span>() &lt;&lt; <span class="string">&quot;Unhandled intrinsic that takes pointer: &quot;</span> &lt;&lt; *F &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">                        <span class="keyword">break</span>; <span class="comment">/* Do mask to be sure. */</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 对所有参数中的指针执行verifyPtr进行mask</span></span><br><span class="line">            Instruction *I = CS.<span class="built_in">getInstruction</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">unsigned</span> i = <span class="number">0</span>, n = CS.<span class="built_in">getNumArgOperands</span>(); i &lt; n; i++) &#123;</span><br><span class="line">                Value *Arg = CS.<span class="built_in">getArgOperand</span>(i);</span><br><span class="line">                <span class="keyword">if</span> (Arg-&gt;<span class="built_in">getType</span>()-&gt;<span class="built_in">isPointerTy</span>())&#123;</span><br><span class="line">                    Value *MaskedArg = <span class="built_in">verifyPtr</span>(Arg, I);</span><br><span class="line">                    CS.<span class="built_in">getInstruction</span>()-&gt;<span class="built_in">setOperand</span>(i, MaskedArg);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// domainprotection在调用是设置相关区域有效（论文是这么说的）</span></span><br><span class="line"><span class="comment">// 通用的接口需要包括begin和end两个函数，一般是用于控制相应区域的active程度，类似于switch开关的实现</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DomainProtection</span> : <span class="keyword">public</span> Protection &#123;</span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">        Function *beginFunc, *endFunc;</span><br><span class="line">        std::string beginFuncName, endFuncName;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在instruction前后插入beginFunc和endFunc</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">changeDomain</span><span class="params">(Instruction *I)</span> </span>&#123;</span><br><span class="line">            CallInst *CIb = CallInst::<span class="built_in">Create</span>(beginFunc);</span><br><span class="line">            CIb-&gt;<span class="built_in">insertBefore</span>(I);</span><br><span class="line">            CallInst *CIe = CallInst::<span class="built_in">Create</span>(endFunc);</span><br><span class="line">            CIe-&gt;<span class="built_in">insertAfter</span>(I);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Optimizes a basicblock by merging regions which have no mem accesses</span></span><br><span class="line"><span class="comment">         * or so in between, thus eliminating needless switching of regions.</span></span><br><span class="line"><span class="comment">         * Returns true if the function needs to be called again: when a</span></span><br><span class="line"><span class="comment">         * modification to a BB is made, it cannot continue iterating over that</span></span><br><span class="line"><span class="comment">         * BB.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// 像上面说的，如果两组beginFunc/endFunc之间没有meminst，那么去掉中间的endFunc和beginFunc</span></span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">optimizeBB</span><span class="params">(BasicBlock &amp;BB)</span> </span>&#123;</span><br><span class="line">            <span class="type">bool</span> inMap = <span class="literal">false</span>; <span class="comment">// 是否在beginFunc和endFunc之间</span></span><br><span class="line">            <span class="type">bool</span> noMemSinceUnmap = <span class="literal">false</span>;</span><br><span class="line">            Instruction *lastUnmap = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (Instruction &amp;II : BB) &#123;</span><br><span class="line">                Instruction *I = &amp;II;</span><br><span class="line">                LoadInst *LI = <span class="built_in">dyn_cast</span>&lt;LoadInst&gt;(I);</span><br><span class="line">                StoreInst *SI = <span class="built_in">dyn_cast</span>&lt;StoreInst&gt;(I);</span><br><span class="line">                MemIntrinsic *MI = <span class="built_in">dyn_cast</span>&lt;MemIntrinsic&gt;(I);</span><br><span class="line">                CallInst *CI = <span class="built_in">dyn_cast</span>&lt;CallInst&gt;(I);</span><br><span class="line">                <span class="keyword">if</span> (LI || SI || MI)</span><br><span class="line">                    noMemSinceUnmap = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (CI) &#123;</span><br><span class="line">                    Function *F = CI-&gt;<span class="built_in">getCalledFunction</span>();</span><br><span class="line">                    <span class="keyword">if</span> (!F)</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">if</span> (F-&gt;<span class="built_in">getName</span>() == beginFuncName) &#123;</span><br><span class="line">                        <span class="built_in">assert</span>(!inMap);</span><br><span class="line">                        inMap = <span class="literal">true</span>;</span><br><span class="line">                        <span class="comment">// 之前有一个endFunc，存在lastUnmap中，并且没有LI/SI/MI</span></span><br><span class="line">                        <span class="comment">// 则把这个beginFunc和上一个endFunc去掉</span></span><br><span class="line">                        <span class="comment">// 然后直接返回</span></span><br><span class="line">                        <span class="keyword">if</span> (noMemSinceUnmap) &#123;</span><br><span class="line">                            lastUnmap-&gt;<span class="built_in">eraseFromParent</span>();</span><br><span class="line">                            I-&gt;<span class="built_in">eraseFromParent</span>();</span><br><span class="line">                            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (F-&gt;<span class="built_in">getName</span>() == endFuncName) &#123;</span><br><span class="line">                        <span class="built_in">assert</span>(inMap);</span><br><span class="line">                        inMap = <span class="literal">false</span>;</span><br><span class="line">                        noMemSinceUnmap = <span class="literal">true</span>;</span><br><span class="line">                        lastUnmap = I;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        noMemSinceUnmap = <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            (<span class="type">void</span>)inMap; <span class="comment">/* Silence compiler, assert doesn&#x27;t count as use. */</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="built_in">DomainProtection</span>(Module *M, <span class="keyword">enum</span> prot_method protMethod)</span><br><span class="line">            : <span class="built_in">Protection</span>(M, protMethod) &#123;</span><br><span class="line">                beginFuncName = <span class="string">&quot;_memsentry_&quot;</span> + protMethodStr + <span class="string">&quot;_begin&quot;</span>;</span><br><span class="line">                endFuncName = <span class="string">&quot;_memsentry_&quot;</span> + protMethodStr + <span class="string">&quot;_end&quot;</span>;</span><br><span class="line">                beginFunc = <span class="built_in">getHelperFunc</span>(M, beginFuncName);</span><br><span class="line">                endFunc = <span class="built_in">getHelperFunc</span>(M, endFuncName);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对domain来说load/store/intrinsic都是调用meminst</span></span><br><span class="line">        <span class="comment">// 对于每一条需要修改的instruction，调用changedomain</span></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">handleMemInst</span><span class="params">(Instruction *I)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isAllowedAccess</span>(I))</span><br><span class="line">                <span class="built_in">changeDomain</span>(I);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">handleCallInst</span><span class="params">(CallSite &amp;CS)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">callsIntoWhitelistedFunction</span>(CS))</span><br><span class="line">                <span class="built_in">changeDomain</span>(CS.<span class="built_in">getInstruction</span>());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">postInstrumentation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// Optimize domain-based instrumentation by removing unnecessary</span></span><br><span class="line">            <span class="comment">// switches back and forth.</span></span><br><span class="line">            <span class="keyword">for</span> (Function &amp;F : *M) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!<span class="built_in">shouldInstrument</span>(F, &amp;WhitelistSection))</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (BasicBlock &amp;BB : F) &#123;</span><br><span class="line">                    <span class="type">unsigned</span> cnt = <span class="number">0</span>;</span><br><span class="line">                    <span class="comment">// 优化直到没有需要合并的domain switch</span></span><br><span class="line">                    <span class="keyword">while</span> (<span class="built_in">optimizeBB</span>(BB)) cnt++;</span><br><span class="line">                    <span class="comment">//LOG_LINE(&quot;Optimized away &quot; &lt;&lt; cnt &lt;&lt; &quot; domain switches in &quot; &lt;&lt; F.getName());</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">inlineHelperCalls</span>(F);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据prot_method返回新建protection实例指针</span></span><br><span class="line"><span class="function"><span class="type">static</span> Protection* <span class="title">getProtectionInstance</span><span class="params">(Module *M, <span class="keyword">enum</span> prot_method protMethod)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(protMethod) &#123;</span><br><span class="line">        <span class="keyword">case</span> SFI:</span><br><span class="line">        <span class="keyword">case</span> MPX:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">AddressProtection</span>(M, protMethod);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> VMFUNC:</span><br><span class="line">        <span class="keyword">case</span> MPK:</span><br><span class="line">        <span class="keyword">case</span> CRYPT:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">DomainProtection</span>(M, protMethod);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">assert</span>(<span class="number">0</span> &amp;&amp; <span class="string">&quot;Not implemented!&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 处理四种指令：load、store、memintrinsic、call/invoke</span></span><br><span class="line"><span class="comment"> * 具体处理指令的步骤交给protection实例prot完成</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MemSentryPass::handleInst</span><span class="params">(Instruction *I)</span> </span>&#123;</span><br><span class="line">    ifcast(LoadInst, LI, I) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ReadWrite != WRITE)</span><br><span class="line">            prot-&gt;<span class="built_in">handleLoadInst</span>(LI);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> ifcast(StoreInst, SI, I) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ReadWrite != READ)</span><br><span class="line">            prot-&gt;<span class="built_in">handleStoreInst</span>(SI);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> ifcast(MemIntrinsic, MI, I) &#123;</span><br><span class="line">        MemTransferInst *MTI = <span class="built_in">dyn_cast</span>&lt;MemTransferInst&gt;(MI);</span><br><span class="line">        <span class="keyword">if</span> (MTI &amp;&amp; ReadWrite != WRITE)</span><br><span class="line">            prot-&gt;<span class="built_in">handleLoadIntrinsic</span>(MTI);</span><br><span class="line">        <span class="keyword">if</span> (ReadWrite != READ)</span><br><span class="line">            prot-&gt;<span class="built_in">handleStoreIntrinsic</span>(MI);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">isa</span>&lt;CallInst&gt;(I) || <span class="built_in">isa</span>&lt;InvokeInst&gt;(I)) &#123;</span><br><span class="line">        CallSite <span class="built_in">CS</span>(I);</span><br><span class="line">        prot-&gt;<span class="built_in">handleCallInst</span>(CS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载的runOnModule方法</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">MemSentryPass::runOnModule</span><span class="params">(Module &amp;M)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">LOG_LINE</span>(<span class="string">&quot;Starting, ProtMethod=&quot;</span> &lt;&lt; prot_method_strings[ProtMethod]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Fix up tracking variables so static lib knows compilation params</span></span><br><span class="line">    <span class="built_in">setGV</span>(M, <span class="string">&quot;_memsentry_prot_method&quot;</span>, ProtMethod);</span><br><span class="line">    <span class="built_in">setGV</span>(M, <span class="string">&quot;_memsentry_max_region_size&quot;</span>, MaxRegionSize);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get right instrumentation class (address-based or domain-based)</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;prot = <span class="built_in">getProtectionInstance</span>(&amp;M, ProtMethod);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历module中function</span></span><br><span class="line">    <span class="keyword">for</span> (Function &amp;F : M) &#123;</span><br><span class="line">        <span class="comment">// 在白名单则跳过</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">shouldInstrument</span>(F, &amp;WhitelistSection))</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">LOG_LINE</span>(<span class="string">&quot;Instrumenting &quot;</span> &lt;&lt; F.<span class="built_in">getName</span>());</span><br><span class="line">        <span class="keyword">for</span> (inst_iterator II = <span class="built_in">inst_begin</span>(&amp;F), E = <span class="built_in">inst_end</span>(&amp;F); II != E; ++II) &#123;</span><br><span class="line">            Instruction *I = &amp;*II;</span><br><span class="line">            <span class="comment">// 正式处理</span></span><br><span class="line">            <span class="built_in">handleInst</span>(I);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Optimize inserted instrumentation further if need be.</span></span><br><span class="line">    <span class="built_in">LOG_LINE</span>(<span class="string">&quot;Optimizing...&quot;</span>);</span><br><span class="line">    <span class="keyword">this</span>-&gt;prot-&gt;<span class="built_in">postInstrumentation</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> MemSentryPass::ID = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 注册</span></span><br><span class="line"><span class="function"><span class="type">static</span> RegisterPass&lt;MemSentryPass&gt; <span class="title">X</span><span class="params">(<span class="string">&quot;memsentry&quot;</span>, <span class="string">&quot;MemSentry pass&quot;</span>)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>llvm</tag>
      </tags>
  </entry>
  <entry>
    <title>ssh-permissions-are-too-open解决方法</title>
    <url>/ssh-permissions-are-too-open-error.html</url>
    <content><![CDATA[<p>前几天跑S6的框架，然后在一个ssh的环节报错。</p>
<span id="more"></span>
<h1 id="具体错误">具体错误</h1>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Permissions 0777 for &#x27;/Users/username/.ssh/id_rsa&#x27; are too open.</span><br><span class="line">It is recommended that your private key files are NOT accessible by others.</span><br><span class="line">This private key will be ignored.</span><br></pre></td></tr></table></figure>
<p>大概意思就是权限太松了。</p>
<h1 id="解决方法">解决方法</h1>
<p>只需要将<code>~/.ssh/id_rsa</code>的权限调整为只有自己可读就好了。</p>
<p>众所周知，<code>r=4</code>为可读，<code>w=2</code>为可写，<code>x=1</code>为可执行。三个分别是<code>user</code>、<code>group</code>和<code>other</code>。权限位相或即可。</p>
<p>所以</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chmod 400 ~/.ssh/id_rsa</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">或者</span></span><br><span class="line">chmod 600 ~/.ssh/id_rsa</span><br></pre></td></tr></table></figure>
<h1 id="参考资料">参考资料</h1>
<ul>
<li>https://stackoverflow.com/questions/9270734/ssh-permissions-are-too-open-error</li>
</ul>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>ssh</tag>
      </tags>
  </entry>
  <entry>
    <title>dpdk安装踩坑实录</title>
    <url>/dpdk-install.html</url>
    <content><![CDATA[<p>本次安装的版本是dpdk18.02.2，在ubuntu
14.04.5上安装，内核版本为4.4.0-31-generic。</p>
<span id="more"></span>
<h1 id="系统配置">系统配置</h1>
<p>需要：</p>
<ul>
<li>python、libnuma-dev等库（libnuma-dev直接通过<code>apt-get install libnuma-dev</code>）</li>
<li>大页内存（并mount）</li>
</ul>
<h1 id="dpdk的安装与下载">dpdk的安装与下载</h1>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget http://fast.dpdk.org/rel/dpdk-18.02.2.tar.xz</span><br><span class="line">tar -xvf dpdk-18.02.2.tar.xz</span><br><span class="line">cd dpdk-stable-18.02.2</span><br><span class="line">echo export RTE_SDK=$(pwd) &gt;&gt; ~/.bashrc</span><br><span class="line">echo export RTE_TARGET=x86_64-native-linuxapp-gcc &gt;&gt; ~/.bashrc</span><br><span class="line">source ~/.bashrc</span><br></pre></td></tr></table></figure>
<p>如果需要用到vhost-user驱动，要修改<code>config/common_base</code>，另其中的<code>CONFIG_RTE_LIBRTE_VHOST=y</code>。</p>
<p>安装dpdk</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make config T=$RTE_TARGET</span><br><span class="line">make T=$RTE_TARGET -j8</span><br><span class="line">make install T=$RTE_TARGET</span><br></pre></td></tr></table></figure>
<h1 id="配置大页内存">配置大页内存</h1>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修改/etc/default/grub</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在 GRUB_CMDLINE_LINUX_DEFAULT= 项中添加</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">default_hugepagesz=1GB hugepagesz=1G hugepages=8</span></span><br><span class="line">sudo update-grub</span><br><span class="line"></span><br><span class="line">mkdir -p /mnt/huge_1GB</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">可以直接mount，但每次重启都要重新配置</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">方法我就不写了</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">也可以让重启后有效</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">vim /etc/fstab</span></span><br><span class="line">nodev /mnt/huge_1GB hugetlbfs pagesize=1GB 0 0</span><br></pre></td></tr></table></figure>
<h1 id="加载驱动">加载驱动</h1>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo modprobe uio</span><br><span class="line">sudo insmod $RTE_SDK/x86_64-native-linuxapp-gcc/kmod/igb_uio.ko</span><br></pre></td></tr></table></figure>
<h1 id="绑定端口">绑定端口</h1>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看网卡信息，确定要绑定的网卡</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">RTE_SDK/usertools/dpdk-devbind.py -s</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">绑定网卡</span></span><br><span class="line">sudo $RTE_SDK/usertools/dpdk-devbind.py --bind=igb_uio 0000:82:00.0</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">后面的参数写-s出来的网卡信息最左边一行，当然也可以写名字之类的</span></span><br></pre></td></tr></table></figure>
<h1 id="一些注意事项">一些注意事项</h1>
<p>按上面方法配置，大页内存不会因为重启而要重新配置，但是模块和端口需要重新配置，<code>~/.bashrc</code>也需要重新<code>source</code>。</p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>dpdk</tag>
      </tags>
  </entry>
  <entry>
    <title>ycsb学习</title>
    <url>/ycsb-learning.html</url>
    <content><![CDATA[<p>主要总结Yahoo的数据库测试项目YCSB的使用（针对redis）。</p>
<span id="more"></span>
<p>github网址：https://github.com/brianfrankcooper/YCSB</p>
<h1 id="安装">安装</h1>
<ul>
<li><p>需要安装</p>
<ul>
<li>java</li>
<li>maven</li>
</ul></li>
<li><p>直接下载编译好的版本（不推荐）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -O --location https://github.com/brianfrankcooper/YCSB/releases/download/0.15.0/ycsb-0.15.0.tar.gz</span><br><span class="line">tar xfvz ycsb-0.15.0.tar.gz</span><br><span class="line">cd ycsb-0.15.0</span><br></pre></td></tr></table></figure></li>
<li><p>使用java或者maven编译</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone http://github.com/brianfrankcooper/YCSB.git</span><br><span class="line">cd YCSB</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">只安装redis测试部分</span></span><br><span class="line">mvn -pl com.yahoo.ycsb:redis-binding -am clean package</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装全部测试功能</span></span><br><span class="line">mvn clean package</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="概述">概述</h1>
<p>详细说明：https://github.com/brianfrankcooper/YCSB/wiki/Running-a-Workload</p>
<p>运行workload一共有六个部分</p>
<ul>
<li>设置数据库</li>
<li>选择合适的DB interface</li>
<li>选择合适的负载</li>
<li>选择合适的runtime parameters</li>
<li>load选择好的workload</li>
<li>run选择好的workload</li>
</ul>
<h2 id="设置数据库">设置数据库</h2>
<p>简要的说，就是创建名为<code>usertable</code>的表，因为ycsb默认的是对<code>usertable</code>进行相关操作。</p>
<p>而对于redis，则不需要相关的操作。</p>
<h2 id="选择合适的db-interface">选择合适的DB interface</h2>
<p>YCSB的操作是通过DB interface来实现的。最基本的DB
interface是<code>com.yahoo.ycsb.BasicDB</code>，会将输出输出到<code>System.out</code>里。可以通过继承DB
interface来自定义DB interface，也可以使用原有的DB interface。</p>
<h2 id="选择合适的workload">选择合适的workload</h2>
<p>当前版本提供了六种workload</p>
<h3 id="workload-a-update-heavy-workload">Workload A: Update heavy
workload</h3>
<p>This workload has a mix of 50/50 reads and writes. An application
example is a session store recording recent actions.</p>
<h3 id="workload-b-read-mostly-workload">Workload B: Read mostly
workload</h3>
<p>This workload has a 95/5 reads/write mix. Application example: photo
tagging; add a tag is an update, but most operations are to read
tags.</p>
<h3 id="workload-c-read-only">Workload C: Read only</h3>
<p>This workload is 100% read. Application example: user profile cache,
where profiles are constructed elsewhere (e.g., Hadoop).</p>
<h3 id="workload-d-read-latest-workload">Workload D: Read latest
workload</h3>
<p>In this workload, new records are inserted, and the most recently
inserted records are the most popular. Application example: user status
updates; people want to read the latest.</p>
<h3 id="workload-e-short-ranges">Workload E: Short ranges</h3>
<p>In this workload, short ranges of records are queried, instead of
individual records. Application example: threaded conversations, where
each scan is for the posts in a given thread (assumed to be clustered by
thread id).</p>
<h3 id="workload-f-read-modify-write">Workload F: Read-modify-write</h3>
<p>In this workload, the client will read a record, modify it, and write
back the changes. Application example: user database, where user records
are read and modified by the user or to record user activity.</p>
<h3 id="自定义workload">自定义Workload</h3>
<p>当然也可以自定义workload：https://github.com/brianfrankcooper/YCSB/wiki/Implementing-New-Workloads</p>
<p>一般常用的workload
property如<code>fieldcount</code>，<code>fieldlength</code>，<code>requestdistribution</code>等。</p>
<p>全部properties如下：</p>
<p>The property files used with the core workload generator can specify
values for the following properties:</p>
<ul>
<li><strong>fieldcount</strong>: the number of fields in a record
(default: 10)</li>
<li><strong>fieldlength</strong>: the size of each field (default:
100)</li>
<li><strong>readallfields</strong>: should reads read all fields (true)
or just one (false) (default: true)</li>
<li><strong>readproportion</strong>: what proportion of operations
should be reads (default: 0.95)</li>
<li><strong>updateproportion</strong>: what proportion of operations
should be updates (default: 0.05)</li>
<li><strong>insertproportion</strong>: what proportion of operations
should be inserts (default: 0)</li>
<li><strong>scanproportion</strong>: what proportion of operations
should be scans (default: 0)</li>
<li><strong>readmodifywriteproportion</strong>: what proportion of
operations should be read a record, modify it, write it back (default:
0)</li>
<li><strong>requestdistribution</strong>: what distribution should be
used to select the records to operate on – uniform, zipfian or latest
(default: uniform)</li>
<li><strong>maxscanlength</strong>: for scans, what is the maximum
number of records to scan (default: 1000)</li>
<li><strong>scanlengthdistribution</strong>: for scans, what
distribution should be used to choose the number of records to scan, for
each scan, between 1 and maxscanlength (default: uniform)</li>
<li><strong>insertorder</strong>: should records be inserted in order by
key (“ordered”), or in hashed order (“hashed”) (default: hashed)</li>
<li><strong>operationcount</strong>: number of operations to perform. If
set to zero then YCSB will run until maxexecutiontime is reached (which
by default is indefinitely). Note that if your workload or command line
parameters do not specify an operation count it will defualt to
zero.</li>
<li><strong>maxexecutiontime</strong>: maximum execution time in
seconds. The benchmark runs until either the operation count has
exhausted or the maximum specified time has elapsed, whichever is
earlier. If unspecified the defualt is to run indefinitely.</li>
<li><strong>table</strong>: the name of the table (default:
usertable)</li>
<li><strong>recordcount</strong>: number of records to load into the
database initially (default: 0)</li>
<li><strong>core_workload_insertion_retry_limit</strong>: number of
attempts for any failed insert operation (default: 0)</li>
<li><strong>core_workload_insertion_retry_interval</strong>: interval
between retries, in seconds (default: 3)</li>
</ul>
<h2 id="选择合适的runtime-parameter">选择合适的runtime parameter</h2>
<p>主要是</p>
<ul>
<li><code>-threads</code> : <strong>the number of client
threads</strong>.</li>
<li><code>-target</code> : <strong>the target number of operations per
second</strong>.</li>
<li><code>-s</code> : <strong>status</strong>.十秒打印一次状态</li>
</ul>
<h2 id="load-data">load data</h2>
<p>需要指定<code>redis.host</code>，<code>redis.port</code>。（可以指定<code>redis.password</code>和<code>redis.cluster</code>）</p>
<p>以上参数也可以在命令中指定，比如</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./bin/ycsb load redis -s -P workloads/workloada -p &quot;redis.host=127.0.0.1&quot; -p &quot;redis.port=6379&quot;</span><br></pre></td></tr></table></figure>
<h2 id="run-data">run data</h2>
<p>同理</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./bin/ycsb run redis -s -P workloads/workloada -p &quot;redis.host=127.0.0.1&quot; -p &quot;redis.port=6379&quot;</span><br></pre></td></tr></table></figure>
<h1 id="一些注意事项">一些注意事项</h1>
<h2 id="ycsb不支持对key的长度的修改">ycsb不支持对key的长度的修改</h2>
<p>issue网址：https://github.com/brianfrankcooper/YCSB/issues/587</p>
<p>ycsb对key命名规则是两种，<code>hashed</code>模式会生成<code>user</code>加固定长度的一串hash值，而<code>ordered</code>模式会按照<code>user</code>加顺序的方式来命名。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">insertorder=hashed      # user6284781860667377211, user8517097267634966620, user1820151046732198393</span><br><span class="line">insertorder=ordered     # user1, user2, user3032</span><br></pre></td></tr></table></figure>
<h2 id="ycsb运行时错误read-time-out">ycsb运行时错误：Read time out</h2>
<p>错误类似于</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redis.clients.jedis.exceptions.JedisConnectionException: java.net.SocketTimeoutException: Read timed out</span><br><span class="line"></span><br><span class="line">at redis.clients.jedis.Protocol.process(Protocol.java:79)</span><br><span class="line">at redis.clients.jedis.Protocol.read(Protocol.java:131)</span><br><span class="line">at redis.clients.jedis.Connection.getIntegerReply(Connection.java:188)</span><br><span class="line">at redis.clients.jedis.Jedis.sismember(Jedis.java:1266)</span><br></pre></td></tr></table></figure>
<p>当数据量变大之后，延时可能会变成几秒，而Jedis默认的是<code>2</code>秒的超时限制。</p>
<p>修改redis的src文件夹的RedisClient.java</p>
<p>将</p>
<p><code>jedis = new Jedis(host, port);</code></p>
<p>修改为</p>
<p><code>jedis = new Jedis(host, port, 10000);</code></p>
<p>即从默认的2秒上升为10秒。</p>
<h1 id="参考资料">参考资料</h1>
<ul>
<li>ycsb github地址：https://github.com/brianfrankcooper/YCSB</li>
<li>ycsb
流程介绍：https://github.com/brianfrankcooper/YCSB/wiki/Running-a-Workload</li>
<li>ycsb
workload介绍：https://github.com/brianfrankcooper/YCSB/wiki/Implementing-New-Workloads</li>
<li>ycsb 不支持对key长度的修改
issue网址：https://github.com/brianfrankcooper/YCSB/issues/587</li>
<li>ycsb 运行时错误：read time out
解决方法博客网址：https://github.com/brianfrankcooper/YCSB/issues/587</li>
</ul>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>ycsb</tag>
      </tags>
  </entry>
  <entry>
    <title>smartnic学习</title>
    <url>/smartnic-learning.html</url>
    <content><![CDATA[<p>总结smartNIC的相关知识，虽然没啥用（因为很多东西都是基于netdev
interface，而实验上好像是虚拟端口，所以不是一个东西），但是为了以后可能会用，还是记一下。</p>
<span id="more"></span>
<h1 id="agilio-smartnic-user-guide">Agilio smartNIC user guide</h1>
<p>文档地址https://help.netronome.com/support/solutions/articles/36000049975-basic-firmware-user-guide</p>
<h2 id="hardware-installation">hardware installation</h2>
<h3 id="validation">validation</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">lspci -d 19ee:</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">或</span></span><br><span class="line">lspci | grep -i Eth</span><br></pre></td></tr></table></figure>
<h2 id="driver-and-firmware">driver and firmware</h2>
<h3 id="validating-the-driver">validating the driver</h3>
<p>支持nfp driver的操作系统</p>
<table>
<thead>
<tr class="header">
<th>operating system</th>
<th>kernel version</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Ubuntu 16.04</td>
<td>4.11+(PF)</td>
</tr>
<tr class="even">
<td>RHEL 7.4+</td>
<td>Default</td>
</tr>
<tr class="odd">
<td>CentOS 7.4+</td>
<td>Default</td>
</tr>
</tbody>
</table>
<h4 id="confirm-upstreamed-nfp-driver">confirm upstreamed nfp
driver</h4>
<p>Confirm that your current Operating System contains the upstreamed
nfp module</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">modinfo nfp | head -3</span><br></pre></td></tr></table></figure>
<h4 id="confirm-thath-nfp-driver-is-loaded">confirm thath nfp driver is
loaded</h4>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">lsmode | grep nfp</span><br></pre></td></tr></table></figure>
<h3 id="smartnic-netdev-interfaces">smartNIC netdev interfaces</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">install agilio-nameing-policy package</span></span><br><span class="line">apt-get install agilio-naming-policy</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">nfp driver初始化之后就有新的netdev interfaces了</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">ip <span class="built_in">link</span></span></span><br></pre></td></tr></table></figure>
<h3 id="validating-the-firmware">validating the firmware</h3>
<p>固件的版本和smartNIC能实现的功能有关，固件应该在<code>/lib/firmware/netronome/</code></p>
<p>固件版本可以通过</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">ethtool -i <span class="string">&quot;netdev interface&quot;</span></span></span><br><span class="line">ethtool -i enp6s0np0</span><br></pre></td></tr></table></figure>
<h3 id="upgrading-the-firmware">upgrading the firmware</h3>
<h4 id="upgrading-firmware-via-the-netronome-repo">upgrading firmware
via the netronome repo</h4>
<p>通过附录一的配置之后，就可以这样安装</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apt-get install agilio-nic-firmware</span><br></pre></td></tr></table></figure>
<h4 id="upgrading-firmware-from-package-installation">upgrading firmware
from package installation</h4>
<p>从support上下载之后</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">dpkg -i agilio-nic-firmware-*.deb</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">reload driver to load new firmware</span></span><br><span class="line">rmmod nfp; modprobe nfp</span><br></pre></td></tr></table></figure>
<h2 id="using-the-linux-driver">using the linux driver</h2>
<h3 id="configuring-interface-media-mode">configuring interface media
mode</h3>
<p>对于老的内核不支持这样配置的，见附录C</p>
<h4 id="configuring-interface-link-speed">configuring interface
link-speed</h4>
<p>下面是agilio CX 25G smartNIC的示例</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># down respective interface(s)</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ip <span class="built_in">link</span> <span class="built_in">set</span> &lt;intf&gt; down</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># to set interface linkspeed to 10G</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ethtool -s &lt;intf&gt; speed 10000</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#NB. A driver reload is needed whenever a port’s speed is changed</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># reload driver for changes to take effect</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">rmmod nfp; modprobe nfp</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># to set interface linkspeed to 25G</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ethtool -s &lt;intf&gt; speed 25000</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># reload driver for changes to take effect</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">rmmod nfp; modprobe nfp</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># older driver/firmware may require a system reboot for changes to take effect</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">reboot</span></span><br></pre></td></tr></table></figure>
<h4 id="setting-interface-breakout-mode">setting interface breakout
mode</h4>
<p>下面的命令只适用于kernel版本4.13之后，为Agilio CX 40G/2x40G
SmartNICs的示例</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># determine card’s pci address</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">lspci -kd 19ee:</span></span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># devlink dev show</span></span></span><br><span class="line">pci/0000:06:00.0</span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># devlink port</span></span></span><br><span class="line">pci/0000:06:00.0/0: type eth netdev enp6s0np0</span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># to put the first 40G port in breakout mode(4x10G)</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">devlink port <span class="built_in">split</span> pci/0000:06:00.0/0 count 4</span></span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># to configure the second 40G port on a beryllium(2x40G interfaces) in breakout mode(4x10G)</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">devlink port <span class="built_in">split</span> pci/0000:06:00.0/4 count 4</span></span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># to configure a port from breakout mode(4x10G) to single mode(40G)</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">devlink port unsplit pci/0000:06:00.0/4</span></span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># reload driver for changes to take effect</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">rmmod nfp; modprobe nfp</span></span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># older driver/firmware versions may require a system reboot for changes to take effect</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">reboot</span></span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># after reboot the port should be in breakout mode e.g.</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">devlink port</span></span><br><span class="line">pci/0000:06:00.0/0: type eth netdev enp6s0np0s0 split_group 0</span><br><span class="line">pci/0000:06:00.0/1: type eth netdev enp6s0np0s1 split_group 0</span><br><span class="line">pci/0000:06:00.0/2: type eth netdev enp6s0np0s2 split_group 0</span><br><span class="line">pci/0000:06:00.0/3: type eth netdev enp6s0np0s3 split_group 0</span><br></pre></td></tr></table></figure>
<h3 id="confirm-connectivity">confirm connectivity</h3>
<h4 id="allocating-ip-addresses">allocating IP addresses</h4>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># assign IP address to interface</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ip address add 10.0.0.2/24 dev ens1np0</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ip <span class="built_in">link</span> <span class="built_in">set</span> ens1np0 up</span></span><br></pre></td></tr></table></figure>
<h4 id="pinging-interfaces">pinging interfaces</h4>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># ping IP from host on same subnet</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ping 10.0.0.2</span></span><br><span class="line"></span><br><span class="line">PING 10.0.0.2 (10.0.0.2) 56(84) bytes of data.</span><br><span class="line">64 bytes from 10.0.0.2: icmp_seq=3 ttl=64 time=0.067 ms</span><br><span class="line">64 bytes from 10.0.0.2: icmp_seq=4 ttl=64 time=0.062 ms</span><br></pre></td></tr></table></figure>
<h2 id="basic-performance-test">basic performance test</h2>
<p>除了IRQ和RSS的配置之外，就是iperf和iperf3的一些基本用法</p>
<h3 id="set-irq-affinity">set IRQ affinity</h3>
<p>IRQ用来平衡核之间的负载</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">wget https://raw.githubusercontent.com/Netronome/nfp-drv-kmods/master/tools/set_irq_affinity.sh</span></span><br></pre></td></tr></table></figure>
<p>样例输出</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">/nfp-drv-kmods/tools/set_irq_affinity.sh enXXXXnpX</span></span><br><span class="line"></span><br><span class="line">Device 0000:02:00.0 is on node 0 with cpus 0 1 2 3 4 5 6 7 8 9 20 21 22 23 24 25 26 27 28 29</span><br><span class="line">IRQ 181 to CPU 0     (irq: 00,00000001 xps: 03,00030003)</span><br><span class="line">IRQ 182 to CPU 1     (irq: 00,00000002 xps: 00,00000000)</span><br><span class="line">IRQ 183 to CPU 2     (irq: 00,00000004 xps: 0c,000c000c)</span><br><span class="line">IRQ 184 to CPU 3     (irq: 00,00000008 xps: 00,00000000)</span><br><span class="line">IRQ 185 to CPU 4     (irq: 00,00000010 xps: 30,00300030)</span><br><span class="line">IRQ 186 to CPU 5     (irq: 00,00000020 xps: 00,00000000)</span><br><span class="line">IRQ 187 to CPU 6     (irq: 00,00000040 xps: c0,00c000c0)</span><br><span class="line">IRQ 188 to CPU 7     (irq: 00,00000080 xps: 00,00000000)</span><br></pre></td></tr></table></figure>
<h3 id="install-iperf">install iperf</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apt-get install -y iperf</span><br></pre></td></tr></table></figure>
<h3 id="using-iperf">using iperf</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># server</span></span> </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">allocate ipv4 address to SmartNIC interface</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ip address add 10.0.0.1/24 dev ens1np0</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">launch iperf server</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">iperf -s</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># client</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">iperf -c 10.0.0.1 -P 4</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"> iperf -c 10.0.0.1 -P 4</span></span><br><span class="line">------------------------------------------------------------</span><br><span class="line">Client connecting to 10.1, TCP port 5001</span><br><span class="line">TCP window size: 85.0 KByte (default)</span><br><span class="line">------------------------------------------------------------</span><br><span class="line">[  5] local 10.0.0.2 port 56938 connected with 10.0.0.1 port 5001</span><br><span class="line">[  3] local 10.0.0.2 port 56932 connected with 10.0.0.1 port 5001</span><br><span class="line">[  4] local 10.0.0.2 port 56934 connected with 10.0.0.1 port 5001</span><br><span class="line">[  6] local 10.0.0.2 port 56936 connected with 10.0.0.1 port 5001</span><br><span class="line">[ ID] Interval       Transfer     Bandwidth</span><br><span class="line">[  6]  0.0-10.0 sec  11.9 GBytes  10.3 Gbits/sec</span><br><span class="line">[  3]  0.0-10.0 sec  9.85 GBytes  8.46 Gbits/sec</span><br><span class="line">[  4]  0.0-10.0 sec  11.9 GBytes  10.2 Gbits/sec</span><br><span class="line">[  5]  0.0-10.0 sec  10.2 GBytes  8.75 Gbits/sec</span><br><span class="line">[SUM] 0.0-10.0 sec  43.8 GBytes  37.7 Gbits/sec</span><br></pre></td></tr></table></figure>
<h3 id="using-iperf3">using iperf3</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># Server:</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">iperf3 -s -p 5001 &amp; iperf3 -s -p 5002 &amp; iperf3 -s -p 5003 &amp; iperf3 -s -p 5004 &amp;</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># Client:</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">iperf3 -c 102.0.0.6 -i 30 -p 5001 &amp; iperf3 -c 102.0.0.6 -i 30 -p 5002 &amp; iperf3 -c 102.0.0.6 -i 30 -p 5003 &amp; iperf3 -c 102.0.0.6 -i 30 -p 5004 &amp;</span></span><br><span class="line"></span><br><span class="line">Example output:</span><br><span class="line"></span><br><span class="line">[ ID] Interval           Transfer     Bandwidth</span><br><span class="line">[  5]   0.00-10.04  sec  0.00 Bytes  0.00 bits/sec                  sender</span><br><span class="line">[  5]   0.00-10.04  sec  9.39 GBytes  8.03 Gbits/sec                  receiver</span><br><span class="line">[  5]  10.00-10.04  sec  33.1 MBytes  7.77 Gbits/sec                 </span><br><span class="line">- - - - - - - - - - - - - - - - - - - - - - - - -</span><br><span class="line">[ ID] Interval           Transfer     Bandwidth</span><br><span class="line">[  5]   0.00-10.04  sec  0.00 Bytes  0.00 bits/sec                  sender</span><br><span class="line">[  5]   0.00-10.04  sec  9.86 GBytes  8.44 Gbits/sec                  receiver</span><br><span class="line">[  5]  10.00-10.04  sec  53.6 MBytes  11.8 Gbits/sec                 </span><br><span class="line">- - - - - - - - - - - - - - - - - - - - - - - - -</span><br><span class="line">[ ID] Interval           Transfer     Bandwidth</span><br><span class="line">[  5]   0.00-10.04  sec  0.00 Bytes  0.00 bits/sec                  sender</span><br><span class="line">[  5]   0.00-10.04  sec  11.9 GBytes  10.2 Gbits/sec                  receiver</span><br><span class="line">[  5]  10.00-10.04  sec  42.1 MBytes  9.43 Gbits/sec                 </span><br><span class="line">- - - - - - - - - - - - - - - - - - - - - - - - -</span><br><span class="line">[ ID] Interval           Transfer     Bandwidth</span><br><span class="line">[  5]   0.00-10.04  sec  0.00 Bytes  0.00 bits/sec                  sender</span><br><span class="line">[  5]   0.00-10.04  sec  10.2 GBytes  8.70 Gbits/sec                  receiver</span><br><span class="line"></span><br><span class="line">Total: 37.7 Gbits/sec</span><br><span class="line"></span><br><span class="line">95.49% of 40GbE link</span><br></pre></td></tr></table></figure>
<h2 id="basic-firmware-features">basic firmware features</h2>
<p>这节主要介绍用ethtool查看和配置一些smartNIC的接口参数。</p>
<h3 id="multiple-queues">multiple queues</h3>
<p>smartNIC支持多个TX和RX队列。<code>-I</code>可以看到当前的队列，<code>-L</code>可以配置当前的队列。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ethtool -l ens1np0</span></span><br><span class="line">Channel parameters for ens1np0:</span><br><span class="line">Pre-set maximums:</span><br><span class="line">RX:             20</span><br><span class="line">TX:             20</span><br><span class="line">Other:          2</span><br><span class="line">Combined:       20</span><br><span class="line">Current hardware settings:</span><br><span class="line">RX:             0</span><br><span class="line">TX:             12</span><br><span class="line">Other:          2</span><br><span class="line">Combined:       8</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ethtool -L &lt;intf&gt; rx 0 tx 0 combined 8</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># rx 代表receive ring interrupts</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># tx 代表transmit ring interrupts</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># combined 代表interrupts that service both</span></span></span><br></pre></td></tr></table></figure>
<h3 id="receive-side-scalingrss">receive side scaling(RSS)</h3>
<p><code>-n</code>查看，<code>-N</code>修改，<code>-x</code>和<code>-X</code>修改和配置key</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ethtool -n ens1np0 rx-flow-hash tcp4</span></span><br><span class="line">TCP over IPV4 flows use these fields for computing Hash flow key:</span><br><span class="line">IP SA</span><br><span class="line">IP DA</span><br><span class="line">L4 bytes 0 &amp; 1 [TCP/UDP src port]</span><br><span class="line">L4 bytes 2 &amp; 3 [TCP/UDP dst port]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ethtool -n ens1np0 rx-flow-hash udp4</span></span><br><span class="line">UDP over IPV4 flows use these fields for computing Hash flow key:</span><br><span class="line">IP SA</span><br><span class="line">IP DA</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ethtool -N &lt;intf&gt; rx-flow-hash tcp4 sdfn</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ethtool -N &lt;intf&gt; rx-flow-hash udp4 sdfn</span></span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># flag details</span></span></span><br><span class="line">rx-flow-hash tcp4|udp4|ah4|esp4|sctp4|tcp6|udp6|ah6|esp6|sctp6m|v|t|s|d|f|n|r...</span><br><span class="line">                  Configures the hash options for the specified flow type.</span><br><span class="line"> </span><br><span class="line">                  m   Hash on the Layer 2 destination address of the rx packet.</span><br><span class="line">                  v   Hash on the VLAN tag of the rx packet.</span><br><span class="line">                  t   Hash on the Layer 3 protocol field of the rx packet.</span><br><span class="line">                  s   Hash on the IP source address of the rx packet.</span><br><span class="line">                  d   Hash on the IP destination address of the rx packet.</span><br><span class="line">                  f   Hash on bytes 0 and 1 of the Layer 4 header of the rx packet.</span><br><span class="line">                  n   Hash on bytes 2 and 3 of the Layer 4 header of the rx packet.</span><br><span class="line">                  r   Discard  all  packets  of this flow type. When this option is set, all other options are ignored.</span><br><span class="line">                      </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ethtool -x &lt;intf&gt;</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ethtool -X &lt;intf&gt; &lt;hkey&gt;</span></span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># flag details</span></span></span><br><span class="line">-x --show-rxfh-indir</span><br><span class="line">Retrieves the receive flow hash indirection table.</span><br><span class="line">-X --set-rxfh-indir</span><br><span class="line">Configures the receive flow hash indirection table.</span><br></pre></td></tr></table></figure>
<h3 id="view-interface-parameters">view interface parameters</h3>
<p><code>-k</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ethtool -k ens1np0</span></span><br></pre></td></tr></table></figure>
<p>一些选项开关列举如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># rx-checksumming</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">enable</span> rx-checksumming</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ethtool -K ens1np0 rx on</span></span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">disable</span> rx-checksumming</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ethtool -K ens1np0 rx off</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#同理</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># tx-checksumming: tx</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># scatter and gather: sg</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># tcp-segmentation offload: tso</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># generic segmentation offload: gso</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># generic receive offload: gro</span></span></span><br></pre></td></tr></table></figure>
<h2 id="install-configuring-and-using-dpdk">install configuring and
using dpdk</h2>
<p>此处就略过了。</p>
<h2 id="附录内容">附录内容</h2>
<ul>
<li>A：netronome repositories，装上面提到的一些应用</li>
<li>B：安装out-of-tree NFP Driver</li>
<li>C：使用BSP package（上面提到了kernel较老的时候如何configure
interface）</li>
<li>D：使用dpdk-ns</li>
<li>E：updating flash</li>
<li>F：升级kernel</li>
<li>G：set_irq_affinity.sh Source（前面irq的替代脚本）</li>
</ul>
<h1 id="key-schedule">key schedule</h1>
<p>https://github.com/goodnighthy/KeySched/tree/master/key_schedule</p>
<h2
id="starting-and-stopping-using-upstartubuntu-14.04-and-centos-6">starting
and stopping using upstart(ubuntu 14.04 and centos 6)</h2>
<p>The RTE (NORMAL MODE) can be started/stopped by calling: start/stop
nfp-sdk6-rte</p>
<p>The RTE(DEBUG MODE) can be started/stopped by calling: start/stop
nfp-sdk6-rte-debug</p>
<p>The RTE(SIM MODE) can be started by calling: start/stop
nfp-sdk6-rte-sim Before using this Upstart configuration set NETRODIR to
the SDK6 simulator installation directory in the installed file
nfp-sdk6-rte-sim.conf</p>
<p>The Hardware Debug Server can be started by calling: start/stop
nfp-hwdbg-srv</p>
<p>To start the job at system ready uncomment the startup line in
nfp-sdk6-rte.conf, nfp-sdk6-rte-debug.conf or nfp-hwdbg-srv.conf in
/etc/init/.</p>
<p>To check whether the RTE job started correctly and is still running
use: status nfp-sdk6-rte (add -debug for DEBUG MODE or -sim for SIM
MODE) if the status show stop/waiting the RTE has stopped and an error
probably occurred. Look at either the Upstart job log in
/var/log/upstart/nfp-sdk6-rte.log (replace nfp-sdk6-rte with the job
name you started) or look in /var/log/nfp-sdk-rte.log for RTE only logs.
To have a continuous live log open either log with tail -f
<log_file_name>.log</p>
<h2
id="starting-and-stopping-using-systemdubuntu-16.04-and-centosrhel-7">starting
and stopping using systemd(ubuntu 16.04 and centos/rhel 7)</h2>
<p>The RTE (NORMAL MODE) can be started/stopped by calling: systemctl
start/stop nfp-sdk6-rte</p>
<p>The RTE(DEBUG MODE) can be started/stopped by calling: systemctl
start/stop pnfp-sdk6-rte-debug</p>
<p>The RTE(SIM MODE) can be started/stopped by calling: systemctl
start/stop nfp-sdk6-rte-sim Before using this Upstart configuration set
NETRODIR to the SDK6 simulator installation directory in the file
/usr/lib/systemd/system/nfp-sdk6-rte-sim.service</p>
<p>The Hardware Debug Server can be started/stopped by calling:
systemctl start/stop nfp-hwdbg-srv</p>
<p>To start the programs at system startup run the systemctl enable
command for the specified service: systemctl enable
nfp-sdk6-rte.service</p>
<p>To check whether the RTE service started correctly and is still
running use: systemctl status nfp-sdk6-rte (add -debug for DEBUG MODE or
-sim for SIM MODE) if the Active status show inactive (dead) the RTE has
stopped and an error probably occurred. Look at either the Systemd
journal or in the RTE logs for more detail on what error occurred.</p>
<p>For looking in the Systemd journal use the following command:
journalctl -u nfp-sdk6-rte replace nfp-sdk6-rte with the service name
you are using (ex nfp-sdk6-rte-debug or nfp-sdk6-rte-sim). Add the -f
argument to follow the journal for a live log.</p>
<p>For only logs generated by the RTE look /var/log/nfp-sdk-rte.log, for
continuous live log open the log with tail -f
/var/log/nfp-sdk-rte.log</p>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>smartnic</tag>
      </tags>
  </entry>
  <entry>
    <title>如何在matplotlib中使用中文</title>
    <url>/matplotlib-chinese-font.html</url>
    <content><![CDATA[<p>matplotlib原生是不支持中文的，但是因为画图中文方便一点，所以解决了一下这个问题。</p>
<span id="more"></span>
<h1 id="查看字体目录位置">查看字体目录位置</h1>
<p>首先进入python查看一下自己电脑的字体存放位置</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> matplotlib</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> matplotlib.matplotlib_fname()</span><br></pre></td></tr></table></figure>
<p>我的mac打印出的信息在</p>
<p><code>/Users/junxianshen/anaconda2/lib/python2.7/site-packages/matplotlib/mpl-data/matplotlibrc</code></p>
<p>字体目录就在</p>
<p><code>/Users/junxianshen/anaconda2/lib/python2.7/site-packages/matplotlib/mpl-data/fonts/ttf/</code></p>
<h1 id="下载并安装">下载并安装</h1>
<p>然后下载一个黑体简体中文字体，比如在这里下</p>
<ul>
<li>http://www.font5.com.cn/font_download.php?id=151&amp;part=1237887120</li>
</ul>
<p>然后复制到上面的字体目录中</p>
<h1 id="清空缓存">清空缓存</h1>
<p>接下来移除缓存，我的mac缓存目录在<code>~/.matplotlib/</code>，我是把里面的东西都删掉了。</p>
<h1 id="正式使用">正式使用</h1>
<p>在python中添加一些中文必须的东西，比如</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br></pre></td></tr></table></figure>
<p>然后使用的时候例如</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plt.plot(max_xval, max_cdf_yval)</span><br><span class="line">plt.xlabel(<span class="string">u&#x27;最大流量&#x27;</span>, fontproperties=<span class="string">&#x27;SimHei&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<ul>
<li>注意，<code>plt.xlabel()</code>中还可以添加<code>fontsize</code>属性，如<code>plt.xlabel(u'横轴：时间',fontproperties = 'SimHei',fontsize = 20)</code></li>
</ul>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>matplotlib</tag>
      </tags>
  </entry>
  <entry>
    <title>too many open files解决方法</title>
    <url>/too-many-open-files-error.html</url>
    <content><![CDATA[<p>解决一下linux系统同时打开过多文件的问题。</p>
<span id="more"></span>
<h1 id="方法一命令方式">方法一：命令方式</h1>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">这样就可以把当前用户的最大允许打开文件数量设置为2048了，但这种设置方法在重启后会还原为默认值。</span> </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">ulimit</span> -n命令非root用户只能设置到4096。</span> </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">想要设置到8192需要sudo权限或者root用户。</span></span><br><span class="line">ulimit -n 2048</span><br></pre></td></tr></table></figure>
<h1 id="方法二修改配置文件">方法二：修改配置文件</h1>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim /etc/security/limits.conf  </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">在最后加入</span>  </span><br><span class="line">* soft nofile 4096  </span><br><span class="line">* hard nofile 4096 </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">或者只加入</span></span><br><span class="line">* - nofile 8192</span><br></pre></td></tr></table></figure>
<p><code>*</code>代表所有用户，可根据需要设置某一用户</p>
<h1 id="检查程序文件数">检查程序文件数</h1>
<p>如果你对你的程序有一定的解的话，应该对程序打开文件数(链接数)上限有一定的估算，如果感觉数字异常，请使用第一步的<strong>lsof
-p 进程id &gt;
openfiles.log</strong>命令，获得当前占用句柄的全部详情进行分析。</p>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>同步服务器时间</title>
    <url>/sync-server-time.html</url>
    <content><![CDATA[<p>最近在make的时候发现server上的时间落后于我本地的时间，查了一下发现只要一条命令就能巧妙把server时间和互联网时间同步。</p>
<span id="more"></span>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo date -s &quot;$(wget -qSO- --max-redirect=0 google.com 2&gt;&amp;1 | grep Date: | cut -d&#x27; &#x27; -f5-8)Z&quot;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>修改或删除git submodule</title>
    <url>/git-submodule-modify.html</url>
    <content><![CDATA[<p>因为国外google代码仓库的东西访问不到，有可能导致submodule失效，需要修改
或者删除git子模块</p>
<span id="more"></span>
<h1 id="删除子模块">删除子模块</h1>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">逆初始化模块，其中&#123;MOD_NAME&#125;为模块目录，执行后可发现模块目录被清空</span></span><br><span class="line">git submodule deinit &#123;MOD_NAME&#125; </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除.gitmodules中记录的模块信息（--cached选项清除.git/modules中的缓存）</span></span><br><span class="line">git rm --cached &#123;MOD_NAME&#125; </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">提交更改到代码库，可观察到<span class="string">&#x27;.gitmodules&#x27;</span>内容发生变更</span></span><br><span class="line">git commit -am &quot;Remove a submodule.&quot; </span><br></pre></td></tr></table></figure>
<h1 id="更改子模块url">更改子模块url</h1>
<p>修改<code>.gitmodules</code>文件中对应模块的<code>url</code>属性，然后更新到<code>.git/config</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git submodule sync</span><br><span class="line">git commit -am &quot;Update submodule url.&quot;</span><br></pre></td></tr></table></figure>
<p>更低版本可能会不能自动更行<code>.git/config</code>，这时需要手动更新。</p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>关于将动态链接库函数拷贝到共享存储中运行的调研历程</title>
    <url>/dylib-to-sharemem.html</url>
    <content><![CDATA[<p>想要将动态链接库拷贝到共享存储里运行。</p>
<span id="more"></span>
<h1 id="相关编译过程概述">相关编译过程概述</h1>
<h2 id="概述---gcc工作的前三个阶段">概述 - GCC工作的前三个阶段</h2>
<h3 id="预编译">预编译</h3>
<ul>
<li>处理宏定义和文件包含。
<ul>
<li>宏定义：可以理解为递归地替换</li>
<li>文件包含：将包含在头文件中的声明拷贝到同一个文件内（<code>extern</code>）。但是这一步的本质是为了让编译器在生成.S文件时的符号表管理和语义检查不会出错。</li>
</ul></li>
</ul>
<h3 id="编译">编译</h3>
<p>编译器完成的工作有词法分析、语法分析、语义分析和代码生成（编译优化）。其中词法分析、语法分析和语义分析中涉及到错误处理。语法分析和语义分析还有代码生成涉及到符号表管理。其中，词法分析通过有限状态自动机分析、语法分析通过语法树的生成构建、语义分析则是对一些语义的检查（声明与定义、表达式和语句的正确性等）、代码生成就是翻译为汇编代码的过程。我们重点关注符号表管理。</p>
<ul>
<li>符号表管理：一个比较典型的符号表保存三个数据结构：变量表、函数表和串表。一种设计是，变量表和函数表使用哈希散列。串表保存的是程序中用到的字符串常量，用链表保存。</li>
</ul>
<h3 id="汇编">汇编</h3>
<p>汇编器的构造与编译器大同小异，因为它本质上是汇编的编译器，汇编器的符号来源有四种：数据、标签、宏、外部符号。</p>
<p>其中</p>
<ul>
<li>标签用于表示一段内存区域的地址，可能来自于函数名</li>
<li>外部符号用于表示引用的其他文件的数据或标签。</li>
</ul>
<p>此时，已经开始生成ELF格式文件，所以我们比较关心汇编器的符号表和重定位表的操作。</p>
<p>汇编允许符号的后置定义，所以汇编器需要对程序进行两次扫描。第一次扫描的时候，汇编器将引用的不在符号表中的符号作为外部符号处理，添加到符号表。当扫描到符号的定义时，使用该符号的定义信息替换原有的符号信息。</p>
<h4 id="表信息生成">表信息生成</h4>
<p>由前面的“ELF文件格式”一节可以知道可重定位目标文件的结构。其中段表、符号表和重定位表是最重要的三个表。</p>
<p>汇编器在第一次扫描时，将汇编信息的段信息导出为段表项，填充到段表。在第二遍扫描时，将符号信息导出为符号表项，填充到符号表，并在产生重定位的位置生成重定位项，填充重定位表。这里重点关注符号表和重定位表。</p>
<ul>
<li>符号表
<ul>
<li>符号表中记录的符号信息包括数据定义符号、宏符号、代码标签、函数名等。是为链接器、调试器、反汇编器等服务等。</li>
<li>符号表中记录符号名、所在段、段内偏移、类型（global, local）</li>
<li>对于外部符号，统一设定为全局符号（因为链接器会对全局符号进行符号解析，忽略局部符号的内容）（这是否是普遍的做法？），所在段设为未知。</li>
</ul></li>
<li>重定位表
<ul>
<li>重定位表中记录重定位符号名，重定位位置所在段，重定位位置段内偏移，重定位类型（相对/绝对）。【<strong>这里需要注意的是，和符号表的所在段和段内偏移不一样，符号表的这两个属性是符号被定义时的位置，而重定义表中的所在段和段内偏移的属性是在被使用时的位置</strong>】</li>
</ul></li>
</ul>
<h2 id="链接重定位和位置无关代码">链接重定位和位置无关代码</h2>
<p>在预编译、编译中所操作的符号表，并不是可执行文件所生成的符号表或重定位表。他们所用的符号表只是在编译过程中，为了执行语法和语义的错误检查而维护的中间变量。我们所真正关心的是最终生成的可执行文件的符号表和重定位表。链接主要负责的工作有地址空间分配、符号解析和重定位。链接器会将同名的段合并。</p>
<h3 id="链接过程中的重定位操作">链接过程中的重定位操作</h3>
<p>相对重定位和绝对重定位</p>
<ul>
<li>相对重定位：使用一个相对地址的引用</li>
<li>绝对重定位，使用一个绝对地址的引用
<ul>
<li>相对重定位地址=重定位符号地址-重定位位置+重定位位置数据内容=重定位符号地址-下一条指令地址</li>
</ul></li>
<li>【<strong>凡是对数据符号的引用都需要重定位，而对标签符号的引用，只有外部引用时才需要重定位。</strong>】调用本地声明的函数时，无论链接器如何调整<code>.text</code>字段，调用者和被调用者的相对位置都不会改变，所以不需要进行重定位。【如<code>call fun</code>，<code>call</code>指令内保存的相对地址不会变化。】</li>
<li>具体操作
<ul>
<li>对于一般的直接引用符号地址的指令会使用绝对地址重定位，对于函数调用或者跳转指令会使用相对地址重定位。（这是否是普遍的做法？）</li>
</ul></li>
</ul>
<h3 id="位置无关代码">位置无关代码</h3>
<p>位置无关代码，可以<strong>加载而无需重定位代码段部分</strong>。</p>
<h4 id="pic数据引用">PIC数据引用</h4>
<p>无论在内存中的何处加载一个目标模块，数据段与代码段的距离总是保持不变。所以PIC数据引用利用了这个特点。在数据段开始的地方设置了<strong>全局偏移量表</strong>（Global
Offset
Table，GOT）。每个被当前目标模块引用的全局数据目标都有一个8字节条目，编译器为GOT中的每个条目生成一个重定位记录。加载的时候，动态链接器会重定位【GOT中的每个条目】。这意味着动态链接器并不会重定位代码段的信息。</p>
<p>每个引用全局目标的目标模块都有自己的GOT。</p>
<h4 id="pic函数调用延迟绑定">PIC函数调用（延迟绑定）</h4>
<p>一个典型的应用程序常常使用共享库的很少一部分，而延迟绑定被提出解决这一问题。一个目标模块调用在共享库中的任何函数，就会有自己的GOT和PLT。延迟绑定依赖于两个部分</p>
<ul>
<li>过程连接表（PLT，Procedure Linkage Table）
<ul>
<li>PLT是以16字节代码为单位（一个条目）构成的数组。PLT[0]跳转到动态链接器中，PLT[1]初始化执行环境，PLT[2]开始的条目调用用户代码调用的函数。</li>
</ul></li>
<li>全局偏移量表（GOT）
<ul>
<li>GOT是以8字节的地址为单位构成的数组。GOT[0]和[1]包含动态链接器在解析函数地址时会使用的信息（addr
of .dynamic / addr of reloc
entries）。GOT[2]是动态链接器在<code>ld-linux.so</code>中的入口点。其余每一条对应于一个被调用的函数，其地址需要在运行时被解析。每个条目都有一条对应的PLT条目。初始时，每个GOT条目都指向对应PLT条目的第二条指令。</li>
</ul></li>
</ul>
<p>整个过程如下（如被调用函数为func）：</p>
<p>第一次执行<code>call func</code></p>
<ul>
<li>程序经过三次寻址（跳转到PLT，查询GOT条目，跳转到GOT条目对应地址），程序跳转到PLT对应表项的第二条指令。</li>
<li>PLT表项的第二条指令，将函数的ID压入栈中，然后跳转到PLT[0]。</li>
<li>PLT[0]压入GOT[1]存放的参数（是什么？），然后通过GOT[2]跳转到动态链接器中。动态链接器通过函数ID和GOT[1]参数确定函数<code>func</code>地址。用得到的地址重写对应GOT表中的地址。</li>
</ul>
<p>第二次执行<code>call func</code></p>
<ul>
<li>程序仍然经过上面三次寻址（跳转到PLT，查询GOT条目，跳转到GOT条目对应地址），此时GOT条目对应地址为<code>func</code>地址。</li>
</ul>
<p><strong>一个问题：延迟绑定修改后的GOT地址是相对地址还是绝对地址？经过思考，应为绝对地址</strong></p>
<h2 id="位置无关代码的函数内部调用">位置无关代码的函数内部调用</h2>
<p>使用一些简单的程序进行实验，对函数内部调用有基本的认识。使用<code>-R</code>查看dynamic
relocation
entries，使用<code>-d</code>查看反汇编结果，使用<code>-t</code>查看符号表内容，使用<code>-T</code>查看动态符号表内容。RIP寄存器存放着当前指令的地址。</p>
<h3 id="位rip寻址">64位RIP寻址</h3>
<p>在没有RIP寻址之前，ELF文件的PIC实现大费周章。必须先调用一个函数拿到PC，再加上偏移地址来获得变量的地址或者GOT位置。RIP寻址则解决了这一问题，这让代码可以通过<code>offset(%rip)</code>的形式偏移寻址。</p>
<h3 id="调用全局数据符号rip寻址">调用全局数据符号（RIP寻址） √</h3>
<p>和前面的讲述一致。完成编译的位置无关代码动态链接库调用static数据符号时，采用<code>offset(%rip)</code>的形式找到GOT对应表项。加载的时候GOT对应表项被链接器重定位。而符号本身（也许）是存放在全局变量区，属于数据段的一部分。同时，动态符号表中将产生对应的表项。尚不清楚全局数据符号的实际地址在什么得放，猜测存放在全局变量区。</p>
<h3 id="调用static数据符号rip寻址">调用static数据符号（RIP寻址） √</h3>
<p>和前面的讲述一致。但是在动态符号表中没有相应表项。猜测符号本身是存放在全局变量区，属于数据段的一部分。</p>
<h3 id="调用函数内部数据符号">调用函数内部数据符号 √</h3>
<p>栈内创建，《编译原理》书上说应通过程序运行时指针<code>sp</code>访问。实际是用栈底+偏移的方式。（<code>offset(%rbp)</code>）</p>
<h4
id="补充call汇编指令intel-user-manual.-p694">补充：call汇编指令（intel
user manual. P694）</h4>
<p><code>call</code>汇编指令有许多种形式，其中<code>e8 cd</code>代表字节
0xE8 后面跟着一个2字节操作数表示要跳转到的地址与当前地址的偏移量。
下文中的<code>call</code>在64位机器上启用<code>-fPIC</code>等编译选项后的执行方式正好为<code>e8 cd</code>格式。可以归纳在下面的情景下，都为相对寻址。</p>
<h3 id="调用外部函数符号">调用外部函数符号</h3>
<p>调用外部函数符号时，从汇编文件产生时，就已经有的<code>call xxx@PLT</code>的调用形式了。反编译得到的结果可以验证这一点，<strong>同时可以肯定，含有<code>@PLT</code>的应为绝对地址，因为最终是通过GOT获得了外部函数地址，而GOT本身是绝对地址。前提是使用位置无关方法</strong>。</p>
<h3 id="调用static函数符号">调用static函数符号</h3>
<p>调用static函数符号时，汇编文件产生的调用的形式为<code>call xxx</code>，同时汇编文件中没有<code>.globl</code>字段。程序运行时应为相对地址调用。</p>
<ul>
<li>假如开了<code>-O2</code>选项，编译器有可能（未验证过是否都会）将static声明的函数优化为硬代码插入调用其的函数中。凡是全局声明的函数，都不会被这样优化。</li>
</ul>
<h1
id="全局函数符号直接拷贝运行失败的原因">全局函数符号直接拷贝运行失败的原因</h1>
<p>对于调用了全局函数符号的代码，直接拷贝最根本的原因应该在于PLT表和GOT表可能产生的错误：</p>
<ul>
<li>函数首先通过相对偏移跳转到对应的PLT表。此时，【能否找到PLT表】成为第一个问题。问题的关键在于【PLT表是否已经被复制过来】。</li>
<li>接下来需要通过查找GOT表中对应的条目，跳转到对应的GOT表位置。【能否找到GOT表】成为第二个问题。（确定GOT表的位置时采用的寻址方式需要确定）</li>
<li>接下来GOT表记录的绝对地址应该是已经被修改过的。但是因为是绝对地址，所以【这个地址一定是错误的】，这是第三个问题。</li>
<li>如果调用任何数据符号，通过偏移寻址能否找到的关键则在于【有没有将数据段也一并拷贝过来】。</li>
</ul>
<h1 id="全局函数符号的拷贝解决">全局函数符号的拷贝解决</h1>
<p>首先需要保证【PLT表和数据段被拷贝到代码段的正确相对位置】，其次要保证【PLT表能够正确访问GOT表】，最后要保证【GOT表存储的值被全部修改】。</p>
<ul>
<li>预编译阶段：全部修改为static函数，这样所有东西都是通过相对寻址访问的了。</li>
<li>编译或汇编阶段：全部修改为static函数解析。</li>
<li>链接或加载阶段：编写llvm
pass，将动态链接库中函数按照static方式解析。</li>
<li>程序运行阶段：将动态链接库加载到我们想要拷贝到的地址。</li>
</ul>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>动态链接库</tag>
        <tag>共享存储</tag>
      </tags>
  </entry>
  <entry>
    <title>普通用户使用docker的权限问题</title>
    <url>/docker-cgroup.html</url>
    <content><![CDATA[<p>好像默认的只有<code>sudo</code>有docker相关权限，普通用户<code>docker run hello-world</code>会有权限报错，解决方法如下</p>
<span id="more"></span>
<h1 id="具体错误">具体错误</h1>
<p>如果直接运行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run hello-world</span><br></pre></td></tr></table></figure>
<p>产生错误</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker: Got permission denied while trying to connect to the Docker daemon socket at unix:///var/run/docker.sock: Post http://%2Fvar%2Frun%2Fdocker.sock/v1.35/containers/create: dial unix /var/run/docker.sock: connect: permission denied.See &#x27;docker run --help&#x27;.</span><br></pre></td></tr></table></figure>
<h1 id="解决方法">解决方法</h1>
<p>创建docker group</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo groupadd docker</span><br></pre></td></tr></table></figure>
<p>把当前用户加入docker group</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo usermod -aG docker $USER</span><br></pre></td></tr></table></figure>
<p>登出再登入，此时可以直接运行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run hello-world</span><br></pre></td></tr></table></figure>
<h1 id="参考资料">参考资料</h1>
<ul>
<li>https://stackoverflow.com/questions/48957195/how-to-fix-docker-got-permission-denied-issue</li>
</ul>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>ubuntu 服务器升降linux kernel踩坑实录</title>
    <url>/ubuntu-change-kernel-version.html</url>
    <content><![CDATA[<p>因为dpdk的驱动、docker等等要求，必须重装服务器的linux kernel</p>
<span id="more"></span>
<h1 id="安装linux-kernel并更新grub">安装linux kernel并更新grub</h1>
<p>先看看自己的linux kernel是什么版本：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">uname -r</span><br></pre></td></tr></table></figure>
<p>先前天舒帮我装了一个4.16的，太新了，apt里啥都没有，所以以后装的时候先<code>apt-cache search linux-generic</code>一下，不然真要命。</p>
<p>然后选一个看起来image和kernel header都有的版本吧。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt install linux-image-4.13.0-45-generic</span><br></pre></td></tr></table></figure>
<p>装完之后别急着重启……把grub改了！</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grep -A100 submenu  /boot/grub/grub.cfg |grep menuentry</span><br></pre></td></tr></table></figure>
<p>从输出的信息中选择需要的启动条目（从0开始）</p>
<p>然后修改<code>/etc/default/grub</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">GRUB_DEFAULT=”1&gt;3″</span><br></pre></td></tr></table></figure>
<p>1指的是进入高级选项，3指的是第三个启动项，如果不知道说什么的话
，重启的时候按shift看一下就懂了。</p>
<p>然后更新grub</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo /usr/sbin/update-grub</span><br></pre></td></tr></table></figure>
<p>最后重启</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo reboot</span><br></pre></td></tr></table></figure>
<h1 id="安装kernel-header">安装kernel header</h1>
<p>没什么好说的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get install linux-headers-$(uname -r)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>mac清理磁盘空间</title>
    <url>/mac-clear-disk-space.html</url>
    <content><![CDATA[<p>今天在clone git的时候居然提示我mac磁盘满了，我也是惊了。</p>
<span id="more"></span>
<h1 id="工具使用">工具使用</h1>
<p>用的是知乎上推荐的一款程序：OmniDiskSweeper。（后来看到据说可以终端上<code>du -sh *</code>就行）</p>
<p><img src="/img/2018-10-11.png" /></p>
<p>然后选要扫的磁盘就行了，具体就不截图了，太麻烦。</p>
<h1 id="进阶问题">进阶问题</h1>
<p>通过扫除居然发现显示的占用空间和实际磁盘工具给出的空间不一样，很神奇，一度以为自己中毒了。</p>
<p>后面发现是mac的时间机器的自动备份没有关。</p>
<p>一方面进到preference关掉mac的时间机器自动备份。</p>
<p>另一方面删除快照。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">显示所有snapshots</span></span><br><span class="line">sudo tmutil listlocalsnapshots /</span><br><span class="line"></span><br><span class="line">com.apple.TimeMachine.2018-10-11-113833</span><br><span class="line">com.apple.TimeMachine.2018-10-11-133802</span><br><span class="line">com.apple.TimeMachine.2018-10-11-143851</span><br><span class="line">com.apple.TimeMachine.2018-10-11-153801</span><br><span class="line">com.apple.TimeMachine.2018-10-11-163801</span><br><span class="line">com.apple.TimeMachine.2018-10-11-192918</span><br><span class="line">com.apple.TimeMachine.2018-10-11-205829</span><br><span class="line">com.apple.TimeMachine.2018-10-11-213912</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删掉相应的</span></span><br><span class="line">tmutil deletelocalsnapshots 2018-10-11-213912</span><br></pre></td></tr></table></figure>
<p>问题解决！</p>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>mac</tag>
      </tags>
  </entry>
  <entry>
    <title>dlopen源码分析</title>
    <url>/dlopen-source-code.html</url>
    <content><![CDATA[<p>研究一下dlopen的源码。</p>
<span id="more"></span>
<p>通过调用链的形式分析dlopen源码。</p>
<p>首先，函数的入口是<code>dlopen (const char *file, int mode)</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *</span><br><span class="line"><span class="title function_">dlopen</span> <span class="params">(<span class="type">const</span> <span class="type">char</span> *file, <span class="type">int</span> mode)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> __dlopen (file, mode, RETURN_ADDRESS (<span class="number">0</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数跳转到了<code>__dlopen</code>，这个函数实际上做了两件事情，将<code>struct dlopen_args args</code>赋值，然后运行<code>dlopen_doit</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *</span><br><span class="line">__dlopen (<span class="type">const</span> <span class="type">char</span> *file, <span class="type">int</span> mode DL_CALLER_DECL)</span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line"> </span><br><span class="line"><span class="meta"># <span class="keyword">ifdef</span> SHARED</span></span><br><span class="line">  <span class="keyword">return</span> _dlerror_run (dlopen_doit, &amp;args) ? <span class="literal">NULL</span> : args.new;</span><br><span class="line"><span class="meta"># <span class="keyword">else</span></span></span><br><span class="line">  <span class="keyword">if</span> (_dlerror_run (dlopen_doit, &amp;args))</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">return</span> args.new;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中结构体<code>struct dlopen_args</code>是这样的：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dlopen_args</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *file; <span class="comment">/* The arguments for dlopen_doit.  */</span></span><br><span class="line">  <span class="type">int</span> mode;</span><br><span class="line">  <span class="type">void</span> *new; <span class="comment">/* The return value of dlopen_doit.  */</span></span><br><span class="line">  <span class="type">const</span> <span class="type">void</span> *caller; <span class="comment">/* The return value of dlopen_doit.  */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>然后<code>dlopen_doit</code>的函数则是调用了<code>__dl_open</code>函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">dlopen_doit</span> <span class="params">(<span class="type">void</span> *a)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">dlopen_args</span> *<span class="title">args</span> =</span> (<span class="keyword">struct</span> dlopen_args *) a;</span><br><span class="line">	... </span><br><span class="line">  args-&gt;new = GLRO(dl_open) (args-&gt;file ?: <span class="string">&quot;&quot;</span>, args-&gt;mode | __RTLD_DLOPEN,</span><br><span class="line">			     args-&gt;caller,</span><br><span class="line">			     args-&gt;file == <span class="literal">NULL</span> ? LM_ID_BASE : NS,</span><br><span class="line">			     __dlfcn_argc, __dlfcn_argv, __environ);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于<code>__dl_open</code>函数，实际上调用了<code>dl_open_worker</code>函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *</span><br><span class="line">_dl_open (<span class="type">const</span> <span class="type">char</span> *file, <span class="type">int</span> mode, <span class="type">const</span> <span class="type">void</span> *caller_dlopen, Lmid_t nsid,</span><br><span class="line">	  <span class="type">int</span> argc, <span class="type">char</span> *argv[], <span class="type">char</span> *env[])</span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">dl_open_args</span> <span class="title">args</span>;</span></span><br><span class="line">  args.file = file;</span><br><span class="line">  args.mode = mode;</span><br><span class="line">  args.caller_dlopen = caller_dlopen;</span><br><span class="line">  args.caller_dl_open = RETURN_ADDRESS (<span class="number">0</span>);</span><br><span class="line">  args.<span class="built_in">map</span> = <span class="literal">NULL</span>;</span><br><span class="line">  args.nsid = nsid;</span><br><span class="line">  args.argc = argc;</span><br><span class="line">  args.argv = argv;</span><br><span class="line">  args.env = env;</span><br><span class="line"> </span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *objname;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *errstring;</span><br><span class="line">  <span class="type">bool</span> malloced;</span><br><span class="line">  <span class="type">int</span> errcode = _dl_catch_error (&amp;objname, &amp;errstring, &amp;malloced,</span><br><span class="line">				 dl_open_worker, &amp;args);</span><br><span class="line">	... </span><br><span class="line">  <span class="keyword">return</span> args.<span class="built_in">map</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中关键的数据存储在<code>struct dl_open_args</code>内，它的结构如下所示</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dl_open_args</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *file;</span><br><span class="line">  <span class="type">int</span> mode;</span><br><span class="line">  <span class="type">const</span> <span class="type">void</span> *caller_dlopen; <span class="comment">/* This is the caller of dlopen().  */</span></span><br><span class="line">  <span class="type">const</span> <span class="type">void</span> *caller_dl_open; <span class="comment">/* This is the caller of _dl_open().  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">map</span>;</span></span><br><span class="line">  Lmid_t nsid; <span class="comment">/* Namespace ID.  */</span></span><br><span class="line">  <span class="type">int</span> argc;</span><br><span class="line">  <span class="type">char</span> **argv;</span><br><span class="line">  <span class="type">char</span> **env;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在<code>dl_open_worker</code>函数中，最重要的加载数据一步是通过调用<code>_dl_map_object</code>实现的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Load the named object.  */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">new</span>;</span></span><br><span class="line">args-&gt;<span class="built_in">map</span> = new = _dl_map_object (call_map, file, lt_loaded, <span class="number">0</span>,</span><br><span class="line">		    mode | __RTLD_CALLMAP, args-&gt;nsid);</span><br></pre></td></tr></table></figure>
<p>接下来就是<code>_dl_map_object</code>函数，其主要的内容如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *</span></span><br><span class="line"><span class="class"><span class="title">internal_function</span></span></span><br><span class="line"><span class="class">_<span class="title">dl_map_object</span> (<span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">loader</span>, <span class="title">const</span> <span class="title">char</span> *<span class="title">name</span>,</span></span><br><span class="line"><span class="class">		<span class="title">int</span> <span class="title">type</span>, <span class="title">int</span> <span class="title">trace_mode</span>, <span class="title">int</span> <span class="title">mode</span>, <span class="title">Lmid_t</span> <span class="title">nsid</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">int</span> fd;</span><br><span class="line">  <span class="type">char</span> *realname;</span><br><span class="line">  <span class="type">char</span> *name_copy;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">l</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">filebuf</span> <span class="title">fb</span>;</span></span><br><span class="line">	...</span><br><span class="line">  <span class="comment">/* Look for this name among those already loaded.  */</span></span><br><span class="line">  <span class="keyword">for</span> (l = GL(dl_ns)[nsid]._ns_loaded; l; l = l-&gt;l_next)</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="comment">/* If the requested name matches the soname of a loaded object,</span></span><br><span class="line"><span class="comment">	 use that object.  Elide this check for names that have not</span></span><br><span class="line"><span class="comment">	 yet been opened.  */</span></span><br><span class="line">      <span class="keyword">if</span> (__builtin_expect (l-&gt;l_faked, <span class="number">0</span>) != <span class="number">0</span> </span><br><span class="line">          || __builtin_expect (l-&gt;l_removed, <span class="number">0</span>) != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">if</span> (!_dl_name_match_p (name, l))</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">char</span> *soname;</span><br><span class="line"> 				<span class="keyword">if</span> (__builtin_expect (l-&gt;l_soname_added, <span class="number">1</span>) </span><br><span class="line">            || l-&gt;l_info[DT_SONAME] == <span class="literal">NULL</span>)</span><br><span class="line">	    	<span class="keyword">continue</span>;</span><br><span class="line"> </span><br><span class="line">	  		soname = ((<span class="type">const</span> <span class="type">char</span> *) D_PTR (l, l_info[DT_STRTAB])</span><br><span class="line">		    	+ l-&gt;l_info[DT_SONAME]-&gt;d_un.d_val);</span><br><span class="line">	  		<span class="keyword">if</span> (<span class="built_in">strcmp</span> (name, soname) != <span class="number">0</span>)</span><br><span class="line">	    		<span class="keyword">continue</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">/* We have a match on a new name -- cache it.  */</span></span><br><span class="line">        add_name_to_object (l, soname);</span><br><span class="line">        l-&gt;l_soname_added = <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line"> </span><br><span class="line">      <span class="comment">/* We have a match.  */</span></span><br><span class="line">      <span class="keyword">return</span> l;</span><br><span class="line">  &#125;</span><br><span class="line"> 	</span><br><span class="line">  ...</span><br><span class="line">  fd = open_path (name, namelen, mode &amp; __RTLD_SECURE, </span><br><span class="line">                  &amp;main_map-&gt;l_rpath_dirs, &amp;realname, &amp;fb, </span><br><span class="line">                  loader ?: main_map, LA_SER_RUNPATH, &amp;found_other_class);</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">  l = _dl_new_object (name_copy, name, type, loader,</span><br><span class="line">				      mode, nsid)) </span><br><span class="line">	</span><br><span class="line">   <span class="keyword">return</span> _dl_map_object_from_fd (name, fd, &amp;fb, realname, loader, type, mode, &amp;stack_end, nsid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中文件是通过<code>open_path</code>调用的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">open_path</span> <span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="type">size_t</span> namelen, <span class="type">int</span> secure,</span></span><br><span class="line"><span class="params">	   <span class="keyword">struct</span> r_search_path_struct *sps, <span class="type">char</span> **realname,</span></span><br><span class="line"><span class="params">	   <span class="keyword">struct</span> filebuf *fbp, <span class="keyword">struct</span> link_map *loader, <span class="type">int</span> whatcode,</span></span><br><span class="line"><span class="params">	   <span class="type">bool</span> *found_other_class)</span></span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">for</span> (cnt = <span class="number">0</span>; fd == <span class="number">-1</span> &amp;&amp; cnt &lt; ncapstr; ++cnt) &#123;</span><br><span class="line"> 			fd = open_verify (buf, fbp, loader, whatcode, found_other_class, </span><br><span class="line">                        <span class="literal">false</span>);</span><br><span class="line">			...</span><br><span class="line">		&#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (fd != <span class="number">-1</span>) &#123;</span><br><span class="line">	  	*realname = (<span class="type">char</span> *) <span class="built_in">malloc</span> (buflen);</span><br><span class="line">	  	<span class="keyword">if</span> (*realname != <span class="literal">NULL</span>)</span><br><span class="line">	    &#123;</span><br><span class="line">	      <span class="built_in">memcpy</span> (*realname, buf, buflen);</span><br><span class="line">	      <span class="keyword">return</span> fd; <span class="comment">// here return the fd</span></span><br><span class="line">	    &#125;</span><br><span class="line">	  	<span class="keyword">else</span></span><br><span class="line">	    &#123;</span><br><span class="line">	      <span class="comment">/* No memory for the name, we certainly won&#x27;t be able</span></span><br><span class="line"><span class="comment">		 to load and link it.  */</span></span><br><span class="line">	      __close (fd);</span><br><span class="line">	      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	    &#125;</span><br><span class="line">		&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Remember whether we found anything.  */</span></span><br><span class="line">    any |= here_any;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (*++dirs != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中<code>open_verify</code>函数通过调用<code>__libc_read</code>对ELF文件的文件头实现了读写。</p>
<p>接下来是<code>_dl_new_object</code>函数，它主要初始化一个新的<code>struct link_map*</code>数据结构，并把它加入到<code>loader</code>对应的单链中（猜测）。</p>
<p>最重要的是函数<code>_dl_map_object_from_fd</code>。这个函数包括了</p>
<ul>
<li>对<code>link_map</code>的二次查找，是否已经存在映射了.so文件的</li>
<li>提取ELF头文件信息（程序入口地址，头文件信息等）</li>
<li>对phdr（程序头表进行遍历），根据每个程序头的type类型做具体的操作</li>
<li>进行映射</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">maplength = loadcmds[nloadcmds - <span class="number">1</span>].allocend - loadcmds[<span class="number">0</span>].mapstart;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Now process the load commands and map segments into memory.</span></span><br><span class="line"><span class="comment">   This is responsible for filling in:</span></span><br><span class="line"><span class="comment">   l_map_start, l_map_end, l_addr, l_contiguous, l_text_end, l_phdr</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">errstring = _dl_map_segments (l, fd, header, type, loadcmds, nloadcmds,</span><br><span class="line">  maplength, has_holes, loader);</span><br></pre></td></tr></table></figure>
<ul>
<li>调用<code>mprotect</code>修改内存权限</li>
<li>修改TLS等设置</li>
<li>修改符号表</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Set up the symbol hash table.  */</span></span><br><span class="line">_dl_setup_hash (l);</span><br></pre></td></tr></table></figure>
<p>最后，是<code>_dl_map_segments</code>函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* This is a position-independent shared object.  We can let the</span></span><br><span class="line"><span class="comment">   kernel map it anywhere it likes, but we must have space for all</span></span><br><span class="line"><span class="comment">   the segments in their specified positions relative to the first.</span></span><br><span class="line"><span class="comment">   So we map the first segment without MAP_FIXED, but with its</span></span><br><span class="line"><span class="comment">   extent increased to cover all the segments.  Then we remove</span></span><br><span class="line"><span class="comment">   access from excess portion, and there is known sufficient space</span></span><br><span class="line"><span class="comment">   there to remap from the later segments.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   As a refinement, sometimes we have an address that we would</span></span><br><span class="line"><span class="comment">   prefer to map such objects at; but this is only a preference,</span></span><br><span class="line"><span class="comment">   the OS can do whatever it likes. */</span></span><br><span class="line">ElfW(Addr) mappref</span><br><span class="line">  = (ELF_PREFERRED_ADDRESS (loader, maplength,</span><br><span class="line">                            c-&gt;mapstart &amp; GLRO(dl_use_load_bias))</span><br><span class="line">     - MAP_BASE_ADDR (l));</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Remember which part of the address space this object uses.  */</span></span><br><span class="line">l-&gt;l_map_start = (ElfW(Addr)) __mmap ((<span class="type">void</span> *) mappref, maplength,</span><br><span class="line">                                      c-&gt;prot,</span><br><span class="line">                                      MAP_COPY|MAP_FILE,</span><br><span class="line">                                      fd, c-&gt;mapoff);</span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely ((<span class="type">void</span> *) l-&gt;l_map_start == MAP_FAILED))</span><br><span class="line">  <span class="keyword">return</span> DL_MAP_SEGMENTS_ERROR_MAP_SEGMENT;</span><br><span class="line"></span><br><span class="line">l-&gt;l_map_end = l-&gt;l_map_start + maplength;</span><br><span class="line">l-&gt;l_addr = l-&gt;l_map_start - c-&gt;mapstart;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (has_holes)</span><br><span class="line">  <span class="comment">/* Change protection on the excess portion to disallow all access;</span></span><br><span class="line"><span class="comment">     the portions we do not remap later will be inaccessible as if</span></span><br><span class="line"><span class="comment">     unallocated.  Then jump into the normal segment-mapping loop to</span></span><br><span class="line"><span class="comment">     handle the portion of the segment past the end of the file</span></span><br><span class="line"><span class="comment">     mapping.  */</span></span><br><span class="line">  __mprotect ((<span class="type">caddr_t</span>) (l-&gt;l_addr + c-&gt;mapend),</span><br><span class="line">              loadcmds[nloadcmds - <span class="number">1</span>].mapstart - c-&gt;mapend,</span><br><span class="line">              PROT_NONE);</span><br><span class="line"></span><br><span class="line">l-&gt;l_contiguous = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">goto</span> postmap;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>系统</category>
      </categories>
      <tags>
        <tag>dlopen</tag>
      </tags>
  </entry>
  <entry>
    <title>2018年网络攻防小学期</title>
    <url>/network-attack-and-defense-semester.html</url>
    <content><![CDATA[<p>收录2018年网络攻防小学期的一些东西</p>
<span id="more"></span>
<ul>
<li><a
href="https://datawine.github.io/%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2%E5%B0%8F%E5%AD%A6%E6%9C%9F%EF%BC%88%E4%B8%80%EF%BC%89%E7%BD%91%E7%BB%9C%E4%BE%A6%E6%9F%A5%E4%B8%8E%E5%8F%96%E8%AF%81%E5%88%86%E6%9E%90.html">网络攻防小学期（一）网络侦查与取证分析</a></li>
<li><a
href="https://datawine.github.io/%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2%E5%B0%8F%E5%AD%A6%E6%9C%9F%EF%BC%88%E4%BA%8C%EF%BC%89%E4%BF%A1%E6%81%AF%E9%9A%90%E8%97%8F%E4%B8%8E%E4%BF%9D%E5%AF%86-%E5%AF%86%E7%A0%81.html">网络攻防小学期（二）信息隐藏与保密/密码</a></li>
<li><a
href="https://datawine.github.io/%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2%E5%B0%8F%E5%AD%A6%E6%9C%9F%EF%BC%88%E4%B8%89%EF%BC%89%E7%BD%91%E7%AB%99%E5%AE%89%E5%85%A8.html">网络攻防小学期（三）网站安全</a></li>
<li><a
href="https://datawine.github.io/%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2%E5%B0%8F%E5%AD%A6%E6%9C%9F%EF%BC%88%E5%9B%9B%EF%BC%89%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E4%B8%8E%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%BC%8F%E6%B4%9E.html">网络攻防小学期（四）逆向工程与二进制漏洞</a></li>
<li><a
href="https://datawine.github.io/%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2%EF%BC%9AM1%E5%8D%A1%E5%B0%8F%E5%AE%9E%E9%AA%8C.html">网络攻防：M1卡小实验</a></li>
<li><a
href="https://datawine.github.io/%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2%EF%BC%9AM1%E5%8D%A1%E5%A4%A7%E5%AE%9E%E9%AA%8C.html">网络攻防：M1卡大实验</a></li>
</ul>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>网络攻防</tag>
      </tags>
  </entry>
  <entry>
    <title>更换python默认版本</title>
    <url>/change-python-default-version.html</url>
    <content><![CDATA[<p>服务器上用的python默认是python3，需要改成python2</p>
<span id="more"></span>
<h1 id="方法一">方法一</h1>
<p>修改别名，在<code>~/.bashrc</code>中修改</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alias python=python2</span><br></pre></td></tr></table></figure>
<h1 id="方法二">方法二</h1>
<p>但是如果是在程序中调用有可能仍然是原来的python(具体我不太清楚，但是在跑一个项目的时候，他调用的python仍然是python3)。而且别的地方也找不到别名了。按理说python的默认版本应该是python2才对，但是也没有办法，只能硬着头皮改，毕竟项目还是要跑的啊。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">sudo update-alternatives --install &lt;<span class="built_in">link</span>&gt; &lt;name&gt; &lt;path&gt; &lt;priority&gt;</span></span><br><span class="line">sudo update-alternatives --install /usr/bin/python python /usr/bin/python2 10</span><br></pre></td></tr></table></figure>
<p>搞定。</p>
<h1 id="参考资料">参考资料</h1>
<ul>
<li>https://stackoverflow.com/questions/41986507/unable-to-set-default-python-version-to-python3-in-ubuntu</li>
</ul>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
</search>
